<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a>plotly.js (v1.26.1)</a>
</h1>
<h4>The open source javascript graphing library that powers plotly</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js">module plotly.js</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.js.geo">
            function <span class="apidocSignatureSpan">plotly.js.</span>js.geo
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.js.scrollbox">
            function <span class="apidocSignatureSpan">plotly.js.</span>js.scrollbox
            <span class="apidocSignatureSpan">(gd, container, id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.js.sieve">
            function <span class="apidocSignatureSpan">plotly.js.</span>js.sieve
            <span class="apidocSignatureSpan">(traces, separateNegativeValues, dontMergeOverlappingData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.js.ternary">
            function <span class="apidocSignatureSpan">plotly.js.</span>js.ternary
            <span class="apidocSignatureSpan">(options, fullLayout)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.anchor_utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.axes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.axis_ids</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.base_plot</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.bin_functions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.calendars</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.carpet</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.click</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.coerce</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.command</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.common</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.constraint_mapping</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.container_commands</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.dates</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.draw</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.events</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.extend</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.geo.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.geo_location_utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.geojson_utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.graph_interact</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.helpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.index</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.loggers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.manage_arrays</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.matrix</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.micropolar</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.micropolar_manager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.norm_functions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.pie</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.plot_config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.plotly</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.plots</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.polygon</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.queue</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.registry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.scrollbox.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.search</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.sieve.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.stats</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.subroutines</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.subtypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.svg_text_utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.ternary.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.topojson_utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.transform</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.</span>js.unhover</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.anchor_utils">module plotly.js.anchor_utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.anchor_utils.isBottomAnchor">
            function <span class="apidocSignatureSpan">plotly.js.anchor_utils.</span>isBottomAnchor
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.anchor_utils.isCenterAnchor">
            function <span class="apidocSignatureSpan">plotly.js.anchor_utils.</span>isCenterAnchor
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.anchor_utils.isMiddleAnchor">
            function <span class="apidocSignatureSpan">plotly.js.anchor_utils.</span>isMiddleAnchor
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.anchor_utils.isRightAnchor">
            function <span class="apidocSignatureSpan">plotly.js.anchor_utils.</span>isRightAnchor
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.axes">module plotly.js.axes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.autoBin">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>autoBin
            <span class="apidocSignatureSpan">(data, ax, nbins, is2d, calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.autoTicks">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>autoTicks
            <span class="apidocSignatureSpan">(ax, roughDTick)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.calcTicks">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>calcTicks
            <span class="apidocSignatureSpan">(ax)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.cleanId">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>cleanId
            <span class="apidocSignatureSpan">(id, axLetter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.clearTypes">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>clearTypes
            <span class="apidocSignatureSpan">(gd, traces)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.coercePosition">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>coercePosition
            <span class="apidocSignatureSpan">(containerOut, gd, coerce, axRef, attr, dflt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.coerceRef">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>coerceRef
            <span class="apidocSignatureSpan">(containerIn, containerOut, gd, attr, dflt, extraOption)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.counterLetter">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>counterLetter
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.doAutoRange">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>doAutoRange
            <span class="apidocSignatureSpan">(ax)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.doTicks">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>doTicks
            <span class="apidocSignatureSpan">(gd, axid, skipTitle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.expand">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>expand
            <span class="apidocSignatureSpan">(ax, data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.findSubplotsWithAxis">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>findSubplotsWithAxis
            <span class="apidocSignatureSpan">(subplots, ax)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.getAutoRange">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>getAutoRange
            <span class="apidocSignatureSpan">(ax)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.getFromId">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>getFromId
            <span class="apidocSignatureSpan">(gd, id, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.getFromTrace">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>getFromTrace
            <span class="apidocSignatureSpan">(gd, fullTrace, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.getSubplots">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>getSubplots
            <span class="apidocSignatureSpan">(gd, ax)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.id2name">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>id2name
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.list">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>list
            <span class="apidocSignatureSpan">(gd, axletter, only2d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.listIds">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>listIds
            <span class="apidocSignatureSpan">(gd, axletter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.makeClipPaths">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>makeClipPaths
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.minDtick">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>minDtick
            <span class="apidocSignatureSpan">(ax, newDiff, newFirst, allow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.saveRangeInitial">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>saveRangeInitial
            <span class="apidocSignatureSpan">(gd, overwrite)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.saveShowSpikeInitial">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>saveShowSpikeInitial
            <span class="apidocSignatureSpan">(gd, overwrite)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.setConvert">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>setConvert
            <span class="apidocSignatureSpan">(ax, fullLayout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.supplyLayoutDefaults">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>supplyLayoutDefaults
            <span class="apidocSignatureSpan">(layoutIn, layoutOut, fullData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.swap">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>swap
            <span class="apidocSignatureSpan">(gd, traces)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.tickFirst">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>tickFirst
            <span class="apidocSignatureSpan">(ax)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.tickIncrement">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>tickIncrement
            <span class="apidocSignatureSpan">(x, dtick, axrev, calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axes.tickText">
            function <span class="apidocSignatureSpan">plotly.js.axes.</span>tickText
            <span class="apidocSignatureSpan">(ax, x, hover)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.axes.</span>layoutAttributes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.axes.</span>subplotMatch</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.axis_ids">module plotly.js.axis_ids</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axis_ids.cleanId">
            function <span class="apidocSignatureSpan">plotly.js.axis_ids.</span>cleanId
            <span class="apidocSignatureSpan">(id, axLetter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axis_ids.getFromId">
            function <span class="apidocSignatureSpan">plotly.js.axis_ids.</span>getFromId
            <span class="apidocSignatureSpan">(gd, id, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axis_ids.getFromTrace">
            function <span class="apidocSignatureSpan">plotly.js.axis_ids.</span>getFromTrace
            <span class="apidocSignatureSpan">(gd, fullTrace, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axis_ids.id2name">
            function <span class="apidocSignatureSpan">plotly.js.axis_ids.</span>id2name
            <span class="apidocSignatureSpan">(id)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axis_ids.list">
            function <span class="apidocSignatureSpan">plotly.js.axis_ids.</span>list
            <span class="apidocSignatureSpan">(gd, axletter, only2d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axis_ids.listIds">
            function <span class="apidocSignatureSpan">plotly.js.axis_ids.</span>listIds
            <span class="apidocSignatureSpan">(gd, axletter)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.axis_ids.name2id">
            function <span class="apidocSignatureSpan">plotly.js.axis_ids.</span>name2id
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.base_plot">module plotly.js.base_plot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.base_plot.clean">
            function <span class="apidocSignatureSpan">plotly.js.base_plot.</span>clean
            <span class="apidocSignatureSpan">(newFullData, newFullLayout, oldFullData, oldFullLayout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.base_plot.plot">
            function <span class="apidocSignatureSpan">plotly.js.base_plot.</span>plot
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.base_plot.toSVG">
            function <span class="apidocSignatureSpan">plotly.js.base_plot.</span>toSVG
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.base_plot.</span>attr</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.base_plot.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.bin_functions">module plotly.js.bin_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.bin_functions.avg">
            function <span class="apidocSignatureSpan">plotly.js.bin_functions.</span>avg
            <span class="apidocSignatureSpan">(n, i, size, counterData, counts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.bin_functions.count">
            function <span class="apidocSignatureSpan">plotly.js.bin_functions.</span>count
            <span class="apidocSignatureSpan">(n, i, size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.bin_functions.max">
            function <span class="apidocSignatureSpan">plotly.js.bin_functions.</span>max
            <span class="apidocSignatureSpan">(n, i, size, counterData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.bin_functions.min">
            function <span class="apidocSignatureSpan">plotly.js.bin_functions.</span>min
            <span class="apidocSignatureSpan">(n, i, size, counterData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.bin_functions.sum">
            function <span class="apidocSignatureSpan">plotly.js.bin_functions.</span>sum
            <span class="apidocSignatureSpan">(n, i, size, counterData)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.calendars">module plotly.js.calendars</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.calendars.getCal">
            function <span class="apidocSignatureSpan">plotly.js.calendars.</span>getCal
            <span class="apidocSignatureSpan">(calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.calendars.handleDefaults">
            function <span class="apidocSignatureSpan">plotly.js.calendars.</span>handleDefaults
            <span class="apidocSignatureSpan">(contIn, contOut, attr, dflt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.calendars.handleTraceDefaults">
            function <span class="apidocSignatureSpan">plotly.js.calendars.</span>handleTraceDefaults
            <span class="apidocSignatureSpan">(traceIn, traceOut, coords, layout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.calendars.worldCalFmt">
            function <span class="apidocSignatureSpan">plotly.js.calendars.</span>worldCalFmt
            <span class="apidocSignatureSpan">(fmt, x, calendar)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.calendars.</span>CANONICAL_SUNDAY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.calendars.</span>CANONICAL_TICK</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.calendars.</span>DFLTRANGE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.calendars.</span>layoutAttributes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.calendars.</span>schema</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.calendars.</span>moduleType</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.calendars.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.carpet">module plotly.js.carpet</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">plotly.js.carpet.</span>animatable</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.carpet.calc">
            function <span class="apidocSignatureSpan">plotly.js.carpet.</span>calc
            <span class="apidocSignatureSpan">(gd, trace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.carpet.plot">
            function <span class="apidocSignatureSpan">plotly.js.carpet.</span>plot
            <span class="apidocSignatureSpan">(gd, plotinfo, cdcarpet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.carpet.supplyDefaults">
            function <span class="apidocSignatureSpan">plotly.js.carpet.</span>supplyDefaults
            <span class="apidocSignatureSpan">(traceIn, traceOut, dfltColor, fullLayout)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.carpet.</span>attributes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.carpet.</span>basePlotModule</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.carpet.</span>categories</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.carpet.</span>meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.carpet.</span>moduleType</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.carpet.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.click">module plotly.js.click</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.click.hasClickToShow">
            function <span class="apidocSignatureSpan">plotly.js.click.</span>hasClickToShow
            <span class="apidocSignatureSpan">(gd, hoverData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.click.onClick">
            function <span class="apidocSignatureSpan">plotly.js.click.</span>onClick
            <span class="apidocSignatureSpan">(gd, hoverData)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.coerce">module plotly.js.coerce</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.coerce.coerce">
            function <span class="apidocSignatureSpan">plotly.js.</span>coerce
            <span class="apidocSignatureSpan">(containerIn, containerOut, attributes, attribute, dflt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.coerce.coerce2">
            function <span class="apidocSignatureSpan">plotly.js.coerce.</span>coerce2
            <span class="apidocSignatureSpan">(containerIn, containerOut, attributes, attribute, dflt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.coerce.coerceFont">
            function <span class="apidocSignatureSpan">plotly.js.coerce.</span>coerceFont
            <span class="apidocSignatureSpan">(coerce, attr, dfltObj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.coerce.validate">
            function <span class="apidocSignatureSpan">plotly.js.coerce.</span>validate
            <span class="apidocSignatureSpan">(value, opts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.coerce.</span>valObjects</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.command">module plotly.js.command</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.command.computeAPICommandBindings">
            function <span class="apidocSignatureSpan">plotly.js.command.</span>computeAPICommandBindings
            <span class="apidocSignatureSpan">(gd, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.command.executeAPICommand">
            function <span class="apidocSignatureSpan">plotly.js.command.</span>executeAPICommand
            <span class="apidocSignatureSpan">(gd, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.command.hasSimpleAPICommandBindings">
            function <span class="apidocSignatureSpan">plotly.js.command.</span>hasSimpleAPICommandBindings
            <span class="apidocSignatureSpan">(gd, commandList, bindingsByValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.command.manageCommandObserver">
            function <span class="apidocSignatureSpan">plotly.js.command.</span>manageCommandObserver
            <span class="apidocSignatureSpan">(gd, container, commandList, onchange)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.common">module plotly.js.common</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.common.doesDirExist">
            function <span class="apidocSignatureSpan">plotly.js.common.</span>doesDirExist
            <span class="apidocSignatureSpan">(dirPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.common.doesFileExist">
            function <span class="apidocSignatureSpan">plotly.js.common.</span>doesFileExist
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.common.execCmd">
            function <span class="apidocSignatureSpan">plotly.js.common.</span>execCmd
            <span class="apidocSignatureSpan">(cmd, cb, errorCb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.common.formatTime">
            function <span class="apidocSignatureSpan">plotly.js.common.</span>formatTime
            <span class="apidocSignatureSpan">(date)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.common.getTimeLastModified">
            function <span class="apidocSignatureSpan">plotly.js.common.</span>getTimeLastModified
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.common.throwOnError">
            function <span class="apidocSignatureSpan">plotly.js.common.</span>throwOnError
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.common.touch">
            function <span class="apidocSignatureSpan">plotly.js.common.</span>touch
            <span class="apidocSignatureSpan">(filePath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.common.writeFile">
            function <span class="apidocSignatureSpan">plotly.js.common.</span>writeFile
            <span class="apidocSignatureSpan">(filePath, content, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.constraint_mapping">module plotly.js.constraint_mapping</a><ol>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.container_commands">module plotly.js.container_commands</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.container_commands.getRunCmd">
            function <span class="apidocSignatureSpan">plotly.js.container_commands.</span>getRunCmd
            <span class="apidocSignatureSpan">(isCI, commands)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.container_commands.</span>cdHome</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.container_commands.</span>cpIndex</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.container_commands.</span>dockerRun</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.container_commands.</span>injectEnv</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.container_commands.</span>ping</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.container_commands.</span>restart</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.container_commands.</span>setup</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.dates">module plotly.js.dates</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.dates.cleanDate">
            function <span class="apidocSignatureSpan">plotly.js.dates.</span>cleanDate
            <span class="apidocSignatureSpan">(v, dflt, calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.dates.dateTick0">
            function <span class="apidocSignatureSpan">plotly.js.dates.</span>dateTick0
            <span class="apidocSignatureSpan">(calendar, sunday)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.dates.dateTime2ms">
            function <span class="apidocSignatureSpan">plotly.js.dates.</span>dateTime2ms
            <span class="apidocSignatureSpan">(s, calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.dates.dfltRange">
            function <span class="apidocSignatureSpan">plotly.js.dates.</span>dfltRange
            <span class="apidocSignatureSpan">(calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.dates.findExactDates">
            function <span class="apidocSignatureSpan">plotly.js.dates.</span>findExactDates
            <span class="apidocSignatureSpan">(data, calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.dates.formatDate">
            function <span class="apidocSignatureSpan">plotly.js.dates.</span>formatDate
            <span class="apidocSignatureSpan">(x, fmt, tr, calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.dates.incrementMonth">
            function <span class="apidocSignatureSpan">plotly.js.dates.</span>incrementMonth
            <span class="apidocSignatureSpan">(ms, dMonth, calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.dates.isDateTime">
            function <span class="apidocSignatureSpan">plotly.js.dates.</span>isDateTime
            <span class="apidocSignatureSpan">(s, calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.dates.isJSDate">
            function <span class="apidocSignatureSpan">plotly.js.dates.</span>isJSDate
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.dates.ms2DateTime">
            function <span class="apidocSignatureSpan">plotly.js.dates.</span>ms2DateTime
            <span class="apidocSignatureSpan">(ms, r, calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.dates.ms2DateTimeLocal">
            function <span class="apidocSignatureSpan">plotly.js.dates.</span>ms2DateTimeLocal
            <span class="apidocSignatureSpan">(ms)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">plotly.js.dates.</span>MAX_MS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">plotly.js.dates.</span>MIN_MS</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.draw">module plotly.js.draw</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.draw.draw">
            function <span class="apidocSignatureSpan">plotly.js.</span>draw
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.draw.drawOne">
            function <span class="apidocSignatureSpan">plotly.js.draw.</span>drawOne
            <span class="apidocSignatureSpan">(gd, index)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.events">module plotly.js.events</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.events.init">
            function <span class="apidocSignatureSpan">plotly.js.events.</span>init
            <span class="apidocSignatureSpan">(plotObj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.events.purge">
            function <span class="apidocSignatureSpan">plotly.js.events.</span>purge
            <span class="apidocSignatureSpan">(plotObj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.events.triggerHandler">
            function <span class="apidocSignatureSpan">plotly.js.events.</span>triggerHandler
            <span class="apidocSignatureSpan">(plotObj, event, data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.extend">module plotly.js.extend</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.extend.extendDeep">
            function <span class="apidocSignatureSpan">plotly.js.extend.</span>extendDeep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.extend.extendDeepAll">
            function <span class="apidocSignatureSpan">plotly.js.extend.</span>extendDeepAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.extend.extendDeepNoArrays">
            function <span class="apidocSignatureSpan">plotly.js.extend.</span>extendDeepNoArrays
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.extend.extendFlat">
            function <span class="apidocSignatureSpan">plotly.js.extend.</span>extendFlat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.geo">module plotly.js.geo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geo.geo">
            function <span class="apidocSignatureSpan">plotly.js.</span>geo
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.geo.prototype">module plotly.js.geo.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geo.prototype.adjustLayout">
            function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>adjustLayout
            <span class="apidocSignatureSpan">(geoLayout, graphSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geo.prototype.drawGraticule">
            function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>drawGraticule
            <span class="apidocSignatureSpan">(selection, axisName, geoLayout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geo.prototype.drawLayout">
            function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>drawLayout
            <span class="apidocSignatureSpan">(geoLayout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geo.prototype.drawTopo">
            function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>drawTopo
            <span class="apidocSignatureSpan">(selection, layerName, geoLayout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geo.prototype.isLonLatOverEdges">
            function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>isLonLatOverEdges
            <span class="apidocSignatureSpan">(lonlat)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geo.prototype.makeFramework">
            function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>makeFramework
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geo.prototype.makePath">
            function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>makePath
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geo.prototype.makeProjection">
            function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>makeProjection
            <span class="apidocSignatureSpan">(geoLayout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geo.prototype.onceTopojsonIsLoaded">
            function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>onceTopojsonIsLoaded
            <span class="apidocSignatureSpan">(geoCalcData, geoLayout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geo.prototype.plot">
            function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>plot
            <span class="apidocSignatureSpan">(geoCalcData, fullLayout, promises)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geo.prototype.render">
            function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>render
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geo.prototype.styleLayer">
            function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>styleLayer
            <span class="apidocSignatureSpan">(selection, layerName, geoLayout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geo.prototype.styleLayout">
            function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>styleLayout
            <span class="apidocSignatureSpan">(geoLayout)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.geo_location_utils">module plotly.js.geo_location_utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geo_location_utils.locationToFeature">
            function <span class="apidocSignatureSpan">plotly.js.geo_location_utils.</span>locationToFeature
            <span class="apidocSignatureSpan">(locationmode, location, features)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.geojson_utils">module plotly.js.geojson_utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geojson_utils.calcTraceToLineCoords">
            function <span class="apidocSignatureSpan">plotly.js.geojson_utils.</span>calcTraceToLineCoords
            <span class="apidocSignatureSpan">(calcTrace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geojson_utils.makeBlank">
            function <span class="apidocSignatureSpan">plotly.js.geojson_utils.</span>makeBlank
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geojson_utils.makeLine">
            function <span class="apidocSignatureSpan">plotly.js.geojson_utils.</span>makeLine
            <span class="apidocSignatureSpan">(coords, trace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.geojson_utils.makePolygon">
            function <span class="apidocSignatureSpan">plotly.js.geojson_utils.</span>makePolygon
            <span class="apidocSignatureSpan">(coords, trace)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.graph_interact">module plotly.js.graph_interact</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.graph_interact.click">
            function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>click
            <span class="apidocSignatureSpan">(gd, evt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.graph_interact.getClosest">
            function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>getClosest
            <span class="apidocSignatureSpan">(cd, distfn, pointData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.graph_interact.getDistanceFunction">
            function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>getDistanceFunction
            <span class="apidocSignatureSpan">(mode, dx, dy, dxy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.graph_interact.hover">
            function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>hover
            <span class="apidocSignatureSpan">(gd, evt, subplot)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.graph_interact.inbox">
            function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>inbox
            <span class="apidocSignatureSpan">(v0, v1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.graph_interact.init">
            function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>init
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.graph_interact.isHoriz">
            function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>isHoriz
            <span class="apidocSignatureSpan">(fullData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.graph_interact.loneHover">
            function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>loneHover
            <span class="apidocSignatureSpan">(hoverItem, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.graph_interact.loneUnhover">
            function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>loneUnhover
            <span class="apidocSignatureSpan">(containerOrSelection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.graph_interact.supplyLayoutDefaults">
            function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>supplyLayoutDefaults
            <span class="apidocSignatureSpan">(layoutIn, layoutOut, fullData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.graph_interact.unhover">
            function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>unhover
            <span class="apidocSignatureSpan">(gd, evt, subplot)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.helpers">module plotly.js.helpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.helpers.cleanData">
            function <span class="apidocSignatureSpan">plotly.js.helpers.</span>cleanData
            <span class="apidocSignatureSpan">(data, existingData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.helpers.cleanLayout">
            function <span class="apidocSignatureSpan">plotly.js.helpers.</span>cleanLayout
            <span class="apidocSignatureSpan">(layout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.helpers.clearPromiseQueue">
            function <span class="apidocSignatureSpan">plotly.js.helpers.</span>clearPromiseQueue
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.helpers.coerceTraceIndices">
            function <span class="apidocSignatureSpan">plotly.js.helpers.</span>coerceTraceIndices
            <span class="apidocSignatureSpan">(gd, traceIndices)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.helpers.getGraphDiv">
            function <span class="apidocSignatureSpan">plotly.js.helpers.</span>getGraphDiv
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.helpers.hasParent">
            function <span class="apidocSignatureSpan">plotly.js.helpers.</span>hasParent
            <span class="apidocSignatureSpan">(aobj, attr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.helpers.manageArrayContainers">
            function <span class="apidocSignatureSpan">plotly.js.helpers.</span>manageArrayContainers
            <span class="apidocSignatureSpan">(np, newVal, undoit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.helpers.swapXYData">
            function <span class="apidocSignatureSpan">plotly.js.helpers.</span>swapXYData
            <span class="apidocSignatureSpan">(trace)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.index">module plotly.js.index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.OptionControl">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>OptionControl
            <span class="apidocSignatureSpan">(opt, optname)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.addStyleRule">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>addStyleRule
            <span class="apidocSignatureSpan">(selector, styleString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.aggNums">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>aggNums
            <span class="apidocSignatureSpan">(f, v, a, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.apply2DTransform">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>apply2DTransform
            <span class="apidocSignatureSpan">(transform)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.apply2DTransform2">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>apply2DTransform2
            <span class="apidocSignatureSpan">(transform)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.bBoxIntersect">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>bBoxIntersect
            <span class="apidocSignatureSpan">(a, b, pad)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.cleanDate">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>cleanDate
            <span class="apidocSignatureSpan">(v, dflt, calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.cleanNumber">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>cleanNumber
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.coerce">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>coerce
            <span class="apidocSignatureSpan">(containerIn, containerOut, attributes, attribute, dflt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.coerce2">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>coerce2
            <span class="apidocSignatureSpan">(containerIn, containerOut, attributes, attribute, dflt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.coerceFont">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>coerceFont
            <span class="apidocSignatureSpan">(coerce, attr, dfltObj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.constrain">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>constrain
            <span class="apidocSignatureSpan">(v, v0, v1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.containsAny">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>containsAny
            <span class="apidocSignatureSpan">(s, fragments)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.dateTick0">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>dateTick0
            <span class="apidocSignatureSpan">(calendar, sunday)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.dateTime2ms">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>dateTime2ms
            <span class="apidocSignatureSpan">(s, calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.dfltRange">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>dfltRange
            <span class="apidocSignatureSpan">(calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.distinctVals">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>distinctVals
            <span class="apidocSignatureSpan">(valsIn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.dot">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>dot
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.ensureArray">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>ensureArray
            <span class="apidocSignatureSpan">(out, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.error">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>error
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.expandObjectPaths">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>expandObjectPaths
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.extendDeep">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>extendDeep
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.extendDeepAll">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>extendDeepAll
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.extendDeepNoArrays">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>extendDeepNoArrays
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.extendFlat">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>extendFlat
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.filterUnique">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>filterUnique
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.filterVisible">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>filterVisible
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.findBin">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>findBin
            <span class="apidocSignatureSpan">(val, bins, linelow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.findExactDates">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>findExactDates
            <span class="apidocSignatureSpan">(data, calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.formatDate">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>formatDate
            <span class="apidocSignatureSpan">(x, fmt, tr, calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.getPlotDiv">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>getPlotDiv
            <span class="apidocSignatureSpan">(el)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.identity">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>identity
            <span class="apidocSignatureSpan">(d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.incrementMonth">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>incrementMonth
            <span class="apidocSignatureSpan">(ms, dMonth, calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.init2dArray">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>init2dArray
            <span class="apidocSignatureSpan">(rowLength, colLength)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.interp">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>interp
            <span class="apidocSignatureSpan">(arr, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.isArray">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>isArray
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.isD3Selection">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>isD3Selection
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.isDateTime">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>isDateTime
            <span class="apidocSignatureSpan">(s, calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.isIE">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>isIE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.isJSDate">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>isJSDate
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.isPlainObject">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>isPlainObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.isPlotDiv">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>isPlotDiv
            <span class="apidocSignatureSpan">(el)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.len">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>len
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.log">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.mean">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>mean
            <span class="apidocSignatureSpan">(data, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.mergeArray">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>mergeArray
            <span class="apidocSignatureSpan">(traceAttr, cd, cdAttr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.minExtend">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>minExtend
            <span class="apidocSignatureSpan">(obj1, obj2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.mod">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>mod
            <span class="apidocSignatureSpan">(v, d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.ms2DateTime">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>ms2DateTime
            <span class="apidocSignatureSpan">(ms, r, calendar)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.ms2DateTimeLocal">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>ms2DateTimeLocal
            <span class="apidocSignatureSpan">(ms)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.nestedProperty">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>nestedProperty
            <span class="apidocSignatureSpan">(container, propStr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.noneOrAll">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>noneOrAll
            <span class="apidocSignatureSpan">(containerIn, containerOut, attrList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.noop">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>noop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.notifier">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>notifier
            <span class="apidocSignatureSpan">(text, displayLength)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.numSeparate">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>numSeparate
            <span class="apidocSignatureSpan">(value, separators, separatethousands)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.objectFromPath">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>objectFromPath
            <span class="apidocSignatureSpan">(path, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.pauseEvent">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>pauseEvent
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.pushUnique">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>pushUnique
            <span class="apidocSignatureSpan">(array, item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.randstr">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>randstr
            <span class="apidocSignatureSpan">(existing, bits, base)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.relinkPrivateKeys">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>relinkPrivateKeys
            <span class="apidocSignatureSpan">(toContainer, fromContainer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.removeElement">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>removeElement
            <span class="apidocSignatureSpan">(el)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.rotationMatrix">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>rotationMatrix
            <span class="apidocSignatureSpan">(alpha)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.rotationXYMatrix">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>rotationXYMatrix
            <span class="apidocSignatureSpan">(a, x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.roundUp">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>roundUp
            <span class="apidocSignatureSpan">(val, arrayIn, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.simpleMap">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>simpleMap
            <span class="apidocSignatureSpan">(array, func, x1, x2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.smooth">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>smooth
            <span class="apidocSignatureSpan">(arrayIn, FWHM)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.sorterAsc">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>sorterAsc
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.sorterDes">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>sorterDes
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.stdev">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>stdev
            <span class="apidocSignatureSpan">(data, len, mean)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.stripTrailingSlash">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>stripTrailingSlash
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.swapAttrs">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>swapAttrs
            <span class="apidocSignatureSpan">(cont, attrList, part1, part2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.syncOrAsync">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>syncOrAsync
            <span class="apidocSignatureSpan">(sequence, arg, finalStep)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.titleCase">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>titleCase
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.toLogRange">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>toLogRange
            <span class="apidocSignatureSpan">(val, range)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.translationMatrix">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>translationMatrix
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.transposeRagged">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>transposeRagged
            <span class="apidocSignatureSpan">(z)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.validate">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>validate
            <span class="apidocSignatureSpan">(value, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.variance">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>variance
            <span class="apidocSignatureSpan">(data, len, mean)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.index.warn">
            function <span class="apidocSignatureSpan">plotly.js.index.</span>warn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">plotly.js.index.</span>MAX_MS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">plotly.js.index.</span>MIN_MS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.index.</span>valObjects</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.loggers">module plotly.js.loggers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.loggers.error">
            function <span class="apidocSignatureSpan">plotly.js.loggers.</span>error
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.loggers.log">
            function <span class="apidocSignatureSpan">plotly.js.loggers.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.loggers.warn">
            function <span class="apidocSignatureSpan">plotly.js.loggers.</span>warn
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.manage_arrays">module plotly.js.manage_arrays</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.manage_arrays.applyContainerArrayChanges">
            function <span class="apidocSignatureSpan">plotly.js.manage_arrays.</span>applyContainerArrayChanges
            <span class="apidocSignatureSpan">(gd, np, edits, flags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.manage_arrays.containerArrayMatch">
            function <span class="apidocSignatureSpan">plotly.js.manage_arrays.</span>containerArrayMatch
            <span class="apidocSignatureSpan">(astr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.manage_arrays.isAddVal">
            function <span class="apidocSignatureSpan">plotly.js.manage_arrays.</span>isAddVal
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.manage_arrays.isRemoveVal">
            function <span class="apidocSignatureSpan">plotly.js.manage_arrays.</span>isRemoveVal
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.matrix">module plotly.js.matrix</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.matrix.apply2DTransform">
            function <span class="apidocSignatureSpan">plotly.js.matrix.</span>apply2DTransform
            <span class="apidocSignatureSpan">(transform)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.matrix.apply2DTransform2">
            function <span class="apidocSignatureSpan">plotly.js.matrix.</span>apply2DTransform2
            <span class="apidocSignatureSpan">(transform)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.matrix.dot">
            function <span class="apidocSignatureSpan">plotly.js.matrix.</span>dot
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.matrix.init2dArray">
            function <span class="apidocSignatureSpan">plotly.js.matrix.</span>init2dArray
            <span class="apidocSignatureSpan">(rowLength, colLength)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.matrix.rotationMatrix">
            function <span class="apidocSignatureSpan">plotly.js.matrix.</span>rotationMatrix
            <span class="apidocSignatureSpan">(alpha)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.matrix.rotationXYMatrix">
            function <span class="apidocSignatureSpan">plotly.js.matrix.</span>rotationXYMatrix
            <span class="apidocSignatureSpan">(a, x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.matrix.translationMatrix">
            function <span class="apidocSignatureSpan">plotly.js.matrix.</span>translationMatrix
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.matrix.transposeRagged">
            function <span class="apidocSignatureSpan">plotly.js.matrix.</span>transposeRagged
            <span class="apidocSignatureSpan">(z)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.micropolar">module plotly.js.micropolar</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.micropolar.AreaChart">
            function <span class="apidocSignatureSpan">plotly.js.micropolar.</span>AreaChart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.micropolar.Axis">
            function <span class="apidocSignatureSpan">plotly.js.micropolar.</span>Axis
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.micropolar.BarChart">
            function <span class="apidocSignatureSpan">plotly.js.micropolar.</span>BarChart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.micropolar.DotPlot">
            function <span class="apidocSignatureSpan">plotly.js.micropolar.</span>DotPlot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.micropolar.Legend">
            function <span class="apidocSignatureSpan">plotly.js.micropolar.</span>Legend
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.micropolar.LinePlot">
            function <span class="apidocSignatureSpan">plotly.js.micropolar.</span>LinePlot
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.micropolar.PolyChart">
            function <span class="apidocSignatureSpan">plotly.js.micropolar.</span>PolyChart
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.micropolar.tooltipPanel">
            function <span class="apidocSignatureSpan">plotly.js.micropolar.</span>tooltipPanel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.micropolar.</span>adapter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.micropolar.</span>manager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.micropolar.</span>util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.micropolar.</span>AREA</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.micropolar.</span>BAR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.micropolar.</span>DATAEXTENT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.micropolar.</span>DOT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.micropolar.</span>LINE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.micropolar.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.micropolar_manager">module plotly.js.micropolar_manager</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.micropolar_manager.fillLayout">
            function <span class="apidocSignatureSpan">plotly.js.micropolar_manager.</span>fillLayout
            <span class="apidocSignatureSpan">(_gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.micropolar_manager.framework">
            function <span class="apidocSignatureSpan">plotly.js.micropolar_manager.</span>framework
            <span class="apidocSignatureSpan">(_gd)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.norm_functions">module plotly.js.norm_functions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.norm_functions.density">
            function <span class="apidocSignatureSpan">plotly.js.norm_functions.</span>density
            <span class="apidocSignatureSpan">(size, total, inc, yinc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.norm_functions.percent">
            function <span class="apidocSignatureSpan">plotly.js.norm_functions.</span>percent
            <span class="apidocSignatureSpan">(size, total)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.norm_functions.probability">
            function <span class="apidocSignatureSpan">plotly.js.norm_functions.</span>probability
            <span class="apidocSignatureSpan">(size, total)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.pie">module plotly.js.pie</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.pie.calc">
            function <span class="apidocSignatureSpan">plotly.js.pie.</span>calc
            <span class="apidocSignatureSpan">(gd, trace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.pie.plot">
            function <span class="apidocSignatureSpan">plotly.js.pie.</span>plot
            <span class="apidocSignatureSpan">(gd, cdpie)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.pie.style">
            function <span class="apidocSignatureSpan">plotly.js.pie.</span>style
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.pie.styleOne">
            function <span class="apidocSignatureSpan">plotly.js.pie.</span>styleOne
            <span class="apidocSignatureSpan">(s, pt, trace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.pie.supplyDefaults">
            function <span class="apidocSignatureSpan">plotly.js.pie.</span>supplyDefaults
            <span class="apidocSignatureSpan">(traceIn, traceOut, defaultColor, layout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.pie.supplyLayoutDefaults">
            function <span class="apidocSignatureSpan">plotly.js.pie.</span>supplyLayoutDefaults
            <span class="apidocSignatureSpan">(layoutIn, layoutOut)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.pie.</span>attributes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.pie.</span>basePlotModule</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.pie.</span>categories</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.pie.</span>layoutAttributes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.pie.</span>meta</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.pie.</span>moduleType</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.pie.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.plot_config">module plotly.js.plot_config</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">plotly.js.plot_config.</span>autosizable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">plotly.js.plot_config.</span>displaylogo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">plotly.js.plot_config.</span>editable</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">plotly.js.plot_config.</span>fillFrame</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">plotly.js.plot_config.</span>logging</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">plotly.js.plot_config.</span>modeBarButtons</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">plotly.js.plot_config.</span>scrollZoom</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">plotly.js.plot_config.</span>sendData</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">plotly.js.plot_config.</span>showAxisDragHandles</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">plotly.js.plot_config.</span>showAxisRangeEntryBoxes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">plotly.js.plot_config.</span>showLink</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">plotly.js.plot_config.</span>showSources</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">plotly.js.plot_config.</span>showTips</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">plotly.js.plot_config.</span>staticPlot</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plot_config.setBackground">
            function <span class="apidocSignatureSpan">plotly.js.plot_config.</span>setBackground
            <span class="apidocSignatureSpan">(gd, bgColor)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">plotly.js.plot_config.</span>frameMargins</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">plotly.js.plot_config.</span>plotGlPixelRatio</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">plotly.js.plot_config.</span>queueLength</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plot_config.</span>globalTransforms</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plot_config.</span>mapboxAccessToken</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plot_config.</span>modeBarButtonsToAdd</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plot_config.</span>modeBarButtonsToRemove</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.plot_config.</span>displayModeBar</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.plot_config.</span>doubleClick</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.plot_config.</span>linkText</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.plot_config.</span>topojsonURL</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.plotly">module plotly.js.plotly</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plotly.addFrames">
            function <span class="apidocSignatureSpan">plotly.js.plotly.</span>addFrames
            <span class="apidocSignatureSpan">(gd, frameList, indices)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plotly.addTraces">
            function <span class="apidocSignatureSpan">plotly.js.plotly.</span>addTraces
            <span class="apidocSignatureSpan">(gd, traces, newIndices)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plotly.animate">
            function <span class="apidocSignatureSpan">plotly.js.plotly.</span>animate
            <span class="apidocSignatureSpan">(gd, frameOrGroupNameOrFrameList, animationOpts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plotly.deleteFrames">
            function <span class="apidocSignatureSpan">plotly.js.plotly.</span>deleteFrames
            <span class="apidocSignatureSpan">(gd, frameList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plotly.deleteTraces">
            function <span class="apidocSignatureSpan">plotly.js.plotly.</span>deleteTraces
            <span class="apidocSignatureSpan">(gd, indices)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plotly.extendTraces">
            function <span class="apidocSignatureSpan">plotly.js.plotly.</span>extendTraces
            <span class="apidocSignatureSpan">(gd, update, indices, maxPoints)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plotly.moveTraces">
            function <span class="apidocSignatureSpan">plotly.js.plotly.</span>moveTraces
            <span class="apidocSignatureSpan">(gd, currentIndices, newIndices)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plotly.newPlot">
            function <span class="apidocSignatureSpan">plotly.js.plotly.</span>newPlot
            <span class="apidocSignatureSpan">(gd, data, layout, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plotly.plot">
            function <span class="apidocSignatureSpan">plotly.js.plotly.</span>plot
            <span class="apidocSignatureSpan">(gd, data, layout, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plotly.prependTraces">
            function <span class="apidocSignatureSpan">plotly.js.plotly.</span>prependTraces
            <span class="apidocSignatureSpan">(gd, update, indices, maxPoints)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plotly.purge">
            function <span class="apidocSignatureSpan">plotly.js.plotly.</span>purge
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plotly.redraw">
            function <span class="apidocSignatureSpan">plotly.js.plotly.</span>redraw
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plotly.relayout">
            function <span class="apidocSignatureSpan">plotly.js.plotly.</span>relayout
            <span class="apidocSignatureSpan">(gd, astr, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plotly.restyle">
            function <span class="apidocSignatureSpan">plotly.js.plotly.</span>restyle
            <span class="apidocSignatureSpan">(gd, astr, val, traces)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plotly.update">
            function <span class="apidocSignatureSpan">plotly.js.plotly.</span>update
            <span class="apidocSignatureSpan">(gd, traceUpdate, layoutUpdate, traces)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plotly.</span>Axes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plotly.</span>Fx</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plotly.</span>ModeBar</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plotly.</span>Plots</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plotly.</span>defaultConfig</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.plots">module plotly.js.plots</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots._hasPlotType">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>_hasPlotType
            <span class="apidocSignatureSpan">(category)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.addLinks">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>addLinks
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.autoMargin">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>autoMargin
            <span class="apidocSignatureSpan">(gd, id, o)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.cleanPlot">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>cleanPlot
            <span class="apidocSignatureSpan">(newFullData, newFullLayout, oldFullData, oldFullLayout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.computeAPICommandBindings">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>computeAPICommandBindings
            <span class="apidocSignatureSpan">(gd, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.computeFrame">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>computeFrame
            <span class="apidocSignatureSpan">(gd, frameName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.createTransitionData">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>createTransitionData
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.doAutoMargin">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>doAutoMargin
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.doCalcdata">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>doCalcdata
            <span class="apidocSignatureSpan">(gd, traces)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.executeAPICommand">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>executeAPICommand
            <span class="apidocSignatureSpan">(gd, method, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.extendLayout">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>extendLayout
            <span class="apidocSignatureSpan">(destLayout, srcLayout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.extendObjectWithContainers">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>extendObjectWithContainers
            <span class="apidocSignatureSpan">(dest, src, containerPaths)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.extendTrace">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>extendTrace
            <span class="apidocSignatureSpan">(destTrace, srcTrace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.findSubplotIds">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>findSubplotIds
            <span class="apidocSignatureSpan">(data, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.generalUpdatePerTraceModule">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>generalUpdatePerTraceModule
            <span class="apidocSignatureSpan">(subplot, subplotCalcData, subplotLayout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.getComponentMethod">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>getComponentMethod
            <span class="apidocSignatureSpan">(name, method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.getModule">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>getModule
            <span class="apidocSignatureSpan">(trace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.getSubplotCalcData">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>getSubplotCalcData
            <span class="apidocSignatureSpan">(calcData, type, subplotId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.getSubplotData">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>getSubplotData
            <span class="apidocSignatureSpan">(data, type, subplotId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.getSubplotIds">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>getSubplotIds
            <span class="apidocSignatureSpan">(layout, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.graphJson">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>graphJson
            <span class="apidocSignatureSpan">(gd, dataonly, mode, output, useDefaults)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.hasSimpleAPICommandBindings">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>hasSimpleAPICommandBindings
            <span class="apidocSignatureSpan">(gd, commandList, bindingsByValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.linkSubplots">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>linkSubplots
            <span class="apidocSignatureSpan">(newFullData, newFullLayout, oldFullData, oldFullLayout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.manageCommandObserver">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>manageCommandObserver
            <span class="apidocSignatureSpan">(gd, container, commandList, onchange)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.modifyFrames">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>modifyFrames
            <span class="apidocSignatureSpan">(gd, operations)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.plotAutoSize">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>plotAutoSize
            <span class="apidocSignatureSpan">(gd, layout, fullLayout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.previousPromises">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>previousPromises
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.purge">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>purge
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.recomputeFrameHash">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>recomputeFrameHash
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.redrawText">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>redrawText
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.register">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>register
            <span class="apidocSignatureSpan">(_module, thisType, categoriesIn, meta)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.registerComponent">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>registerComponent
            <span class="apidocSignatureSpan">(_module)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.registerSubplot">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>registerSubplot
            <span class="apidocSignatureSpan">(_module)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.rehover">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>rehover
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.resize">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>resize
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.sanitizeMargins">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>sanitizeMargins
            <span class="apidocSignatureSpan">(fullLayout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.sendDataToCloud">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>sendDataToCloud
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.style">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>style
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.supplyAnimationDefaults">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyAnimationDefaults
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.supplyAnimationFrameDefaults">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyAnimationFrameDefaults
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.supplyAnimationTransitionDefaults">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyAnimationTransitionDefaults
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.supplyDataDefaults">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyDataDefaults
            <span class="apidocSignatureSpan">(dataIn, dataOut, layout, fullLayout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.supplyDefaults">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyDefaults
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.supplyFrameDefaults">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyFrameDefaults
            <span class="apidocSignatureSpan">(frameIn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.supplyLayoutGlobalDefaults">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyLayoutGlobalDefaults
            <span class="apidocSignatureSpan">(layoutIn, layoutOut)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.supplyLayoutModuleDefaults">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyLayoutModuleDefaults
            <span class="apidocSignatureSpan">(layoutIn, layoutOut, fullData, transitionData)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.supplyTraceDefaults">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyTraceDefaults
            <span class="apidocSignatureSpan">(traceIn, traceOutIndex, layout, traceInIndex)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.supplyTransformDefaults">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyTransformDefaults
            <span class="apidocSignatureSpan">(traceIn, traceOut, layout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.traceIs">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>traceIs
            <span class="apidocSignatureSpan">(traceType, category)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.plots.transition">
            function <span class="apidocSignatureSpan">plotly.js.plots.</span>transition
            <span class="apidocSignatureSpan">(gd, data, layout, traces, frameOpts, transitionOpts)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plots.</span>allCategories</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plots.</span>allTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plots.</span>attributes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plots.</span>componentsRegistry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plots.</span>dataArrayContainers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plots.</span>fontAttrs</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plots.</span>layoutArrayContainers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plots.</span>layoutArrayRegexes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plots.</span>layoutAttributes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plots.</span>modules</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plots.</span>subplotsRegistry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.plots.</span>transformsRegistry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.plots.</span>fontWeight</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.polygon">module plotly.js.polygon</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.polygon.filter">
            function <span class="apidocSignatureSpan">plotly.js.polygon.</span>filter
            <span class="apidocSignatureSpan">(pts, tolerance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.polygon.isSegmentBent">
            function <span class="apidocSignatureSpan">plotly.js.polygon.</span>isSegmentBent
            <span class="apidocSignatureSpan">(pts, start, end, tolerance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.polygon.tester">
            function <span class="apidocSignatureSpan">plotly.js.polygon.</span>tester
            <span class="apidocSignatureSpan">(ptsIn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.queue">module plotly.js.queue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.queue.add">
            function <span class="apidocSignatureSpan">plotly.js.queue.</span>add
            <span class="apidocSignatureSpan">(gd, undoFunc, undoArgs, redoFunc, redoArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.queue.plotDo">
            function <span class="apidocSignatureSpan">plotly.js.queue.</span>plotDo
            <span class="apidocSignatureSpan">(gd, func, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.queue.redo">
            function <span class="apidocSignatureSpan">plotly.js.queue.</span>redo
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.queue.startSequence">
            function <span class="apidocSignatureSpan">plotly.js.queue.</span>startSequence
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.queue.stopSequence">
            function <span class="apidocSignatureSpan">plotly.js.queue.</span>stopSequence
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.queue.undo">
            function <span class="apidocSignatureSpan">plotly.js.queue.</span>undo
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.registry">module plotly.js.registry</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.registry.getComponentMethod">
            function <span class="apidocSignatureSpan">plotly.js.registry.</span>getComponentMethod
            <span class="apidocSignatureSpan">(name, method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.registry.getModule">
            function <span class="apidocSignatureSpan">plotly.js.registry.</span>getModule
            <span class="apidocSignatureSpan">(trace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.registry.register">
            function <span class="apidocSignatureSpan">plotly.js.registry.</span>register
            <span class="apidocSignatureSpan">(_module, thisType, categoriesIn, meta)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.registry.registerComponent">
            function <span class="apidocSignatureSpan">plotly.js.registry.</span>registerComponent
            <span class="apidocSignatureSpan">(_module)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.registry.registerSubplot">
            function <span class="apidocSignatureSpan">plotly.js.registry.</span>registerSubplot
            <span class="apidocSignatureSpan">(_module)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.registry.traceIs">
            function <span class="apidocSignatureSpan">plotly.js.registry.</span>traceIs
            <span class="apidocSignatureSpan">(traceType, category)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.registry.</span>allCategories</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.registry.</span>allTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.registry.</span>componentsRegistry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.registry.</span>layoutArrayContainers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.registry.</span>layoutArrayRegexes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.registry.</span>modules</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.registry.</span>subplotsRegistry</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.registry.</span>transformsRegistry</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.scrollbox">module plotly.js.scrollbox</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.scrollbox.scrollbox">
            function <span class="apidocSignatureSpan">plotly.js.</span>scrollbox
            <span class="apidocSignatureSpan">(gd, container, id)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">plotly.js.scrollbox.</span>barLength</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">plotly.js.scrollbox.</span>barPad</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">plotly.js.scrollbox.</span>barRadius</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">plotly.js.scrollbox.</span>barWidth</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.scrollbox.</span>barColor</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.scrollbox.prototype">module plotly.js.scrollbox.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.scrollbox.prototype._onBarDrag">
            function <span class="apidocSignatureSpan">plotly.js.scrollbox.prototype.</span>_onBarDrag
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.scrollbox.prototype._onBoxDrag">
            function <span class="apidocSignatureSpan">plotly.js.scrollbox.prototype.</span>_onBoxDrag
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.scrollbox.prototype._onBoxWheel">
            function <span class="apidocSignatureSpan">plotly.js.scrollbox.prototype.</span>_onBoxWheel
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.scrollbox.prototype.disable">
            function <span class="apidocSignatureSpan">plotly.js.scrollbox.prototype.</span>disable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.scrollbox.prototype.enable">
            function <span class="apidocSignatureSpan">plotly.js.scrollbox.prototype.</span>enable
            <span class="apidocSignatureSpan">(position, translateX, translateY)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.scrollbox.prototype.setTranslate">
            function <span class="apidocSignatureSpan">plotly.js.scrollbox.prototype.</span>setTranslate
            <span class="apidocSignatureSpan">(translateX, translateY)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.search">module plotly.js.search</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.search.distinctVals">
            function <span class="apidocSignatureSpan">plotly.js.search.</span>distinctVals
            <span class="apidocSignatureSpan">(valsIn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.search.findBin">
            function <span class="apidocSignatureSpan">plotly.js.search.</span>findBin
            <span class="apidocSignatureSpan">(val, bins, linelow)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.search.roundUp">
            function <span class="apidocSignatureSpan">plotly.js.search.</span>roundUp
            <span class="apidocSignatureSpan">(val, arrayIn, reverse)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.search.sorterAsc">
            function <span class="apidocSignatureSpan">plotly.js.search.</span>sorterAsc
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.search.sorterDes">
            function <span class="apidocSignatureSpan">plotly.js.search.</span>sorterDes
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.sieve">module plotly.js.sieve</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.sieve.sieve">
            function <span class="apidocSignatureSpan">plotly.js.</span>sieve
            <span class="apidocSignatureSpan">(traces, separateNegativeValues, dontMergeOverlappingData)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.sieve.prototype">module plotly.js.sieve.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.sieve.prototype.get">
            function <span class="apidocSignatureSpan">plotly.js.sieve.prototype.</span>get
            <span class="apidocSignatureSpan">(position, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.sieve.prototype.getLabel">
            function <span class="apidocSignatureSpan">plotly.js.sieve.prototype.</span>getLabel
            <span class="apidocSignatureSpan">(position, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.sieve.prototype.put">
            function <span class="apidocSignatureSpan">plotly.js.sieve.prototype.</span>put
            <span class="apidocSignatureSpan">(position, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.stats">module plotly.js.stats</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.stats.aggNums">
            function <span class="apidocSignatureSpan">plotly.js.stats.</span>aggNums
            <span class="apidocSignatureSpan">(f, v, a, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.stats.interp">
            function <span class="apidocSignatureSpan">plotly.js.stats.</span>interp
            <span class="apidocSignatureSpan">(arr, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.stats.len">
            function <span class="apidocSignatureSpan">plotly.js.stats.</span>len
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.stats.mean">
            function <span class="apidocSignatureSpan">plotly.js.stats.</span>mean
            <span class="apidocSignatureSpan">(data, len)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.stats.stdev">
            function <span class="apidocSignatureSpan">plotly.js.stats.</span>stdev
            <span class="apidocSignatureSpan">(data, len, mean)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.stats.variance">
            function <span class="apidocSignatureSpan">plotly.js.stats.</span>variance
            <span class="apidocSignatureSpan">(data, len, mean)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.subroutines">module plotly.js.subroutines</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.subroutines.doCamera">
            function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>doCamera
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.subroutines.doColorBars">
            function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>doColorBars
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.subroutines.doLegend">
            function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>doLegend
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.subroutines.doModeBar">
            function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>doModeBar
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.subroutines.doTicksRelayout">
            function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>doTicksRelayout
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.subroutines.doTraceStyle">
            function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>doTraceStyle
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.subroutines.drawMainTitle">
            function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>drawMainTitle
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.subroutines.layoutReplot">
            function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>layoutReplot
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.subroutines.layoutStyles">
            function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>layoutStyles
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.subroutines.lsInner">
            function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>lsInner
            <span class="apidocSignatureSpan">(gd)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.subtypes">module plotly.js.subtypes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.subtypes.hasLines">
            function <span class="apidocSignatureSpan">plotly.js.subtypes.</span>hasLines
            <span class="apidocSignatureSpan">(trace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.subtypes.hasMarkers">
            function <span class="apidocSignatureSpan">plotly.js.subtypes.</span>hasMarkers
            <span class="apidocSignatureSpan">(trace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.subtypes.hasText">
            function <span class="apidocSignatureSpan">plotly.js.subtypes.</span>hasText
            <span class="apidocSignatureSpan">(trace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.subtypes.isBubble">
            function <span class="apidocSignatureSpan">plotly.js.subtypes.</span>isBubble
            <span class="apidocSignatureSpan">(trace)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.svg_text_utils">module plotly.js.svg_text_utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.svg_text_utils.convertToTspans">
            function <span class="apidocSignatureSpan">plotly.js.svg_text_utils.</span>convertToTspans
            <span class="apidocSignatureSpan">(_context, _callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.svg_text_utils.html_entity_decode">
            function <span class="apidocSignatureSpan">plotly.js.svg_text_utils.</span>html_entity_decode
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.svg_text_utils.makeEditable">
            function <span class="apidocSignatureSpan">plotly.js.svg_text_utils.</span>makeEditable
            <span class="apidocSignatureSpan">(context, _delegate, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.svg_text_utils.plainText">
            function <span class="apidocSignatureSpan">plotly.js.svg_text_utils.</span>plainText
            <span class="apidocSignatureSpan">(_str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.svg_text_utils.xml_entity_encode">
            function <span class="apidocSignatureSpan">plotly.js.svg_text_utils.</span>xml_entity_encode
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.ternary">module plotly.js.ternary</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.ternary.ternary">
            function <span class="apidocSignatureSpan">plotly.js.</span>ternary
            <span class="apidocSignatureSpan">(options, fullLayout)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.ternary.prototype">module plotly.js.ternary.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.ternary.prototype.adjustLayout">
            function <span class="apidocSignatureSpan">plotly.js.ternary.prototype.</span>adjustLayout
            <span class="apidocSignatureSpan">(ternaryLayout, graphSize)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.ternary.prototype.drawAxes">
            function <span class="apidocSignatureSpan">plotly.js.ternary.prototype.</span>drawAxes
            <span class="apidocSignatureSpan">(doTitles)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.ternary.prototype.init">
            function <span class="apidocSignatureSpan">plotly.js.ternary.prototype.</span>init
            <span class="apidocSignatureSpan">(fullLayout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.ternary.prototype.initInteractions">
            function <span class="apidocSignatureSpan">plotly.js.ternary.prototype.</span>initInteractions
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.ternary.prototype.makeFramework">
            function <span class="apidocSignatureSpan">plotly.js.ternary.prototype.</span>makeFramework
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.ternary.prototype.plot">
            function <span class="apidocSignatureSpan">plotly.js.ternary.prototype.</span>plot
            <span class="apidocSignatureSpan">(ternaryCalcData, fullLayout)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.topojson_utils">module plotly.js.topojson_utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.topojson_utils.getTopojsonFeatures">
            function <span class="apidocSignatureSpan">plotly.js.topojson_utils.</span>getTopojsonFeatures
            <span class="apidocSignatureSpan">(trace, topojson)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.topojson_utils.getTopojsonName">
            function <span class="apidocSignatureSpan">plotly.js.topojson_utils.</span>getTopojsonName
            <span class="apidocSignatureSpan">(geoLayout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.topojson_utils.getTopojsonPath">
            function <span class="apidocSignatureSpan">plotly.js.topojson_utils.</span>getTopojsonPath
            <span class="apidocSignatureSpan">(topojsonURL, topojsonName)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.transform">module plotly.js.transform</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.transform.transform">
            function <span class="apidocSignatureSpan">plotly.js.</span>transform
            <span class="apidocSignatureSpan">(dataIn, state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.transform.calcTransform">
            function <span class="apidocSignatureSpan">plotly.js.transform.</span>calcTransform
            <span class="apidocSignatureSpan">(gd, trace, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.transform.supplyDefaults">
            function <span class="apidocSignatureSpan">plotly.js.transform.</span>supplyDefaults
            <span class="apidocSignatureSpan">(transformIn, traceOut, layout, traceIn)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">plotly.js.transform.</span>attributes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.transform.</span>moduleType</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">plotly.js.transform.</span>name</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.plotly.js.unhover">module plotly.js.unhover</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.unhover.raw">
            function <span class="apidocSignatureSpan">plotly.js.unhover.</span>raw
            <span class="apidocSignatureSpan">(gd, evt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.plotly.js.unhover.wrapped">
            function <span class="apidocSignatureSpan">plotly.js.unhover.</span>wrapped
            <span class="apidocSignatureSpan">(gd, evt, subplot)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js" id="apidoc.module.plotly.js">module plotly.js</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.js.geo" id="apidoc.element.plotly.js.js.geo">
        function <span class="apidocSignatureSpan">plotly.js.</span>js.geo
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Geo(options) {
    this.id = options.id;
    this.graphDiv = options.graphDiv;
    this.container = options.container;
    this.topojsonURL = options.topojsonURL;

    this.topojsonName = null;
    this.topojson = null;

    this.projectionType = null;
    this.projection = null;

    this.clipAngle = null;
    this.setScale = null;
    this.path = null;

    this.zoom = null;
    this.zoomReset = null;

    this.makeFramework();

    this.traceHash = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.js.scrollbox" id="apidoc.element.plotly.js.js.scrollbox">
        function <span class="apidocSignatureSpan">plotly.js.</span>js.scrollbox
        <span class="apidocSignatureSpan">(gd, container, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ScrollBox(gd, container, id) {
    this.gd = gd;
    this.container = container;
    this.id = id;

    // See ScrollBox.prototype.enable for further definition
    this.position = null;  // scrollbox position
    this.translateX = null;  // scrollbox horizontal translation
    this.translateY = null;  // scrollbox vertical translation
    this.hbar = null;  // horizontal scrollbar D3 selection
    this.vbar = null;  // vertical scrollbar D3 selection

    // &lt;rect&gt; element to capture pointer events
    this.bg = this.container.selectAll('rect.scrollbox-bg').data([0]);

    this.bg.exit()
        .on('.drag', null)
        .on('wheel', null)
        .remove();

    this.bg.enter().append('rect')
        .classed('scrollbox-bg', true)
        .style('pointer-events', 'all')
        .attr({
            opacity: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0
        });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.js.sieve" id="apidoc.element.plotly.js.js.sieve">
        function <span class="apidocSignatureSpan">plotly.js.</span>js.sieve
        <span class="apidocSignatureSpan">(traces, separateNegativeValues, dontMergeOverlappingData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Sieve(traces, separateNegativeValues, dontMergeOverlappingData) {
    this.traces = traces;
    this.separateNegativeValues = separateNegativeValues;
    this.dontMergeOverlappingData = dontMergeOverlappingData;

    var positions = [];
    for(var i = 0; i &lt; traces.length; i++) {
        var trace = traces[i];
        for(var j = 0; j &lt; trace.length; j++) {
            var bar = trace[j];
            if(bar.p !== BADNUM) positions.push(bar.p);
        }
    }
    this.positions = positions;

    var dv = Lib.distinctVals(this.positions);
    this.distinctPositions = dv.vals;
    this.minDiff = dv.minDiff;

    this.binWidth = this.minDiff;

    this.bins = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.js.ternary" id="apidoc.element.plotly.js.js.ternary">
        function <span class="apidocSignatureSpan">plotly.js.</span>js.ternary
        <span class="apidocSignatureSpan">(options, fullLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Ternary(options, fullLayout) {
    this.id = options.id;
    this.graphDiv = options.graphDiv;
    this.init(fullLayout);
    this.makeFramework();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
































































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.anchor_utils" id="apidoc.module.plotly.js.anchor_utils">module plotly.js.anchor_utils</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.anchor_utils.isBottomAnchor" id="apidoc.element.plotly.js.anchor_utils.isBottomAnchor">
        function <span class="apidocSignatureSpan">plotly.js.anchor_utils.</span>isBottomAnchor
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBottomAnchor(opts) {
    return (
        opts.yanchor === 'bottom' ||
        (opts.yanchor === 'auto' &amp;&amp; opts.y &lt;= 1 / 3)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.anchor_utils.isCenterAnchor" id="apidoc.element.plotly.js.anchor_utils.isCenterAnchor">
        function <span class="apidocSignatureSpan">plotly.js.anchor_utils.</span>isCenterAnchor
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isCenterAnchor(opts) {
    return (
        opts.xanchor === 'center' ||
        (opts.xanchor === 'auto' &amp;&amp; opts.x &gt; 1 / 3 &amp;&amp; opts.x &lt; 2 / 3)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.anchor_utils.isMiddleAnchor" id="apidoc.element.plotly.js.anchor_utils.isMiddleAnchor">
        function <span class="apidocSignatureSpan">plotly.js.anchor_utils.</span>isMiddleAnchor
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isMiddleAnchor(opts) {
    return (
        opts.yanchor === 'middle' ||
        (opts.yanchor === 'auto' &amp;&amp; opts.y &gt; 1 / 3 &amp;&amp; opts.y &lt; 2 / 3)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.anchor_utils.isRightAnchor" id="apidoc.element.plotly.js.anchor_utils.isRightAnchor">
        function <span class="apidocSignatureSpan">plotly.js.anchor_utils.</span>isRightAnchor
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isRightAnchor(opts) {
    return (
        opts.xanchor === 'right' ||
        (opts.xanchor === 'auto' &amp;&amp; opts.x &gt;= 2 / 3)
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.axes" id="apidoc.module.plotly.js.axes">module plotly.js.axes</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.axes.autoBin" id="apidoc.element.plotly.js.axes.autoBin">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>autoBin
        <span class="apidocSignatureSpan">(data, ax, nbins, is2d, calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoBin = function (data, ax, nbins, is2d, calendar) {
    var dataMin = Lib.aggNums(Math.min, null, data),
        dataMax = Lib.aggNums(Math.max, null, data);

    if(!calendar) calendar = ax.calendar;

    if(ax.type === 'category') {
        return {
            start: dataMin - 0.5,
            end: dataMax + 0.5,
            size: 1
        };
    }

    var size0;
    if(nbins) size0 = ((dataMax - dataMin) / nbins);
    else {
        // totally auto: scale off std deviation so the highest bin is
        // somewhat taller than the total number of bins, but don't let
        // the size get smaller than the 'nice' rounded down minimum
        // difference between values
        var distinctData = Lib.distinctVals(data),
            msexp = Math.pow(10, Math.floor(
                Math.log(distinctData.minDiff) / Math.LN10)),
            minSize = msexp * Lib.roundUp(
                distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);
        size0 = Math.max(minSize, 2 * Lib.stdev(data) /
            Math.pow(data.length, is2d ? 0.25 : 0.4));

        // fallback if ax.d2c output BADNUMs
        // e.g. when user try to plot categorical bins
        // on a layout.xaxis.type: 'linear'
        if(!isNumeric(size0)) size0 = 1;
    }

    // piggyback off autotick code to make "nice" bin sizes
    var dummyAx;
    if(ax.type === 'log') {
        dummyAx = {
            type: 'linear',
            range: [dataMin, dataMax]
        };
    }
    else {
        dummyAx = {
            type: ax.type,
            range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),
            calendar: calendar
        };
    }
    axes.setConvert(dummyAx);

    axes.autoTicks(dummyAx, size0);
    var binStart = axes.tickIncrement(
            axes.tickFirst(dummyAx), dummyAx.dtick, 'reverse', calendar),
        binEnd;

    // check for too many data points right at the edges of bins
    // (&gt;50% within 1% of bin edges) or all data points integral
    // and offset the bins accordingly
    if(typeof dummyAx.dtick === 'number') {
        binStart = autoShiftNumericBins(binStart, data, dummyAx, dataMin, dataMax);

        var bincount = 1 + Math.floor((dataMax - binStart) / dummyAx.dtick);
        binEnd = binStart + bincount * dummyAx.dtick;
    }
    else {
        // month ticks - should be the only nonlinear kind we have at this point.
        // dtick (as supplied by axes.autoTick) only has nonlinear values on
        // date and log axes, but even if you display a histogram on a log axis
        // we bin it on a linear axis (which one could argue against, but that's
        // a separate issue)
        if(dummyAx.dtick.charAt(0) === 'M') {
            binStart = autoShiftMonthBins(binStart, data, dummyAx.dtick, dataMin, calendar);
        }

        // calculate the endpoint for nonlinear ticks - you have to
        // just increment until you're done
        binEnd = binStart;
        while(binEnd &lt;= dataMax) {
            binEnd = axes.tickIncrement(binEnd, dummyAx.dtick, false, calendar);
        }
    }

    return {
        start: ax.c2r(binStart, 0, calendar),
        end: ax.c2r(binEnd, 0, calendar),
        size: dummyAx.dtick
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.autoTicks" id="apidoc.element.plotly.js.axes.autoTicks">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>autoTicks
        <span class="apidocSignatureSpan">(ax, roughDTick)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoTicks = function (ax, roughDTick) {
    var base;

    if(ax.type === 'date') {
        ax.tick0 = Lib.dateTick0(ax.calendar);
        // the criteria below are all based on the rough spacing we calculate
        // being &gt; half of the final unit - so precalculate twice the rough val
        var roughX2 = 2 * roughDTick;

        if(roughX2 &gt; ONEAVGYEAR) {
            roughDTick /= ONEAVGYEAR;
            base = Math.pow(10, Math.floor(Math.log(roughDTick) / Math.LN10));
            ax.dtick = 'M' + (12 * roundDTick(roughDTick, base, roundBase10));
        }
        else if(roughX2 &gt; ONEAVGMONTH) {
            roughDTick /= ONEAVGMONTH;
            ax.dtick = 'M' + roundDTick(roughDTick, 1, roundBase24);
        }
        else if(roughX2 &gt; ONEDAY) {
            ax.dtick = roundDTick(roughDTick, ONEDAY, roundDays);
            // get week ticks on sunday
            // this will also move the base tick off 2000-01-01 if dtick is
            // 2 or 3 days... but that's a weird enough case that we'll ignore it.
            ax.tick0 = Lib.dateTick0(ax.calendar, true);
        }
        else if(roughX2 &gt; ONEHOUR) {
            ax.dtick = roundDTick(roughDTick, ONEHOUR, roundBase24);
        }
        else if(roughX2 &gt; ONEMIN) {
            ax.dtick = roundDTick(roughDTick, ONEMIN, roundBase60);
        }
        else if(roughX2 &gt; ONESEC) {
            ax.dtick = roundDTick(roughDTick, ONESEC, roundBase60);
        }
        else {
            // milliseconds
            base = Math.pow(10, Math.floor(Math.log(roughDTick) / Math.LN10));
            ax.dtick = roundDTick(roughDTick, base, roundBase10);
        }
    }
    else if(ax.type === 'log') {
        ax.tick0 = 0;
        var rng = Lib.simpleMap(ax.range, ax.r2l);

        if(roughDTick &gt; 0.7) {
            // only show powers of 10
            ax.dtick = Math.ceil(roughDTick);
        }
        else if(Math.abs(rng[1] - rng[0]) &lt; 1) {
            // span is less than one power of 10
            var nt = 1.5 * Math.abs((rng[1] - rng[0]) / roughDTick);

            // ticks on a linear scale, labeled fully
            roughDTick = Math.abs(Math.pow(10, rng[1]) -
                Math.pow(10, rng[0])) / nt;
            base = Math.pow(10, Math.floor(Math.log(roughDTick) / Math.LN10));
            ax.dtick = 'L' + roundDTick(roughDTick, base, roundBase10);
        }
        else {
            // include intermediates between powers of 10,
            // labeled with small digits
            // ax.dtick = "D2" (show 2 and 5) or "D1" (show all digits)
            ax.dtick = (roughDTick &gt; 0.3) ? 'D2' : 'D1';
        }
    }
    else if(ax.type === 'category') {
        ax.tick0 = 0;
        ax.dtick = Math.ceil(Math.max(roughDTick, 1));
    }
    else {
        // auto ticks always start at 0
        ax.tick0 = 0;
        base = Math.pow(10, Math.floor(Math.log(roughDTick) / Math.LN10));
        ax.dtick = roundDTick(roughDTick, base, roundBase10);
    }

    // prevent infinite loops
    if(ax.dtick === 0) ax.dtick = 1;

    // TODO: this is from log axis histograms with autorange off
    if(!isNumeric(ax.dtick) &amp;&amp; typeof ax.dtick !== 'string') {
        var olddtick = ax.dtick;
        ax.dtick = 1;
        throw 'ax.dtick error: ' + String(olddtick);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        type: ax.type,
        range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),
        calendar: calendar
    };
}
axes.setConvert(dummyAx);

axes.<span class="apidocCodeKeywordSpan">autoTicks</span>(dummyAx, size0);
var binStart = axes.tickIncrement(
        axes.tickFirst(dummyAx), dummyAx.dtick, 'reverse', calendar),
    binEnd;

// check for too many data points right at the edges of bins
// (&gt;50% within 1% of bin edges) or all data points integral
// and offset the bins accordingly
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.calcTicks" id="apidoc.element.plotly.js.axes.calcTicks">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>calcTicks
        <span class="apidocSignatureSpan">(ax)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function calcTicks(ax) {
    var rng = Lib.simpleMap(ax.range, ax.r2l);

    // calculate max number of (auto) ticks to display based on plot size
    if(ax.tickmode === 'auto' || !ax.dtick) {
        var nt = ax.nticks,
            minPx;
        if(!nt) {
            if(ax.type === 'category') {
                minPx = ax.tickfont ? (ax.tickfont.size || 12) * 1.2 : 15;
                nt = ax._length / minPx;
            }
            else {
                minPx = ax._id.charAt(0) === 'y' ? 40 : 80;
                nt = Lib.constrain(ax._length / minPx, 4, 9) + 1;
            }
        }

        // add a couple of extra digits for filling in ticks when we
        // have explicit tickvals without tick text
        if(ax.tickmode === 'array') nt *= 100;

        axes.autoTicks(ax, Math.abs(rng[1] - rng[0]) / nt);
        // check for a forced minimum dtick
        if(ax._minDtick &gt; 0 &amp;&amp; ax.dtick &lt; ax._minDtick * 2) {
            ax.dtick = ax._minDtick;
            ax.tick0 = ax.l2r(ax._forceTick0);
        }
    }

    // check for missing tick0
    if(!ax.tick0) {
        ax.tick0 = (ax.type === 'date') ? '2000-01-01' : 0;
    }

    // now figure out rounding of tick values
    autoTickRound(ax);

    // now that we've figured out the auto values for formatting
    // in case we're missing some ticktext, we can break out for array ticks
    if(ax.tickmode === 'array') return arrayTicks(ax);

    // find the first tick
    ax._tmin = axes.tickFirst(ax);

    // check for reversed axis
    var axrev = (rng[1] &lt; rng[0]);

    // return the full set of tick vals
    var vals = [],
        // add a tiny bit so we get ticks which may have rounded out
        endtick = rng[1] * 1.0001 - rng[0] * 0.0001;
    if(ax.type === 'category') {
        endtick = (axrev) ? Math.max(-0.5, endtick) :
            Math.min(ax._categories.length - 0.5, endtick);
    }
    for(var x = ax._tmin;
            (axrev) ? (x &gt;= endtick) : (x &lt;= endtick);
            x = axes.tickIncrement(x, ax.dtick, axrev, ax.calendar)) {
        vals.push(x);

        // prevent infinite loops
        if(vals.length &gt; 1000) break;
    }

    // save the last tick as well as first, so we can
    // show the exponent only on the last one
    ax._tmax = vals[vals.length - 1];

    // for showing the rest of a date when the main tick label is only the
    // latter part: ax._prevDateHead holds what we showed most recently.
    // Start with it cleared and mark that we're in calcTicks (ie calculating a
    // whole string of these so we should care what the previous date head was!)
    ax._prevDateHead = '';
    ax._inCalcTicks = true;

    var ticksOut = new Array(vals.length);
    for(var i = 0; i &lt; vals.length; i++) ticksOut[i] = axes.tickText(ax, vals[i]);

    ax._inCalcTicks = false;

    return ticksOut;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// set scaling to pixels
ax.setScale();

var axLetter = axid.charAt(0),
    counterLetter = axes.counterLetter(axid),
    vals = axes.<span class="apidocCodeKeywordSpan">calcTicks</span>(ax),
    datafn = function(d) { return [d.text, d.x, ax.mirror].join('_'); },
    tcls = axid + 'tick',
    gcls = axid + 'grid',
    zcls = axid + 'zl',
    pad = (ax.linewidth || 1) / 2,
    labelStandoff =
        (ax.ticks === 'outside' ? ax.ticklen : 1) + (ax.linewidth || 0),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.cleanId" id="apidoc.element.plotly.js.axes.cleanId">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>cleanId
        <span class="apidocSignatureSpan">(id, axLetter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cleanId(id, axLetter) {
    if(!id.match(constants.AX_ID_PATTERN)) return;
    if(axLetter &amp;&amp; id.charAt(0) !== axLetter) return;

    var axNum = id.substr(1).replace(/^0+/, '');
    if(axNum === '1') axNum = '';
    return id.charAt(0) + axNum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
delete layout.yaxis1;
    }

    var axList = Axes.list({_fullLayout: layout});
    for(i = 0; i &lt; axList.length; i++) {
var ax = axList[i];
if(ax.anchor &amp;&amp; ax.anchor !== 'free') {
    ax.anchor = Axes.<span class="apidocCodeKeywordSpan">cleanId</span>(ax.anchor);
}
if(ax.overlaying) ax.overlaying = Axes.cleanId(ax.overlaying);

// old method of axis type - isdate and islog (before category existed)
if(!ax.type) {
    if(ax.isdate) ax.type = 'date';
    else if(ax.islog) ax.type = 'log';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.clearTypes" id="apidoc.element.plotly.js.axes.clearTypes">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>clearTypes
        <span class="apidocSignatureSpan">(gd, traces)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearTypes = function (gd, traces) {
    if(!Array.isArray(traces) || !traces.length) {
        traces = (gd._fullData).map(function(d, i) { return i; });
    }
    traces.forEach(function(tracenum) {
        var trace = gd.data[tracenum];
        delete (axes.getFromId(gd, trace.xaxis) || {}).type;
        delete (axes.getFromId(gd, trace.yaxis) || {}).type;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else if(hovermode.get() === 'y') {
        hovermode.set('x');
    }
}

// check if we need to call axis type
if((traces.indexOf(0) !== -1) &amp;&amp; (axtypeAttrs.indexOf(ai) !== -1)) {
    Plotly.Axes.<span class="apidocCodeKeywordSpan">clearTypes</span>(gd, traces);
    flags.docalc = true;
}

// switching from auto to manual binning or z scaling doesn't
// actually do anything but change what you see in the styling
// box. everything else at least needs to apply styles
if((['autobinx', 'autobiny', 'zauto'].indexOf(ai) === -1) ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.coercePosition" id="apidoc.element.plotly.js.axes.coercePosition">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>coercePosition
        <span class="apidocSignatureSpan">(containerOut, gd, coerce, axRef, attr, dflt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coercePosition = function (containerOut, gd, coerce, axRef, attr, dflt) {
    var pos,
        newPos;

    if(axRef === 'paper' || axRef === 'pixel') {
        pos = coerce(attr, dflt);
    }
    else {
        var ax = axes.getFromId(gd, axRef);

        dflt = ax.fraction2r(dflt);
        pos = coerce(attr, dflt);

        if(ax.type === 'category') {
            // if position is given as a category name, convert it to a number
            if(typeof pos === 'string' &amp;&amp; (ax._categories || []).length) {
                newPos = ax._categories.indexOf(pos);
                containerOut[attr] = (newPos === -1) ? dflt : newPos;
                return;
            }
        }
        else if(ax.type === 'date') {
            containerOut[attr] = Lib.cleanDate(pos, BADNUM, ax.calendar);
            return;
        }
    }
    // finally make sure we have a number (unless date type already returned a string)
    containerOut[attr] = isNumeric(pos) ? Number(pos) : dflt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for(var i = 0; i &lt; 2; i++) {
        var axLetter = axLetters[i];

        // xref, yref
        var axRef = Axes.coerceRef(annIn, annOut, gdMock, axLetter, '', 'paper');

        // x, y
        Axes.<span class="apidocCodeKeywordSpan">coercePosition</span>(annOut, gdMock, coerce, axRef, axLetter, 0.5);

        if(showArrow) {
var arrowPosAttr = 'a' + axLetter,
    // axref, ayref
    aaxRef = Axes.coerceRef(annIn, annOut, gdMock, arrowPosAttr, 'pixel');

// for now the arrow can only be on the same axis or specified as pixels
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.coerceRef" id="apidoc.element.plotly.js.axes.coerceRef">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>coerceRef
        <span class="apidocSignatureSpan">(containerIn, containerOut, gd, attr, dflt, extraOption)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coerceRef = function (containerIn, containerOut, gd, attr, dflt, extraOption) {
    var axLetter = attr.charAt(attr.length - 1),
        axlist = axes.listIds(gd, axLetter),
        refAttr = attr + 'ref',
        attrDef = {};

    if(!dflt) dflt = axlist[0] || extraOption;
    if(!extraOption) extraOption = dflt;

    // data-ref annotations are not supported in gl2d yet

    attrDef[refAttr] = {
        valType: 'enumerated',
        values: axlist.concat(extraOption ? [extraOption] : []),
        dflt: dflt
    };

    // xref, yref
    return Lib.coerce(containerIn, containerOut, attrDef, refAttr);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var axLetters = ['x', 'y'],
arrowPosDflt = [-10, -30],
gdMock = {_fullLayout: fullLayout};
    for(var i = 0; i &lt; 2; i++) {
var axLetter = axLetters[i];

// xref, yref
var axRef = Axes.<span class="apidocCodeKeywordSpan">coerceRef</span>(annIn, annOut, gdMock, axLetter, '', 'paper
');

// x, y
Axes.coercePosition(annOut, gdMock, coerce, axRef, axLetter, 0.5);

if(showArrow) {
    var arrowPosAttr = 'a' + axLetter,
        // axref, ayref
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.counterLetter" id="apidoc.element.plotly.js.axes.counterLetter">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>counterLetter
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">counterLetter = function (id) {
    var axLetter = id.charAt(0);
    if(axLetter === 'x') return 'y';
    if(axLetter === 'y') return 'x';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
}

// set scaling to pixels
ax.setScale();

var axLetter = axid.charAt(0),
    counterLetter = axes.<span class="apidocCodeKeywordSpan">counterLetter</span>(axid),
    vals = axes.calcTicks(ax),
    datafn = function(d) { return [d.text, d.x, ax.mirror].join('_'); },
    tcls = axid + 'tick',
    gcls = axid + 'grid',
    zcls = axid + 'zl',
    pad = (ax.linewidth || 1) / 2,
    labelStandoff =
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.doAutoRange" id="apidoc.element.plotly.js.axes.doAutoRange">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>doAutoRange
        <span class="apidocSignatureSpan">(ax)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doAutoRange = function (ax) {
    if(!ax._length) ax.setScale();

    // TODO do we really need this?
    var hasDeps = (ax._min &amp;&amp; ax._max &amp;&amp; ax._min.length &amp;&amp; ax._max.length);

    if(ax.autorange &amp;&amp; hasDeps) {
        ax.range = axes.getAutoRange(ax);

        // doAutoRange will get called on fullLayout,
        // but we want to report its results back to layout

        var axIn = ax._input;
        axIn.range = ax.range.slice();
        axIn.autorange = ax.autorange;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    function doAutoRangeAndConstraints() {
if(gd._transitioning) return;

var axList = Plotly.Axes.list(gd, '', true);
for(var i = 0; i &lt; axList.length; i++) {
    Plotly.Axes.<span class="apidocCodeKeywordSpan">doAutoRange</span>(axList[i]);
}

enforceAxisConstraints(gd);

// store initial ranges *after* enforcing constraints, otherwise
// we will never look like we're at the initial ranges
if(graphWasEmpty) Plotly.Axes.saveRangeInitial(gd);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.doTicks" id="apidoc.element.plotly.js.axes.doTicks">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>doTicks
        <span class="apidocSignatureSpan">(gd, axid, skipTitle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doTicks = function (gd, axid, skipTitle) {
    var fullLayout = gd._fullLayout,
        ax,
        independent = false;

    // allow passing an independent axis object instead of id
    if(typeof axid === 'object') {
        ax = axid;
        axid = ax._id;
        independent = true;
    }
    else {
        ax = axes.getFromId(gd, axid);

        if(axid === 'redraw') {
            fullLayout._paper.selectAll('g.subplot').each(function(subplot) {
                var plotinfo = fullLayout._plots[subplot],
                    xa = plotinfo.xaxis,
                    ya = plotinfo.yaxis;

                plotinfo.xaxislayer
                    .selectAll('.' + xa._id + 'tick').remove();
                plotinfo.yaxislayer
                    .selectAll('.' + ya._id + 'tick').remove();
                plotinfo.gridlayer
                    .selectAll('path').remove();
                plotinfo.zerolinelayer
                    .selectAll('path').remove();
            });
        }

        if(!axid || axid === 'redraw') {
            return Lib.syncOrAsync(axes.list(gd, '', true).map(function(ax) {
                return function() {
                    if(!ax._id) return;
                    var axDone = axes.doTicks(gd, ax._id);
                    if(axid === 'redraw') {
                        ax._r = ax.range.slice();
                        ax._rl = Lib.simpleMap(ax._r, ax.r2l);
                    }
                    return axDone;
                };
            }));
        }
    }

    // make sure we only have allowed options for exponents
    // (others can make confusing errors)
    if(!ax.tickformat) {
        if(['none', 'e', 'E', 'power', 'SI', 'B'].indexOf(ax.exponentformat) === -1) {
            ax.exponentformat = 'e';
        }
        if(['all', 'first', 'last', 'none'].indexOf(ax.showexponent) === -1) {
            ax.showexponent = 'all';
        }
    }

    // set scaling to pixels
    ax.setScale();

    var axLetter = axid.charAt(0),
        counterLetter = axes.counterLetter(axid),
        vals = axes.calcTicks(ax),
        datafn = function(d) { return [d.text, d.x, ax.mirror].join('_'); },
        tcls = axid + 'tick',
        gcls = axid + 'grid',
        zcls = axid + 'zl',
        pad = (ax.linewidth || 1) / 2,
        labelStandoff =
            (ax.ticks === 'outside' ? ax.ticklen : 1) + (ax.linewidth || 0),
        labelShift = 0,
        gridWidth = Drawing.crispRound(gd, ax.gridwidth, 1),
        zeroLineWidth = Drawing.crispRound(gd, ax.zerolinewidth, gridWidth),
        tickWidth = Drawing.crispRound(gd, ax.tickwidth, 1),
        sides, transfn, tickpathfn, subplots,
        i;

    if(ax._counterangle &amp;&amp; ax.ticks === 'outside') {
        var caRad = ax._counterangle * Math.PI / 180;
        labelStandoff = ax.ticklen * Math.cos(caRad) + (ax.linewidth || 0);
        labelShift = ax.ticklen * Math.sin(caRad);
    }

    // positioning arguments for x vs y axes
    if(axLetter === 'x') {
        sides = ['bottom', 'top'];
        transfn = function(d) {
            return 'translate(' + ax.l2p(d.x) + ',0)';
        };
        tickpathfn = function(shift, len) {
            if(ax._counterangle) {
                var caRad = ax._counterangle * Math.PI / 180;
                return 'M0,' + shift + 'l' + (Math.sin(caRad) * len) + ',' + (Math.cos(caRad) * len);
            }
            else return 'M0,' + shift + 'v' + len;
        };
    }
    else if(axLetter === 'y') {
        sides = ['left', 'right'];
        transfn = function(d) {
            return 'translate(0,' + ax.l2p(d.x) + ')';
        };
        tickpathfn = function(shift, len) {
            if(ax._counterangle) {
                var caRad = ax._counterangle * Math.PI / 180;
                return 'M' + shift + ',0l' + (Math.cos(caRad) * len) + ',' + (-Math.sin(caRad) * len);
            }
            else return 'M' + shift + ',0h' + len;
        };
    }
    else {
        Lib.warn('Unrecognized doTicks axis:', axid);
        return;
    }
    var axside = ax.side || sides[0],
    // which direction do the side[0], side[1], and ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // store initial ranges *after* enforcing constraints, otherwise
    // we will never look like we're at the initial ranges
    if(graphWasEmpty) Plotly.Axes.saveRangeInitial(gd);
}

// draw ticks, titles, and calculate axis scaling (._b, ._m)
function drawAxes() {
    return Plotly.Axes.<span class="apidocCodeKeywordSpan">doTicks</span>(gd, 'redraw');
}

// Now plot the data
function drawData() {
    var calcdata = gd.calcdata,
        i;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.expand" id="apidoc.element.plotly.js.axes.expand">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>expand
        <span class="apidocSignatureSpan">(ax, data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expand = function (ax, data, options) {
    var needsAutorange = (
        ax.autorange ||
        !!Lib.nestedProperty(ax, 'rangeslider.autorange').get()
    );

    if(!needsAutorange || !data) return;

    if(!ax._min) ax._min = [];
    if(!ax._max) ax._max = [];
    if(!options) options = {};
    if(!ax._m) ax.setScale();

    var len = data.length,
        extrappad = options.padded ? ax._length * 0.05 : 0,
        tozero = options.tozero &amp;&amp; (ax.type === 'linear' || ax.type === '-'),
        i, j, v, di, dmin, dmax,
        ppadiplus, ppadiminus, includeThis, vmin, vmax;

    function getPad(item) {
        if(Array.isArray(item)) {
            return function(i) { return Math.max(Number(item[i]||0), 0); };
        }
        else {
            var v = Math.max(Number(item||0), 0);
            return function() { return v; };
        }
    }
    var ppadplus = getPad((ax._m &gt; 0 ?
            options.ppadplus : options.ppadminus) || options.ppad || 0),
        ppadminus = getPad((ax._m &gt; 0 ?
            options.ppadminus : options.ppadplus) || options.ppad || 0),
        vpadplus = getPad(options.vpadplus || options.vpad),
        vpadminus = getPad(options.vpadminus || options.vpad);

    function addItem(i) {
        di = data[i];
        if(!isNumeric(di)) return;
        ppadiplus = ppadplus(i) + extrappad;
        ppadiminus = ppadminus(i) + extrappad;
        vmin = di - vpadminus(i);
        vmax = di + vpadplus(i);
        // special case for log axes: if vpad makes this object span
        // more than an order of mag, clip it to one order. This is so
        // we don't have non-positive errors or absurdly large lower
        // range due to rounding errors
        if(ax.type === 'log' &amp;&amp; vmin &lt; vmax / 10) { vmin = vmax / 10; }

        dmin = ax.c2l(vmin);
        dmax = ax.c2l(vmax);

        if(tozero) {
            dmin = Math.min(0, dmin);
            dmax = Math.max(0, dmax);
        }

        // In order to stop overflow errors, don't consider points
        // too close to the limits of js floating point
        function goodNumber(v) {
            return isNumeric(v) &amp;&amp; Math.abs(v) &lt; FP_SAFE;
        }

        if(goodNumber(dmin)) {
            includeThis = true;
            // take items v from ax._min and compare them to the
            // presently active point:
            // - if the item supercedes the new point, set includethis false
            // - if the new pt supercedes the item, delete it from ax._min
            for(j = 0; j &lt; ax._min.length &amp;&amp; includeThis; j++) {
                v = ax._min[j];
                if(v.val &lt;= dmin &amp;&amp; v.pad &gt;= ppadiminus) {
                    includeThis = false;
                }
                else if(v.val &gt;= dmin &amp;&amp; v.pad &lt;= ppadiminus) {
                    ax._min.splice(j, 1);
                    j--;
                }
            }
            if(includeThis) {
                ax._min.push({
                    val: dmin,
                    pad: (tozero &amp;&amp; dmin === 0) ? 0 : ppadiminus
                });
            }
        }

        if(goodNumber(dmax)) {
            includeThis = true;
            for(j = 0; j &lt; ax._max.length &amp;&amp; includeThis; j++) {
                v = ax._max[j];
                if(v.val &gt;= dmax &amp;&amp; v.pad &gt;= ppadiplus) {
                    includeThis = false;
                }
                else if(v.val &lt;= dmax &amp;&amp; v.pad &lt;= ppadiplus) {
                    ax._max.splice(j, 1);
                    j--;
                }
            }
            if(includeThis) {
                ax._max.push({
                    val: dmax,
                    pad: (tozero &amp;&amp; dmax === 0) ? 0 : ppadiplus
                });
            }
        }
    }

    // For efficiency covering monotonic or near-monotonic data,
    // check a few points at both ends first and then sweep
    // through the middle
    for(i = 0; i &lt; 6; i++) addItem(i);
    for(i = len - 1; i &gt; 5; i--) addItem(i);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        if(xa &amp;&amp; xa.autorange) {
headPlus = headSize + ann.xshift;
headMinus = headSize - ann.xshift;

if(ann.axref === ann.xref) {
    // expand for the arrowhead (padded by arrowhead)
    Axes.<span class="apidocCodeKeywordSpan">expand</span>(xa, [xa.r2c(ann.x)], {
        ppadplus: headPlus,
        ppadminus: headMinus
    });
    // again for the textbox (padded by textbox)
    Axes.expand(xa, [xa.r2c(ann.ax)], {
        ppadplus: ann._xpadplus,
        ppadminus: ann._xpadminus
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.findSubplotsWithAxis" id="apidoc.element.plotly.js.axes.findSubplotsWithAxis">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>findSubplotsWithAxis
        <span class="apidocSignatureSpan">(subplots, ax)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findSubplotsWithAxis = function (subplots, ax) {
    var axMatch = new RegExp(
        (ax._id.charAt(0) === 'x') ? ('^' + ax._id + 'y') : (ax._id + '$')
    );
    var subplotsWithAxis = [];

    for(var i = 0; i &lt; subplots.length; i++) {
        var sp = subplots[i];
        if(axMatch.test(sp)) subplotsWithAxis.push(sp);
    }

    return subplotsWithAxis;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if(aMatch[1] === bMatch[1]) {
        return +(aMatch[2] || 1) - (bMatch[2] || 1);
    }

    return +(aMatch[1]||0) - (bMatch[1]||0);
});

if(ax) return axes.<span class="apidocCodeKeywordSpan">findSubplotsWithAxis</span>(allSubplots, ax);
return allSubplots;
};

// find all subplots with axis 'ax'
axes.findSubplotsWithAxis = function(subplots, ax) {
var axMatch = new RegExp(
    (ax._id.charAt(0) === 'x') ? ('^' + ax._id + 'y') : (ax._id + '$')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.getAutoRange" id="apidoc.element.plotly.js.axes.getAutoRange">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>getAutoRange
        <span class="apidocSignatureSpan">(ax)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAutoRange = function (ax) {
    var newRange = [];

    var minmin = ax._min[0].val,
        maxmax = ax._max[0].val,
        i;

    for(i = 1; i &lt; ax._min.length; i++) {
        if(minmin !== maxmax) break;
        minmin = Math.min(minmin, ax._min[i].val);
    }
    for(i = 1; i &lt; ax._max.length; i++) {
        if(minmin !== maxmax) break;
        maxmax = Math.max(maxmax, ax._max[i].val);
    }

    var j, minpt, maxpt, minbest, maxbest, dp, dv,
        mbest = 0,
        axReverse = false;

    if(ax.range) {
        var rng = Lib.simpleMap(ax.range, ax.r2l);
        axReverse = rng[1] &lt; rng[0];
    }

    // one-time setting to easily reverse the axis
    // when plotting from code
    if(ax.autorange === 'reversed') {
        axReverse = true;
        ax.autorange = true;
    }

    for(i = 0; i &lt; ax._min.length; i++) {
        minpt = ax._min[i];
        for(j = 0; j &lt; ax._max.length; j++) {
            maxpt = ax._max[j];
            dv = maxpt.val - minpt.val;
            dp = ax._length - minpt.pad - maxpt.pad;
            if(dv &gt; 0 &amp;&amp; dp &gt; 0 &amp;&amp; dv / dp &gt; mbest) {
                minbest = minpt;
                maxbest = maxpt;
                mbest = dv / dp;
            }
        }
    }

    if(minmin === maxmax) {
        var lower = minmin - 1;
        var upper = minmin + 1;
        if(ax.rangemode === 'tozero') {
            newRange = minmin &lt; 0 ? [lower, 0] : [0, upper];
        }
        else if(ax.rangemode === 'nonnegative') {
            newRange = [Math.max(0, lower), Math.max(0, upper)];
        }
        else {
            newRange = [lower, upper];
        }
    }
    else if(mbest) {
        if(ax.type === 'linear' || ax.type === '-') {
            if(ax.rangemode === 'tozero') {
                if(minbest.val &gt;= 0) {
                    minbest = {val: 0, pad: 0};
                }
                if(maxbest.val &lt;= 0) {
                    maxbest = {val: 0, pad: 0};
                }
            }
            else if(ax.rangemode === 'nonnegative') {
                if(minbest.val - mbest * minbest.pad &lt; 0) {
                    minbest = {val: 0, pad: 0};
                }
                if(maxbest.val &lt; 0) {
                    maxbest = {val: 1, pad: 0};
                }
            }

            // in case it changed again...
            mbest = (maxbest.val - minbest.val) /
                (ax._length - minbest.pad - maxbest.pad);

        }

        newRange = [
            minbest.val - mbest * minbest.pad,
            maxbest.val + mbest * maxbest.pad
        ];
    }

    // don't let axis have zero size, while still respecting tozero and nonnegative
    if(newRange[0] === newRange[1]) {
        if(ax.rangemode === 'tozero') {
            if(newRange[0] &lt; 0) {
                newRange = [newRange[0], 0];
            }
            else if(newRange[0] &gt; 0) {
                newRange = [0, newRange[0]];
            }
            else {
                newRange = [0, 1];
            }
        }
        else {
            newRange = [newRange[0] - 1, newRange[0] + 1];
            if(ax.rangemode === 'nonnegative') {
                newRange[0] = Math.max(0, newRange[0]);
            }
        }
    }

    // maintain reversal
    if(axReverse) newRange.reverse();

    return Lib.simpleMap(newRange, ax.l2r || Number);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
axes.doAutoRange = function(ax) {
    if(!ax._length) ax.setScale();

    // TODO do we really need this?
    var hasDeps = (ax._min &amp;&amp; ax._max &amp;&amp; ax._min.length &amp;&amp; ax._max.length);

    if(ax.autorange &amp;&amp; hasDeps) {
ax.range = axes.<span class="apidocCodeKeywordSpan">getAutoRange</span>(ax);

// doAutoRange will get called on fullLayout,
// but we want to report its results back to layout

var axIn = ax._input;
axIn.range = ax.range.slice();
axIn.autorange = ax.autorange;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.getFromId" id="apidoc.element.plotly.js.axes.getFromId">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>getFromId
        <span class="apidocSignatureSpan">(gd, id, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFromId = function (gd, id, type) {
    var fullLayout = gd._fullLayout;

    if(type === 'x') id = id.replace(/y[0-9]*/, '');
    else if(type === 'y') id = id.replace(/x[0-9]*/, '');

    return fullLayout[exports.id2name(id)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(val !== undefined) p.set(val);
    }

    // for editing annotations or shapes - is it on autoscaled axes?
    function refAutorange(obj, axLetter) {
if(!Lib.isPlainObject(obj)) return false;
var axRef = obj[axLetter + 'ref'] || axLetter,
    ax = Plotly.Axes.<span class="apidocCodeKeywordSpan">getFromId</span>(gd, axRef);

if(!ax &amp;&amp; axRef.charAt(0) === axLetter) {
    // fall back on the primary axis in case we've referenced a
    // nonexistent axis (as we do above if axRef is missing).
    // This assumes the object defaults to data referenced, which
    // is the case for shapes and annotations but not for images.
    // The only thing this is used for is to determine whether to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.getFromTrace" id="apidoc.element.plotly.js.axes.getFromTrace">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>getFromTrace
        <span class="apidocSignatureSpan">(gd, fullTrace, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFromTrace = function (gd, fullTrace, type) {
    var fullLayout = gd._fullLayout;
    var ax = null;

    if(Registry.traceIs(fullTrace, 'gl3d')) {
        var scene = fullTrace.scene;
        if(scene.substr(0, 5) === 'scene') {
            ax = fullLayout[scene][type + 'axis'];
        }
    }
    else {
        ax = exports.getFromId(gd, fullTrace[type + 'axis'] || type);
    }

    return ax;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.getSubplots" id="apidoc.element.plotly.js.axes.getSubplots">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>getSubplots
        <span class="apidocSignatureSpan">(gd, ax)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSubplots = function (gd, ax) {
    var subplots = [];
    var i, j, sp;

    // look for subplots in the data
    var data = gd._fullData || gd.data || [];

    for(i = 0; i &lt; data.length; i++) {
        var trace = data[i];

        if(trace.visible === false || trace.visible === 'legendonly' ||
            !(Registry.traceIs(trace, 'cartesian') || Registry.traceIs(trace, 'gl2d'))
        ) continue;

        var xId = trace.xaxis || 'x',
            yId = trace.yaxis || 'y';
        sp = xId + yId;

        if(subplots.indexOf(sp) === -1) subplots.push(sp);
    }

    // look for subplots in the axes/anchors, so that we at least draw all axes
    var axesList = axes.list(gd, '', true);

    function hasAx2(sp, ax2) {
        return sp.indexOf(ax2._id) !== -1;
    }

    for(i = 0; i &lt; axesList.length; i++) {
        var ax2 = axesList[i],
            ax2Letter = ax2._id.charAt(0),
            ax3Id = (ax2.anchor === 'free') ?
                ((ax2Letter === 'x') ? 'y' : 'x') :
                ax2.anchor,
            ax3 = axes.getFromId(gd, ax3Id);

        // look if ax2 is already represented in the data
        var foundAx2 = false;
        for(j = 0; j &lt; subplots.length; j++) {
            if(hasAx2(subplots[j], ax2)) {
                foundAx2 = true;
                break;
            }
        }

        // ignore free axes that already represented in the data
        if(ax2.anchor === 'free' &amp;&amp; foundAx2) continue;

        // ignore anchor-less axes
        if(!ax3) continue;

        sp = (ax2Letter === 'x') ?
            ax2._id + ax3._id :
            ax3._id + ax2._id;

        if(subplots.indexOf(sp) === -1) subplots.push(sp);
    }

    // filter invalid subplots
    var spMatch = axes.subplotMatch,
        allSubplots = [];

    for(i = 0; i &lt; subplots.length; i++) {
        sp = subplots[i];
        if(spMatch.test(sp)) allSubplots.push(sp);
    }

    // sort the subplot ids
    allSubplots.sort(function(a, b) {
        var aMatch = a.match(spMatch),
            bMatch = b.match(spMatch);

        if(aMatch[1] === bMatch[1]) {
            return +(aMatch[2] || 1) - (bMatch[2] || 1);
        }

        return +(aMatch[1]||0) - (bMatch[1]||0);
    });

    if(ax) return axes.findSubplotsWithAxis(allSubplots, ax);
    return allSubplots;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
newSubplots = newFullLayout._plots = {};

    var mockGd = {
_fullData: newFullData,
_fullLayout: newFullLayout
    };

    var ids = Plotly.Axes.<span class="apidocCodeKeywordSpan">getSubplots</span>(mockGd);

    for(var i = 0; i &lt; ids.length; i++) {
var id = ids[i],
    oldSubplot = oldSubplots[id],
    plotinfo;

if(oldSubplot) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.id2name" id="apidoc.element.plotly.js.axes.id2name">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>id2name
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function id2name(id) {
    if(typeof id !== 'string' || !id.match(constants.AX_ID_PATTERN)) return;
    var axNum = id.substr(1);
    if(axNum === '1') axNum = '';
    return id.charAt(0) + 'axis' + axNum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

// make a new empty vals array for undoit
function a0() { return traces.map(function() { return undefined; }); }

// for autoranging multiple axes
function addToAxlist(axid) {
    var axName = Plotly.Axes.<span class="apidocCodeKeywordSpan">id2name</span>(axid);
    if(axlist.indexOf(axName) === -1) axlist.push(axName);
}

function autorangeAttr(axName) { return 'LAYOUT' + axName + '.autorange'; }

function rangeAttr(axName) { return 'LAYOUT' + axName + '.range'; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.list" id="apidoc.element.plotly.js.axes.list">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>list
        <span class="apidocSignatureSpan">(gd, axletter, only2d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">list = function (gd, axletter, only2d) {
    return listNames(gd, axletter, only2d)
        .map(function(axName) {
            return Lib.nestedProperty(gd._fullLayout, axName).get();
        });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    delete layout.xaxis1;
}
if(layout.yaxis1) {
    if(!layout.yaxis) layout.yaxis = layout.yaxis1;
    delete layout.yaxis1;
}

var axList = Axes.<span class="apidocCodeKeywordSpan">list</span>({_fullLayout: layout});
for(i = 0; i &lt; axList.length; i++) {
    var ax = axList[i];
    if(ax.anchor &amp;&amp; ax.anchor !== 'free') {
        ax.anchor = Axes.cleanId(ax.anchor);
    }
    if(ax.overlaying) ax.overlaying = Axes.cleanId(ax.overlaying);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.listIds" id="apidoc.element.plotly.js.axes.listIds">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>listIds
        <span class="apidocSignatureSpan">(gd, axletter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listIds = function (gd, axletter) {
    return listNames(gd, axletter, true).map(exports.name2id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * dflt: the default to coerce to, or blank to use the first axis (falling back on
 *     extraOption if there is no axis)
 * extraOption: aside from existing axes with this letter, what non-axis value is allowed?
 *     Only required if it's different from `dflt`
 */
axes.coerceRef = function(containerIn, containerOut, gd, attr, dflt, extraOption) {
var axLetter = attr.charAt(attr.length - 1),
    axlist = axes.<span class="apidocCodeKeywordSpan">listIds</span>(gd, axLetter),
    refAttr = attr + 'ref',
    attrDef = {};

if(!dflt) dflt = axlist[0] || extraOption;
if(!extraOption) extraOption = dflt;

// data-ref annotations are not supported in gl2d yet
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.makeClipPaths" id="apidoc.element.plotly.js.axes.makeClipPaths">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>makeClipPaths
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeClipPaths = function (gd) {
    var fullLayout = gd._fullLayout,
        defs = fullLayout._defs,
        fullWidth = {_offset: 0, _length: fullLayout.width, _id: ''},
        fullHeight = {_offset: 0, _length: fullLayout.height, _id: ''},
        xaList = axes.list(gd, 'x', true),
        yaList = axes.list(gd, 'y', true),
        clipList = [],
        i,
        j;

    for(i = 0; i &lt; xaList.length; i++) {
        clipList.push({x: xaList[i], y: fullHeight});
        for(j = 0; j &lt; yaList.length; j++) {
            if(i === 0) clipList.push({x: fullWidth, y: yaList[j]});
            clipList.push({x: xaList[i], y: yaList[j]});
        }
    }

    var defGroup = defs.selectAll('g.clips')
        .data([0]);

    defGroup.enter().append('g')
        .classed('clips', true);

    // selectors don't work right with camelCase tags,
    // have to use class instead
    // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I
    var axClips = defGroup.selectAll('.axesclip')
        .data(clipList, function(d) { return d.x._id + d.y._id; });

    axClips.enter().append('clipPath')
        .classed('axesclip', true)
        .attr('id', function(d) { return 'clip' + fullLayout._uid + d.x._id + d.y._id; })
      .append('rect');

    axClips.exit().remove();

    axClips.each(function(d) {
        d3.select(this).select('rect').attr({
            x: d.x._offset || 0,
            y: d.y._offset || 0,
            width: d.x._length || 1,
            height: d.y._length || 1
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        plotinfo.draglayer.attr('transform', origin);

        // mark free axes as displayed, so we don't draw them again
        if(showfreex) { freefinished.push(xa._id); }
        if(showfreey) { freefinished.push(ya._id); }
    });

    Plotly.Axes.<span class="apidocCodeKeywordSpan">makeClipPaths</span>(gd);
    exports.drawMainTitle(gd);
    ModeBar.manage(gd);

    return gd._promises.length &amp;&amp; Promise.all(gd._promises);
};

exports.drawMainTitle = function(gd) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.minDtick" id="apidoc.element.plotly.js.axes.minDtick">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>minDtick
        <span class="apidocSignatureSpan">(ax, newDiff, newFirst, allow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minDtick = function (ax, newDiff, newFirst, allow) {
    // doesn't make sense to do forced min dTick on log or category axes,
    // and the plot itself may decide to cancel (ie non-grouped bars)
    if(['log', 'category'].indexOf(ax.type) !== -1 || !allow) {
        ax._minDtick = 0;
    }
    // undefined means there's nothing there yet
    else if(ax._minDtick === undefined) {
        ax._minDtick = newDiff;
        ax._forceTick0 = newFirst;
    }
    else if(ax._minDtick) {
        // existing minDtick is an integer multiple of newDiff
        // (within rounding err)
        // and forceTick0 can be shifted to newFirst
        if((ax._minDtick / newDiff + 1e-6) % 1 &lt; 2e-6 &amp;&amp;
                (((newFirst - ax._forceTick0) / newDiff % 1) +
                    1.000001) % 1 &lt; 2e-6) {
            ax._minDtick = newDiff;
            ax._forceTick0 = newFirst;
        }
        // if the converse is true (newDiff is a multiple of minDtick and
        // newFirst can be shifted to forceTick0) then do nothing - same
        // forcing stands. Otherwise, cancel forced minimum
        else if((newDiff / ax._minDtick + 1e-6) % 1 &gt; 2e-6 ||
                (((newFirst - ax._forceTick0) / ax._minDtick % 1) +
                    1.000001) % 1 &gt; 2e-6) {
            ax._minDtick = 0;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
function updatePositionAxis(gd, pa, sieve, allowMinDtick) {
var calcTraces = sieve.traces,
    distinctPositions = sieve.distinctPositions,
    distinctPositions0 = distinctPositions[0],
    minDiff = sieve.minDiff,
    vpad = minDiff / 2;

Axes.<span class="apidocCodeKeywordSpan">minDtick</span>(pa, minDiff, distinctPositions0, allowMinDtick);

// If the user set the bar width or the offset,
// then bars can be shifted away from their positions
// and widths can be larger than minDiff.
//
// Here, we compute pMin and pMax to expand the position axis,
// so that all bars are fully within the axis range.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.saveRangeInitial" id="apidoc.element.plotly.js.axes.saveRangeInitial">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>saveRangeInitial
        <span class="apidocSignatureSpan">(gd, overwrite)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">saveRangeInitial = function (gd, overwrite) {
    var axList = axes.list(gd, '', true),
        hasOneAxisChanged = false;

    for(var i = 0; i &lt; axList.length; i++) {
        var ax = axList[i];

        var isNew = (ax._rangeInitial === undefined);
        var hasChanged = (
            isNew || !(
                ax.range[0] === ax._rangeInitial[0] &amp;&amp;
                ax.range[1] === ax._rangeInitial[1]
            )
        );

        if((isNew &amp;&amp; ax.autorange === false) || (overwrite &amp;&amp; hasChanged)) {
            ax._rangeInitial = ax.range.slice();
            hasOneAxisChanged = true;
        }
    }

    return hasOneAxisChanged;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        Plotly.Axes.doAutoRange(axList[i]);
    }

    enforceAxisConstraints(gd);

    // store initial ranges *after* enforcing constraints, otherwise
    // we will never look like we're at the initial ranges
    if(graphWasEmpty) Plotly.Axes.<span class="apidocCodeKeywordSpan">saveRangeInitial</span>(gd);
}

// draw ticks, titles, and calculate axis scaling (._b, ._m)
function drawAxes() {
    return Plotly.Axes.doTicks(gd, 'redraw');
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.saveShowSpikeInitial" id="apidoc.element.plotly.js.axes.saveShowSpikeInitial">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>saveShowSpikeInitial
        <span class="apidocSignatureSpan">(gd, overwrite)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">saveShowSpikeInitial = function (gd, overwrite) {
    var axList = axes.list(gd, '', true),
        hasOneAxisChanged = false,
        allEnabled = 'on';

    for(var i = 0; i &lt; axList.length; i++) {
        var ax = axList[i];

        var isNew = (ax._showSpikeInitial === undefined);
        var hasChanged = (
            isNew || !(
                ax.showspikes === ax._showspikes
            )
        );

        if((isNew) || (overwrite &amp;&amp; hasChanged)) {
            ax._showSpikeInitial = ax.showspikes;
            hasOneAxisChanged = true;
        }

        if(allEnabled === 'on' &amp;&amp; !ax.showspikes) {
            allEnabled = 'off';
        }
    }
    gd._fullLayout._cartesianSpikesEnabled = allEnabled;
    return hasOneAxisChanged;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// polar need a different framework
if(gd.framework !== makePlotFramework) {
    gd.framework = makePlotFramework;
    makePlotFramework(gd);
}

// save initial show spikes once per graph
if(graphWasEmpty) Plotly.Axes.<span class="apidocCodeKeywordSpan">saveShowSpikeInitial</span>(gd);

// prepare the data and find the autorange

// generate calcdata, if we need to
// to force redoing calcdata, just delete it before calling Plotly.plot
var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;
if(recalc) Plots.doCalcdata(gd);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.setConvert" id="apidoc.element.plotly.js.axes.setConvert">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>setConvert
        <span class="apidocSignatureSpan">(ax, fullLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setConvert(ax, fullLayout) {
    fullLayout = fullLayout || {};

    // clipMult: how many axis lengths past the edge do we render?
    // for panning, 1-2 would suffice, but for zooming more is nice.
    // also, clipping can affect the direction of lines off the edge...
    var clipMult = 10;

    function toLog(v, clip) {
        if(v &gt; 0) return Math.log(v) / Math.LN10;

        else if(v &lt;= 0 &amp;&amp; clip &amp;&amp; ax.range &amp;&amp; ax.range.length === 2) {
            // clip NaN (ie past negative infinity) to clipMult axis
            // length past the negative edge
            var r0 = ax.range[0],
                r1 = ax.range[1];
            return 0.5 * (r0 + r1 - 3 * clipMult * Math.abs(r0 - r1));
        }

        else return BADNUM;
    }

<span class="apidocCodeCommentSpan">    /*
     * wrapped dateTime2ms that:
     * - accepts ms numbers for backward compatibility
     * - inserts a dummy arg so calendar is the 3rd arg (see notes below).
     * - defaults to ax.calendar
     */
</span>    function dt2ms(v, _, calendar) {
        // NOTE: Changed this behavior: previously we took any numeric value
        // to be a ms, even if it was a string that could be a bare year.
        // Now we convert it as a date if at all possible, and only try
        // as (local) ms if that fails.
        var ms = dateTime2ms(v, calendar || ax.calendar);
        if(ms === BADNUM) {
            if(isNumeric(v)) ms = dateTime2ms(new Date(+v));
            else return BADNUM;
        }
        return ms;
    }

    // wrapped ms2DateTime to insert default ax.calendar
    function ms2dt(v, r, calendar) {
        return ms2DateTime(v, r, calendar || ax.calendar);
    }

    function getCategoryName(v) {
        return ax._categories[Math.round(v)];
    }

    /*
     * setCategoryIndex: return the index of category v,
     * inserting it in the list if it's not already there
     *
     * this will enter the categories in the order it
     * encounters them, ie all the categories from the
     * first data set, then all the ones from the second
     * that aren't in the first etc.
     *
     * it is assumed that this function is being invoked in the
     * already sorted category order; otherwise there would be
     * a disconnect between the array and the index returned
     */
    function setCategoryIndex(v) {
        if(v !== null &amp;&amp; v !== undefined) {
            if(ax._categoriesMap === undefined) {
                ax._categoriesMap = {};
            }

            if(ax._categoriesMap[v] !== undefined) {
                return ax._categoriesMap[v];
            } else {
                ax._categories.push(v);

                var curLength = ax._categories.length - 1;
                ax._categoriesMap[v] = curLength;

                return curLength;
            }
        }
        return BADNUM;
    }

    function getCategoryIndex(v) {
        // d2l/d2c variant that that won't add categories but will also
        // allow numbers to be mapped to the linearized axis positions
        if(ax._categoriesMap) {
            var index = ax._categoriesMap[v];
            if(index !== undefined) return index;
        }

        if(typeof v === 'number') { return v; }
    }

    function l2p(v) {
        if(!isNumeric(v)) return BADNUM;

        // include 2 fractional digits on pixel, for PDF zooming etc
        return d3.round(ax._b + ax._m * v, 2);
    }

    function p2l(px) { return (px - ax._b) / ax._m; }

    // conversions among c/l/p are fairly simple - do them together for all axis types
    ax.c2l = (ax.type === 'log') ? toLog : num;
    ax.l2c = (ax.type === 'log') ? fromLog : num;

    ax.l2p = l2p;
    ax.p2l = p2l;

    ax.c2p = (ax.type === 'log') ? function(v, clip) { return l2p(toLog(v, clip)); } : l2p;
    ax.p2c = (ax.type === 'log') ? function(px) { return fromLog(p2l(px)); } : p2l;

    /*
     * now type-specific conversions for **ALL** other combinations
     * they're all written out, instead of being combinations of each other, for
     * both clarity and speed.
     */
    if(['linear', '-'].indexOf(ax.type) !== -1) {
        // all are data vals, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
else {
    dummyAx = {
        type: ax.type,
        range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),
        calendar: calendar
    };
}
axes.<span class="apidocCodeKeywordSpan">setConvert</span>(dummyAx);

axes.autoTicks(dummyAx, size0);
var binStart = axes.tickIncrement(
        axes.tickFirst(dummyAx), dummyAx.dtick, 'reverse', calendar),
    binEnd;

// check for too many data points right at the edges of bins
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.supplyLayoutDefaults" id="apidoc.element.plotly.js.axes.supplyLayoutDefaults">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>supplyLayoutDefaults
        <span class="apidocSignatureSpan">(layoutIn, layoutOut, fullData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function supplyLayoutDefaults(layoutIn, layoutOut, fullData) {
    var layoutKeys = Object.keys(layoutIn),
        xaListCartesian = [],
        yaListCartesian = [],
        xaListGl2d = [],
        yaListGl2d = [],
        xaListCheater = [],
        xaListNonCheater = [],
        outerTicks = {},
        noGrids = {},
        i;

    // look for axes in the data
    for(i = 0; i &lt; fullData.length; i++) {
        var trace = fullData[i];
        var listX, listY;

        if(Registry.traceIs(trace, 'cartesian')) {
            listX = xaListCartesian;
            listY = yaListCartesian;
        }
        else if(Registry.traceIs(trace, 'gl2d')) {
            listX = xaListGl2d;
            listY = yaListGl2d;
        }
        else continue;

        var xaName = axisIds.id2name(trace.xaxis),
            yaName = axisIds.id2name(trace.yaxis);

        // Two things trigger axis visibility:
        // 1. is not carpet
        // 2. carpet that's not cheater
        if(!Registry.traceIs(trace, 'carpet') || (trace.type === 'carpet' &amp;&amp; !trace._cheater)) {
            if(xaName) Lib.pushUnique(xaListNonCheater, xaName);
        }

        // The above check for definitely-not-cheater is not adequate. This
        // second list tracks which axes *could* be a cheater so that the
        // full condition triggering hiding is:
        //   *could* be a cheater and *is not definitely visible*
        if(trace.type === 'carpet' &amp;&amp; trace._cheater) {
            if(xaName) Lib.pushUnique(xaListCheater, xaName);
        }

        // add axes implied by traces
        if(xaName &amp;&amp; listX.indexOf(xaName) === -1) listX.push(xaName);
        if(yaName &amp;&amp; listY.indexOf(yaName) === -1) listY.push(yaName);

        // check for default formatting tweaks
        if(Registry.traceIs(trace, '2dMap')) {
            outerTicks[xaName] = true;
            outerTicks[yaName] = true;
        }

        if(Registry.traceIs(trace, 'oriented')) {
            var positionAxis = trace.orientation === 'h' ? yaName : xaName;
            noGrids[positionAxis] = true;
        }
    }

    // N.B. Ignore orphan axes (i.e. axes that have no data attached to them)
    // if gl3d or geo is present on graph. This is retain backward compatible.
    //
    // TODO drop this in version 2.0
    var ignoreOrphan = (layoutOut._has('gl3d') || layoutOut._has('geo'));

    if(!ignoreOrphan) {
        for(i = 0; i &lt; layoutKeys.length; i++) {
            var key = layoutKeys[i];

            // orphan layout axes are considered cartesian subplots

            if(xaListGl2d.indexOf(key) === -1 &amp;&amp;
                xaListCartesian.indexOf(key) === -1 &amp;&amp;
                    constants.xAxisMatch.test(key)) {
                xaListCartesian.push(key);
            }
            else if(yaListGl2d.indexOf(key) === -1 &amp;&amp;
                yaListCartesian.indexOf(key) === -1 &amp;&amp;
                    constants.yAxisMatch.test(key)) {
                yaListCartesian.push(key);
            }
        }
    }

    // make sure that plots with orphan cartesian axes
    // are considered 'cartesian'
    if(xaListCartesian.length &amp;&amp; yaListCartesian.length) {
        Lib.pushUnique(layoutOut._basePlotModules, Registry.subplotsRegistry.cartesian);
    }

    function axSort(a, b) {
        var aNum = Number(a.substr(5) || 1),
            bNum = Number(b.substr(5) || 1);
        return aNum - bNum;
    }

    var xaList = xaListCartesian.concat(xaListGl2d).sort(axSort),
        yaList = yaListCartesian.concat(yaListGl2d).sort(axSort),
        axesList = xaList.concat(yaList);

    // plot_bgcolor only makes sense if there's a (2D) plot!
    // TODO: bgcolor for each subplot, to inherit from the main one
    var plot_bgcolor = Color.background;
    if(xaList.length &amp;&amp; yaList.length) {
        plot_bgcolor = Lib.coerce(layoutIn, layoutOut, basePlotLayoutAttributes, 'plot_bgcolor');
    }

    var bgColor = Color.combine(plot_bgcolor, layoutOut.paper_bgcolor);

    var axName, axLetter, axLayoutIn, axLayoutOut;

    function coerce(attr, dflt) {
        return Lib.coerce(axLayoutIn, axLayoutOut, la ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

plots.supplyLayoutModuleDefaults = function(layoutIn, layoutOut, fullData, transitionData) {
    var i, _module;

    // can't be be part of basePlotModules loop
    // in order to handle the orphan axes case
    Plotly.Axes.<span class="apidocCodeKeywordSpan">supplyLayoutDefaults</span>(layoutIn, layoutOut, fullData);

    // base plot module layout defaults
    var basePlotModules = layoutOut._basePlotModules;
    for(i = 0; i &lt; basePlotModules.length; i++) {
_module = basePlotModules[i];

// done above already
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.swap" id="apidoc.element.plotly.js.axes.swap">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>swap
        <span class="apidocSignatureSpan">(gd, traces)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">swap = function (gd, traces) {
    var axGroups = makeAxisGroups(gd, traces);

    for(var i = 0; i &lt; axGroups.length; i++) {
        swapAxisGroup(gd, axGroups[i].x, axGroups[i].y);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        // all the other ones, just modify that one attribute
        param.set(newVal);
    }
}

// swap the data attributes of the relevant x and y axes?
if(['swapxyaxes', 'orientationaxes'].indexOf(ai) !== -1) {
    Plotly.Axes.<span class="apidocCodeKeywordSpan">swap</span>(gd, traces);
}

// swap hovermode if set to "compare x/y data"
if(ai === 'orientationaxes') {
    var hovermode = Lib.nestedProperty(gd.layout, 'hovermode');
    if(hovermode.get() === 'x') {
        hovermode.set('y');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.tickFirst" id="apidoc.element.plotly.js.axes.tickFirst">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>tickFirst
        <span class="apidocSignatureSpan">(ax)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tickFirst = function (ax) {
    var r2l = ax.r2l || Number,
        rng = Lib.simpleMap(ax.range, r2l),
        axrev = rng[1] &lt; rng[0],
        sRound = axrev ? Math.floor : Math.ceil,
        // add a tiny extra bit to make sure we get ticks
        // that may have been rounded out
        r0 = rng[0] * 1.0001 - rng[1] * 0.0001,
        dtick = ax.dtick,
        tick0 = r2l(ax.tick0);

    if(isNumeric(dtick)) {
        var tmin = sRound((r0 - tick0) / dtick) * dtick + tick0;

        // make sure no ticks outside the category list
        if(ax.type === 'category') {
            tmin = Lib.constrain(tmin, 0, ax._categories.length - 1);
        }
        return tmin;
    }

    var tType = dtick.charAt(0),
        dtNum = Number(dtick.substr(1));

    // Dates: months (or years)
    if(tType === 'M') {
        var cnt = 0,
            t0 = tick0,
            t1,
            mult,
            newDTick;

        // This algorithm should work for *any* nonlinear (but close to linear!)
        // tick spacing. Limit to 10 iterations, for gregorian months it's normally &lt;=3.
        while(cnt &lt; 10) {
            t1 = axes.tickIncrement(t0, dtick, axrev, ax.calendar);
            if((t1 - r0) * (t0 - r0) &lt;= 0) {
                // t1 and t0 are on opposite sides of r0! we've succeeded!
                if(axrev) return Math.min(t0, t1);
                return Math.max(t0, t1);
            }
            mult = (r0 - ((t0 + t1) / 2)) / (t1 - t0);
            newDTick = tType + ((Math.abs(Math.round(mult)) || 1) * dtNum);
            t0 = axes.tickIncrement(t0, newDTick, mult &lt; 0 ? !axrev : axrev, ax.calendar);
            cnt++;
        }
        Lib.error('tickFirst did not converge', ax);
        return t0;
    }

    // Log scales: Linear, Digits
    else if(tType === 'L') {
        return Math.log(sRound(
            (Math.pow(10, r0) - tick0) / dtNum) * dtNum + tick0) / Math.LN10;
    }
    else if(tType === 'D') {
        var tickset = (dtick === 'D2') ? roundLog2 : roundLog1,
            frac = Lib.roundUp(Lib.mod(r0, 1), tickset, axrev);

        return Math.floor(r0) +
            Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;
    }
    else throw 'unrecognized dtick ' + String(dtick);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        calendar: calendar
    };
}
axes.setConvert(dummyAx);

axes.autoTicks(dummyAx, size0);
var binStart = axes.tickIncrement(
        axes.<span class="apidocCodeKeywordSpan">tickFirst</span>(dummyAx), dummyAx.dtick, 'reverse', calendar),
    binEnd;

// check for too many data points right at the edges of bins
// (&gt;50% within 1% of bin edges) or all data points integral
// and offset the bins accordingly
if(typeof dummyAx.dtick === 'number') {
    binStart = autoShiftNumericBins(binStart, data, dummyAx, dataMin, dataMax);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.tickIncrement" id="apidoc.element.plotly.js.axes.tickIncrement">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>tickIncrement
        <span class="apidocSignatureSpan">(x, dtick, axrev, calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tickIncrement = function (x, dtick, axrev, calendar) {
    var axSign = axrev ? -1 : 1;

    // includes linear, all dates smaller than month, and pure 10^n in log
    if(isNumeric(dtick)) return x + axSign * dtick;

    // everything else is a string, one character plus a number
    var tType = dtick.charAt(0),
        dtSigned = axSign * Number(dtick.substr(1));

    // Dates: months (or years - see Lib.incrementMonth)
    if(tType === 'M') return Lib.incrementMonth(x, dtSigned, calendar);

    // Log scales: Linear, Digits
    else if(tType === 'L') return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10;

    // log10 of 2,5,10, or all digits (logs just have to be
    // close enough to round)
    else if(tType === 'D') {
        var tickset = (dtick === 'D2') ? roundLog2 : roundLog1,
            x2 = x + axSign * 0.01,
            frac = Lib.roundUp(Lib.mod(x2, 1), tickset, axrev);

        return Math.floor(x2) +
            Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;
    }
    else throw 'unrecognized dtick ' + String(dtick);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),
        calendar: calendar
    };
}
axes.setConvert(dummyAx);

axes.autoTicks(dummyAx, size0);
var binStart = axes.<span class="apidocCodeKeywordSpan">tickIncrement</span>(
        axes.tickFirst(dummyAx), dummyAx.dtick, 'reverse', calendar),
    binEnd;

// check for too many data points right at the edges of bins
// (&gt;50% within 1% of bin edges) or all data points integral
// and offset the bins accordingly
if(typeof dummyAx.dtick === 'number') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axes.tickText" id="apidoc.element.plotly.js.axes.tickText">
        function <span class="apidocSignatureSpan">plotly.js.axes.</span>tickText
        <span class="apidocSignatureSpan">(ax, x, hover)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tickText = function (ax, x, hover) {
    var out = tickTextObj(ax, x),
        hideexp,
        arrayMode = ax.tickmode === 'array',
        extraPrecision = hover || arrayMode,
        i,
        tickVal2l = ax.type === 'category' ? ax.d2l_noadd : ax.d2l;

    if(arrayMode &amp;&amp; Array.isArray(ax.ticktext)) {
        var rng = Lib.simpleMap(ax.range, ax.r2l),
            minDiff = Math.abs(rng[1] - rng[0]) / 10000;
        for(i = 0; i &lt; ax.ticktext.length; i++) {
            if(Math.abs(x - tickVal2l(ax.tickvals[i])) &lt; minDiff) break;
        }
        if(i &lt; ax.ticktext.length) {
            out.text = String(ax.ticktext[i]);
            return out;
        }
    }

    function isHidden(showAttr) {
        var first_or_last;

        if(showAttr === undefined) return true;
        if(hover) return showAttr === 'none';

        first_or_last = {
            first: ax._tmin,
            last: ax._tmax
        }[showAttr];

        return showAttr !== 'all' &amp;&amp; x !== first_or_last;
    }

    hideexp = ax.exponentformat !== 'none' &amp;&amp; isHidden(ax.showexponent) ? 'hide' : '';

    if(ax.type === 'date') formatDate(ax, out, hover, extraPrecision);
    else if(ax.type === 'log') formatLog(ax, out, hover, extraPrecision, hideexp);
    else if(ax.type === 'category') formatCategory(ax, out);
    else formatLinear(ax, out, hover, extraPrecision, hideexp);

    // add prefix and suffix
    if(ax.tickprefix &amp;&amp; !isHidden(ax.showtickprefix)) out.text = ax.tickprefix + out.text;
    if(ax.ticksuffix &amp;&amp; !isHidden(ax.showticksuffix)) out.text += ax.ticksuffix;

    return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // latter part: ax._prevDateHead holds what we showed most recently.
    // Start with it cleared and mark that we're in calcTicks (ie calculating a
    // whole string of these so we should care what the previous date head was!)
    ax._prevDateHead = '';
    ax._inCalcTicks = true;

    var ticksOut = new Array(vals.length);
    for(var i = 0; i &lt; vals.length; i++) ticksOut[i] = axes.<span class="apidocCodeKeywordSpan">tickText</span>(ax, vals[i]);

    ax._inCalcTicks = false;

    return ticksOut;
};

function arrayTicks(ax) {
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.axis_ids" id="apidoc.module.plotly.js.axis_ids">module plotly.js.axis_ids</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.axis_ids.cleanId" id="apidoc.element.plotly.js.axis_ids.cleanId">
        function <span class="apidocSignatureSpan">plotly.js.axis_ids.</span>cleanId
        <span class="apidocSignatureSpan">(id, axLetter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cleanId(id, axLetter) {
    if(!id.match(constants.AX_ID_PATTERN)) return;
    if(axLetter &amp;&amp; id.charAt(0) !== axLetter) return;

    var axNum = id.substr(1).replace(/^0+/, '');
    if(axNum === '1') axNum = '';
    return id.charAt(0) + axNum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
delete layout.yaxis1;
    }

    var axList = Axes.list({_fullLayout: layout});
    for(i = 0; i &lt; axList.length; i++) {
var ax = axList[i];
if(ax.anchor &amp;&amp; ax.anchor !== 'free') {
    ax.anchor = Axes.<span class="apidocCodeKeywordSpan">cleanId</span>(ax.anchor);
}
if(ax.overlaying) ax.overlaying = Axes.cleanId(ax.overlaying);

// old method of axis type - isdate and islog (before category existed)
if(!ax.type) {
    if(ax.isdate) ax.type = 'date';
    else if(ax.islog) ax.type = 'log';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axis_ids.getFromId" id="apidoc.element.plotly.js.axis_ids.getFromId">
        function <span class="apidocSignatureSpan">plotly.js.axis_ids.</span>getFromId
        <span class="apidocSignatureSpan">(gd, id, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFromId = function (gd, id, type) {
    var fullLayout = gd._fullLayout;

    if(type === 'x') id = id.replace(/y[0-9]*/, '');
    else if(type === 'y') id = id.replace(/x[0-9]*/, '');

    return fullLayout[exports.id2name(id)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(val !== undefined) p.set(val);
    }

    // for editing annotations or shapes - is it on autoscaled axes?
    function refAutorange(obj, axLetter) {
if(!Lib.isPlainObject(obj)) return false;
var axRef = obj[axLetter + 'ref'] || axLetter,
    ax = Plotly.Axes.<span class="apidocCodeKeywordSpan">getFromId</span>(gd, axRef);

if(!ax &amp;&amp; axRef.charAt(0) === axLetter) {
    // fall back on the primary axis in case we've referenced a
    // nonexistent axis (as we do above if axRef is missing).
    // This assumes the object defaults to data referenced, which
    // is the case for shapes and annotations but not for images.
    // The only thing this is used for is to determine whether to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axis_ids.getFromTrace" id="apidoc.element.plotly.js.axis_ids.getFromTrace">
        function <span class="apidocSignatureSpan">plotly.js.axis_ids.</span>getFromTrace
        <span class="apidocSignatureSpan">(gd, fullTrace, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFromTrace = function (gd, fullTrace, type) {
    var fullLayout = gd._fullLayout;
    var ax = null;

    if(Registry.traceIs(fullTrace, 'gl3d')) {
        var scene = fullTrace.scene;
        if(scene.substr(0, 5) === 'scene') {
            ax = fullLayout[scene][type + 'axis'];
        }
    }
    else {
        ax = exports.getFromId(gd, fullTrace[type + 'axis'] || type);
    }

    return ax;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axis_ids.id2name" id="apidoc.element.plotly.js.axis_ids.id2name">
        function <span class="apidocSignatureSpan">plotly.js.axis_ids.</span>id2name
        <span class="apidocSignatureSpan">(id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function id2name(id) {
    if(typeof id !== 'string' || !id.match(constants.AX_ID_PATTERN)) return;
    var axNum = id.substr(1);
    if(axNum === '1') axNum = '';
    return id.charAt(0) + 'axis' + axNum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});

// make a new empty vals array for undoit
function a0() { return traces.map(function() { return undefined; }); }

// for autoranging multiple axes
function addToAxlist(axid) {
    var axName = Plotly.Axes.<span class="apidocCodeKeywordSpan">id2name</span>(axid);
    if(axlist.indexOf(axName) === -1) axlist.push(axName);
}

function autorangeAttr(axName) { return 'LAYOUT' + axName + '.autorange'; }

function rangeAttr(axName) { return 'LAYOUT' + axName + '.range'; }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axis_ids.list" id="apidoc.element.plotly.js.axis_ids.list">
        function <span class="apidocSignatureSpan">plotly.js.axis_ids.</span>list
        <span class="apidocSignatureSpan">(gd, axletter, only2d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">list = function (gd, axletter, only2d) {
    return listNames(gd, axletter, only2d)
        .map(function(axName) {
            return Lib.nestedProperty(gd._fullLayout, axName).get();
        });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    delete layout.xaxis1;
}
if(layout.yaxis1) {
    if(!layout.yaxis) layout.yaxis = layout.yaxis1;
    delete layout.yaxis1;
}

var axList = Axes.<span class="apidocCodeKeywordSpan">list</span>({_fullLayout: layout});
for(i = 0; i &lt; axList.length; i++) {
    var ax = axList[i];
    if(ax.anchor &amp;&amp; ax.anchor !== 'free') {
        ax.anchor = Axes.cleanId(ax.anchor);
    }
    if(ax.overlaying) ax.overlaying = Axes.cleanId(ax.overlaying);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axis_ids.listIds" id="apidoc.element.plotly.js.axis_ids.listIds">
        function <span class="apidocSignatureSpan">plotly.js.axis_ids.</span>listIds
        <span class="apidocSignatureSpan">(gd, axletter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listIds = function (gd, axletter) {
    return listNames(gd, axletter, true).map(exports.name2id);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * dflt: the default to coerce to, or blank to use the first axis (falling back on
 *     extraOption if there is no axis)
 * extraOption: aside from existing axes with this letter, what non-axis value is allowed?
 *     Only required if it's different from `dflt`
 */
axes.coerceRef = function(containerIn, containerOut, gd, attr, dflt, extraOption) {
var axLetter = attr.charAt(attr.length - 1),
    axlist = axes.<span class="apidocCodeKeywordSpan">listIds</span>(gd, axLetter),
    refAttr = attr + 'ref',
    attrDef = {};

if(!dflt) dflt = axlist[0] || extraOption;
if(!extraOption) extraOption = dflt;

// data-ref annotations are not supported in gl2d yet
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.axis_ids.name2id" id="apidoc.element.plotly.js.axis_ids.name2id">
        function <span class="apidocSignatureSpan">plotly.js.axis_ids.</span>name2id
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function name2id(name) {
    if(!name.match(constants.AX_NAME_PATTERN)) return;
    var axNum = name.substr(5);
    if(axNum === '1') axNum = '';
    return name.charAt(0) + axNum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// for constraint enforcement: keep track of all axes (as {id: name})
// we're editing the (auto)range of, so we can tell the others constrained
// to scale with them that it's OK for them to shrink
var rangesAltered = {};

function recordAlteredAxis(pleafPlus) {
    var axId = axisIds.<span class="apidocCodeKeywordSpan">name2id</span>(pleafPlus.split('.')[0]);
    rangesAltered[axId] = 1;
}

// alter gd.layout
for(var ai in aobj) {
    if(helpers.hasParent(aobj, ai)) {
        throw new Error('cannot set ' + ai + 'and a parent attribute simultaneously');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.base_plot" id="apidoc.module.plotly.js.base_plot">module plotly.js.base_plot</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.base_plot.clean" id="apidoc.element.plotly.js.base_plot.clean">
        function <span class="apidocSignatureSpan">plotly.js.base_plot.</span>clean
        <span class="apidocSignatureSpan">(newFullData, newFullLayout, oldFullData, oldFullLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clean = function (newFullData, newFullLayout, oldFullData, oldFullLayout) {
    var hadParcoords = (oldFullLayout._has &amp;&amp; oldFullLayout._has('parcoords'));
    var hasParcoords = (newFullLayout._has &amp;&amp; newFullLayout._has('parcoords'));

    if(hadParcoords &amp;&amp; !hasParcoords) {
        oldFullLayout._paperdiv.selectAll('.parcoords-line-layers').remove();
        oldFullLayout._paperdiv.selectAll('.parcoords-line-layers').remove();
        oldFullLayout._paperdiv.selectAll('.parcoords').remove();
        oldFullLayout._paperdiv.selectAll('.parcoords').remove();
        oldFullLayout._glimages.selectAll('*').remove();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        delete scene.cameraposition;
    }
}

// sanitize rgb(fractions) and rgba(fractions) that old tinycolor
// supported, but new tinycolor does not because they're not valid css
Color.<span class="apidocCodeKeywordSpan">clean</span>(layout);

return layout;
};

function cleanAxRef(container, attr) {
var valIn = container[attr],
    axLetter = attr.charAt(0);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.base_plot.plot" id="apidoc.element.plotly.js.base_plot.plot">
        function <span class="apidocSignatureSpan">plotly.js.base_plot.</span>plot
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">plot = function (gd) {
    var calcData = Plots.getSubplotCalcData(gd.calcdata, 'parcoords', 'parcoords');
    if(calcData.length) parcoordsPlot(gd, calcData);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        fullLayout._infolayer.selectAll('.cb' + uid).remove();
    }
}

// loop over the base plot modules present on graph
var basePlotModules = fullLayout._basePlotModules;
for(i = 0; i &lt; basePlotModules.length; i++) {
    basePlotModules[i].<span class="apidocCodeKeywordSpan">plot</span>(gd);
}

// keep reference to shape layers in subplots
var layerSubplot = fullLayout._paper.selectAll('.layer-subplot');
fullLayout._shapeSubplotLayers = layerSubplot.selectAll('.shapelayer');

// styling separate from drawing
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.base_plot.toSVG" id="apidoc.element.plotly.js.base_plot.toSVG">
        function <span class="apidocSignatureSpan">plotly.js.base_plot.</span>toSVG
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toSVG = function (gd) {

    var imageRoot = gd._fullLayout._glimages;
    var root = d3.selectAll('.svg-container');
    var canvases = root.filter(function(d, i) {return i === root.size() - 1;})
        .selectAll('.parcoords-lines.context, .parcoords-lines.focus');

    function canvasToImage(d) {
        var canvas = this;
        var imageData = canvas.toDataURL('image/png');
        var image = imageRoot.append('svg:image');
        var size = gd._fullLayout._size;
        var domain = gd._fullData[d.model.key].domain;

        image.attr({
            xmlns: xmlnsNamespaces.svg,
            'xlink:href': imageData,
            x: size.l + size.w * domain.x[0] - c.overdrag,
            y: size.t + size.h * (1 - domain.y[1]),
            width: (domain.x[1] - domain.x[0]) * size.w + 2 * c.overdrag,
            height: (domain.y[1] - domain.y[0]) * size.h,
            preserveAspectRatio: 'none'
        });
    }

    canvases.each(canvasToImage);

    // Chrome / Safari bug workaround - browser apparently loses connection to the defined pattern
    // Without the workaround, these browsers 'lose' the filter brush styling (color etc.) after a snapshot
    // on a subsequent interaction.
    // Firefox works fine without this workaround
    window.setTimeout(function() {
        d3.selectAll('#filterBarPattern')
            .attr('id', 'filterBarPattern');
    }, 60);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// subplot-specific to-SVG methods
// which notably add the contents of the gl-container
// into the main svg node
var basePlotModules = fullLayout._basePlotModules || [];
for(i = 0; i &lt; basePlotModules.length; i++) {
    var _module = basePlotModules[i];

    if(_module.toSVG) _module.<span class="apidocCodeKeywordSpan">toSVG</span>(gd);
}

// add top items above them assumes everything in toppaper is either
// a group or a defs, and if it's empty (like hoverlayer) we can ignore it.
if(toppaper) {
    var nodes = toppaper.node().childNodes;
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.bin_functions" id="apidoc.module.plotly.js.bin_functions">module plotly.js.bin_functions</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.bin_functions.avg" id="apidoc.element.plotly.js.bin_functions.avg">
        function <span class="apidocSignatureSpan">plotly.js.bin_functions.</span>avg
        <span class="apidocSignatureSpan">(n, i, size, counterData, counts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">avg = function (n, i, size, counterData, counts) {
    var v = counterData[i];
    if(isNumeric(v)) {
        v = Number(v);
        size[n] += v;
        counts[n]++;
    }
    return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.bin_functions.count" id="apidoc.element.plotly.js.bin_functions.count">
        function <span class="apidocSignatureSpan">plotly.js.bin_functions.</span>count
        <span class="apidocSignatureSpan">(n, i, size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (n, i, size) {
    size[n]++;
    return 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.bin_functions.max" id="apidoc.element.plotly.js.bin_functions.max">
        function <span class="apidocSignatureSpan">plotly.js.bin_functions.</span>max
        <span class="apidocSignatureSpan">(n, i, size, counterData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">max = function (n, i, size, counterData) {
    var v = counterData[i];
    if(isNumeric(v)) {
        v = Number(v);
        if(!isNumeric(size[n])) {
            size[n] = v;
            return v;
        }
        else if(size[n] &lt; v) {
            var delta = v - size[n];
            size[n] = v;
            return delta;
        }
    }
    return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   if(e.preventDefault) e.preventDefault();
   e.cancelBubble = true;
   return false;
};

// constrain - restrict a number v to be between v0 and v1
lib.constrain = function(v, v0, v1) {
   if(v0 &gt; v1) return Math.<span class="apidocCodeKeywordSpan">max</span>(v1, Math.min(v0, v));
   return Math.max(v0, Math.min(v1, v));
};

/**
* do two bounding boxes from getBoundingClientRect,
* ie {left,right,top,bottom,width,height}, overlap?
* takes optional padding pixels
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.bin_functions.min" id="apidoc.element.plotly.js.bin_functions.min">
        function <span class="apidocSignatureSpan">plotly.js.bin_functions.</span>min
        <span class="apidocSignatureSpan">(n, i, size, counterData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">min = function (n, i, size, counterData) {
    var v = counterData[i];
    if(isNumeric(v)) {
        v = Number(v);
        if(!isNumeric(size[n])) {
            size[n] = v;
            return v;
        }
        else if(size[n] &gt; v) {
            var delta = v - size[n];
            size[n] = v;
            return delta;
        }
    }
    return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * d3's vocabulary:
 * %{n}f where n is the max number of digits of fractional seconds
 */
var fracMatch = /%\d?f/g;
function modDateFormat(fmt, x, calendar) {

fmt = fmt.replace(fracMatch, function(match) {
    var digits = Math.<span class="apidocCodeKeywordSpan">min</span>(+(match.charAt(1)) || 6, 6),
        fracSecs = ((x / 1000 % 1) + 2)
            .toFixed(digits)
            .substr(2).replace(/0+$/, '') || '0';
    return fracSecs;
});

var d = new Date(Math.floor(x + 0.05));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.bin_functions.sum" id="apidoc.element.plotly.js.bin_functions.sum">
        function <span class="apidocSignatureSpan">plotly.js.bin_functions.</span>sum
        <span class="apidocSignatureSpan">(n, i, size, counterData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sum = function (n, i, size, counterData) {
    var v = counterData[i];
    if(isNumeric(v)) {
        v = Number(v);
        size[n] += v;
        return v;
    }
    return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (typeof keys === 'string') keys = keys.split('.');
    var next = keys.shift();
    return obj[next] &amp;&amp; (!keys.length || objHasKeys(obj[next], keys));
};

Âµ.util.sumArrays = function(a, b) {
    return d3.zip(a, b).map(function(d, i) {
        return d3.<span class="apidocCodeKeywordSpan">sum</span>(d);
    });
};

Âµ.util.arrayLast = function(a) {
    return a[a.length - 1];
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.calendars" id="apidoc.module.plotly.js.calendars">module plotly.js.calendars</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.calendars.getCal" id="apidoc.element.plotly.js.calendars.getCal">
        function <span class="apidocSignatureSpan">plotly.js.calendars.</span>getCal
        <span class="apidocSignatureSpan">(calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getCal(calendar) {
    var calendarObj = allCals[calendar];
    if(calendarObj) return calendarObj;

    calendarObj = allCals[calendar] = calendars.instance(calendar);
    return calendarObj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.calendars.handleDefaults" id="apidoc.element.plotly.js.calendars.handleDefaults">
        function <span class="apidocSignatureSpan">plotly.js.calendars.</span>handleDefaults
        <span class="apidocSignatureSpan">(contIn, contOut, attr, dflt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleDefaults = function (contIn, contOut, attr, dflt) {
    var attrs = {};
    attrs[attr] = attributes;

    return Lib.coerce(contIn, contOut, attrs, attr, dflt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.calendars.handleTraceDefaults" id="apidoc.element.plotly.js.calendars.handleTraceDefaults">
        function <span class="apidocSignatureSpan">plotly.js.calendars.</span>handleTraceDefaults
        <span class="apidocSignatureSpan">(traceIn, traceOut, coords, layout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">handleTraceDefaults = function (traceIn, traceOut, coords, layout) {
    for(var i = 0; i &lt; coords.length; i++) {
        handleDefaults(traceIn, traceOut, coords[i] + 'calendar', layout.calendar);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.calendars.worldCalFmt" id="apidoc.element.plotly.js.calendars.worldCalFmt">
        function <span class="apidocSignatureSpan">plotly.js.calendars.</span>worldCalFmt
        <span class="apidocSignatureSpan">(fmt, x, calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function worldCalFmt(fmt, x, calendar) {
    var dateJD = Math.floor((x + 0.05) / ONEDAY) + EPOCHJD,
        cDate = getCal(calendar).fromJD(dateJD),
        i = 0,
        modifier, directive, directiveLen, directiveObj, replacementPart;
    while((i = fmt.indexOf('%', i)) !== -1) {
        modifier = fmt.charAt(i + 1);
        if(modifier === '0' || modifier === '-' || modifier === '_') {
            directiveLen = 3;
            directive = fmt.charAt(i + 2);
            if(modifier === '_') modifier = '-';
        }
        else {
            directive = modifier;
            modifier = '0';
            directiveLen = 2;
        }
        directiveObj = d3ToWorldCalendars[directive];
        if(!directiveObj) {
            i += directiveLen;
        }
        else {
            // code is recognized as a date part but world-calendars doesn't support it
            if(directiveObj === UNKNOWN) replacementPart = UNKNOWN;

            // format the cDate according to the translated directive
            else replacementPart = cDate.formatDate(directiveObj[modifier]);

            fmt = fmt.substr(0, i) + replacementPart + fmt.substr(i + directiveLen);
            i += replacementPart.length;
        }
    }
    return fmt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.carpet" id="apidoc.module.plotly.js.carpet">module plotly.js.carpet</a></h1>




    <h2>
        <a href="#apidoc.element.plotly.js.carpet.calc" id="apidoc.element.plotly.js.carpet.calc">
        function <span class="apidocSignatureSpan">plotly.js.carpet.</span>calc
        <span class="apidocSignatureSpan">(gd, trace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function calc(gd, trace) {
    var xa = Axes.getFromId(gd, trace.xaxis || 'x');
    var ya = Axes.getFromId(gd, trace.yaxis || 'y');
    var aax = trace.aaxis;
    var bax = trace.baxis;
    var a = trace._a = trace.a;
    var b = trace._b = trace.b;

    var t = {};
    var x;
    var y = trace.y;

    if(trace._cheater) {
        var avals = aax.cheatertype === 'index' ? a.length : a;
        var bvals = bax.cheatertype === 'index' ? b.length : b;
        trace.x = x = cheaterBasis(avals, bvals, trace.cheaterslope);
    } else {
        x = trace.x;
    }

    trace._x = trace.x = x = clean2dArray(x);
    trace._y = trace.y = y = clean2dArray(y);

    // Fill in any undefined values with elliptic smoothing. This doesn't take
    // into account the spacing of the values. That is, the derivatives should
    // be modified to use a and b values. It's not that hard, but this is already
    // moderate overkill for just filling in missing values.
    smoothFill2dArray(x, a, b);
    smoothFill2dArray(y, a, b);

    // create conversion functions that depend on the data
    trace.setScale();

    // Convert cartesian-space x/y coordinates to screen space pixel coordinates:
    t.xp = trace.xp = map2dArray(trace.xp, x, xa.c2p);
    t.yp = trace.yp = map2dArray(trace.yp, y, ya.c2p);

    // This is a rather expensive scan. Nothing guarantees monotonicity,
    // so we need to scan through all data to get proper ranges:
    var xrange = arrayMinmax(x);
    var yrange = arrayMinmax(y);

    var dx = 0.5 * (xrange[1] - xrange[0]);
    var xc = 0.5 * (xrange[1] + xrange[0]);

    var dy = 0.5 * (yrange[1] - yrange[0]);
    var yc = 0.5 * (yrange[1] + yrange[0]);

    // Expand the axes to fit the plot, except just grow it by a factor of 1.3
    // because the labels should be taken into account except that's difficult
    // hence 1.3.
    var grow = 1.3;
    xrange = [xc - dx * grow, xc + dx * grow];
    yrange = [yc - dy * grow, yc + dy * grow];

    Axes.expand(xa, xrange, {padded: true});
    Axes.expand(ya, yrange, {padded: true});

    // Enumerate the gridlines, both major and minor, and store them on the trace
    // object:
    calcGridlines(trace, t, 'a', 'b');
    calcGridlines(trace, t, 'b', 'a');

    // Calculate the text labels for each major gridline and store them on the
    // trace object:
    calcLabels(trace, aax);
    calcLabels(trace, bax);

    // Tabulate points for the four segments that bound the axes so that we can
    // map to pixel coordinates in the plot function and create a clip rect:
    t.clipsegments = calcClipPath(trace.xctrl, trace.yctrl, aax, bax);

    t.x = x;
    t.y = y;
    t.a = a;
    t.b = b;

    return [t];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for(var j = 0; j &lt; modules.length; j++) {
        _module = modules[j];
        if(_module.setPositions) _module.setPositions(gd, subplotInfo);
    }
}

// calc and autorange for errorbars
ErrorBars.<span class="apidocCodeKeywordSpan">calc</span>(gd);

// TODO: autosize extra for text markers and images
// see https://github.com/plotly/plotly.js/issues/1111
return Lib.syncOrAsync([
    Registry.getComponentMethod('shapes', 'calcAutorange'),
    Registry.getComponentMethod('annotations', 'calcAutorange'),
    doAutoRangeAndConstraints,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.carpet.plot" id="apidoc.element.plotly.js.carpet.plot">
        function <span class="apidocSignatureSpan">plotly.js.carpet.</span>plot
        <span class="apidocSignatureSpan">(gd, plotinfo, cdcarpet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function plot(gd, plotinfo, cdcarpet) {
    for(var i = 0; i &lt; cdcarpet.length; i++) {
        plotOne(gd, plotinfo, cdcarpet[i]);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        fullLayout._infolayer.selectAll('.cb' + uid).remove();
    }
}

// loop over the base plot modules present on graph
var basePlotModules = fullLayout._basePlotModules;
for(i = 0; i &lt; basePlotModules.length; i++) {
    basePlotModules[i].<span class="apidocCodeKeywordSpan">plot</span>(gd);
}

// keep reference to shape layers in subplots
var layerSubplot = fullLayout._paper.selectAll('.layer-subplot');
fullLayout._shapeSubplotLayers = layerSubplot.selectAll('.shapelayer');

// styling separate from drawing
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.carpet.supplyDefaults" id="apidoc.element.plotly.js.carpet.supplyDefaults">
        function <span class="apidocSignatureSpan">plotly.js.carpet.</span>supplyDefaults
        <span class="apidocSignatureSpan">(traceIn, traceOut, dfltColor, fullLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function supplyDefaults(traceIn, traceOut, dfltColor, fullLayout) {
    function coerce(attr, dflt) {
        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
    }

    var defaultColor = coerce('color', colorAttrs.defaultLine);
    Lib.coerceFont(coerce, 'font');

    coerce('carpet');

    handleABDefaults(traceIn, traceOut, fullLayout, coerce, defaultColor);

    if(!traceOut.a || !traceOut.b) {
        traceOut.visible = false;
        return;
    }

    if(traceOut.a.length &lt; 3) {
        traceOut.aaxis.smoothing = 0;
    }

    if(traceOut.b.length &lt; 3) {
        traceOut.baxis.smoothing = 0;
    }

    // NB: the input is x/y arrays. You should know that the *first* dimension of x and y
    // corresponds to b and the second to a. This sounds backwards but ends up making sense
    // the important part to know is that when you write y[j][i], j goes from 0 to b.length - 1
    // and i goes from 0 to a.length - 1.
    var len = handleXYDefaults(traceIn, traceOut, coerce);

    setConvert(traceOut);

    if(traceOut._cheater) {
        coerce('cheaterslope');
    }

    if(!len) {
        traceOut.visible = false;
        return;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    gd._replotPending = true;
    return Promise.reject();
} else {
    // we're going ahead with a replot now
    gd._replotPending = false;
}

Plots.<span class="apidocCodeKeywordSpan">supplyDefaults</span>(gd);

var fullLayout = gd._fullLayout;

// Polar plots
if(data &amp;&amp; data[0] &amp;&amp; data[0].r) return plotPolar(gd, data, layout);

// so we don't try to re-call Plotly.plot from inside
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.click" id="apidoc.module.plotly.js.click">module plotly.js.click</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.click.hasClickToShow" id="apidoc.element.plotly.js.click.hasClickToShow">
        function <span class="apidocSignatureSpan">plotly.js.click.</span>hasClickToShow
        <span class="apidocSignatureSpan">(gd, hoverData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hasClickToShow(gd, hoverData) {
    var sets = getToggleSets(gd, hoverData);
    return sets.on.length &gt; 0 || sets.explicitOff.length &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.click.onClick" id="apidoc.element.plotly.js.click.onClick">
        function <span class="apidocSignatureSpan">plotly.js.click.</span>onClick
        <span class="apidocSignatureSpan">(gd, hoverData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onClick(gd, hoverData) {
    var toggleSets = getToggleSets(gd, hoverData),
        onSet = toggleSets.on,
        offSet = toggleSets.off.concat(toggleSets.explicitOff),
        update = {},
        i;

    if(!(onSet.length || offSet.length)) return;

    for(i = 0; i &lt; onSet.length; i++) {
        update['annotations[' + onSet[i] + '].visible'] = true;
    }

    for(i = 0; i &lt; offSet.length; i++) {
        update['annotations[' + offSet[i] + '].visible'] = false;
    }

    return Plotly.update(gd, {}, update);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.coerce" id="apidoc.module.plotly.js.coerce">module plotly.js.coerce</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.coerce.coerce" id="apidoc.element.plotly.js.coerce.coerce">
        function <span class="apidocSignatureSpan">plotly.js.</span>coerce
        <span class="apidocSignatureSpan">(containerIn, containerOut, attributes, attribute, dflt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coerce = function (containerIn, containerOut, attributes, attribute, dflt) {
    var opts = nestedProperty(attributes, attribute).get(),
        propIn = nestedProperty(containerIn, attribute),
        propOut = nestedProperty(containerOut, attribute),
        v = propIn.get();

    if(dflt === undefined) dflt = opts.dflt;

<span class="apidocCodeCommentSpan">    /**
     * arrayOk: value MAY be an array, then we do no value checking
     * at this point, because it can be more complicated than the
     * individual form (eg. some array vals can be numbers, even if the
     * single values must be color strings)
     */
</span>    if(opts.arrayOk &amp;&amp; Array.isArray(v)) {
        propOut.set(v);
        return v;
    }

    exports.valObjects[opts.valType].coerceFunction(v, propOut, dflt, opts);

    return propOut.get();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    var items = opts.items,
        vOut = [];
    dflt = Array.isArray(dflt) ? dflt : [];

    for(var i = 0; i &lt; items.length; i++) {
        exports.<span class="apidocCodeKeywordSpan">coerce</span>(v, vOut, items, '[' + i + ']', dflt[i]);
    }

    propOut.set(vOut);
},
validateFunction: function(v, opts) {
    if(!Array.isArray(v)) return false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.coerce.coerce2" id="apidoc.element.plotly.js.coerce.coerce2">
        function <span class="apidocSignatureSpan">plotly.js.coerce.</span>coerce2
        <span class="apidocSignatureSpan">(containerIn, containerOut, attributes, attribute, dflt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coerce2 = function (containerIn, containerOut, attributes, attribute, dflt) {
    var propIn = nestedProperty(containerIn, attribute),
        propOut = exports.coerce(containerIn, containerOut, attributes, attribute, dflt),
        valIn = propIn.get();

    return (valIn !== undefined &amp;&amp; valIn !== null) ? propOut : false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var letter = options.letter,
    font = options.font || {},
    defaultTitle = 'Click to enter ' +
        (options.title || (letter.toUpperCase() + ' axis')) +
        ' title';

function coerce2(attr, dflt) {
    return Lib.<span class="apidocCodeKeywordSpan">coerce2</span>(containerIn, containerOut, layoutAttributes, attr, dflt);
}

var visible = coerce('visible', !options.cheateronly);

var axType = containerOut.type;

if(axType === 'date') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.coerce.coerceFont" id="apidoc.element.plotly.js.coerce.coerceFont">
        function <span class="apidocSignatureSpan">plotly.js.coerce.</span>coerceFont
        <span class="apidocSignatureSpan">(coerce, attr, dfltObj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coerceFont = function (coerce, attr, dfltObj) {
    var out = {};

    dfltObj = dfltObj || {};

    out.family = coerce(attr + '.family', dfltObj.family);
    out.size = coerce(attr + '.size', dfltObj.size);
    out.color = coerce(attr + '.color', dfltObj.color);

    return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

plots.supplyLayoutGlobalDefaults = function(layoutIn, layoutOut) {
function coerce(attr, dflt) {
    return Lib.coerce(layoutIn, layoutOut, plots.layoutAttributes, attr, dflt);
}

var globalFont = Lib.<span class="apidocCodeKeywordSpan">coerceFont</span>(coerce, 'font');

coerce('title');

Lib.coerceFont(coerce, 'titlefont', {
    family: globalFont.family,
    size: Math.round(globalFont.size * 1.4),
    color: globalFont.color
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.coerce.validate" id="apidoc.element.plotly.js.coerce.validate">
        function <span class="apidocSignatureSpan">plotly.js.coerce.</span>validate
        <span class="apidocSignatureSpan">(value, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (value, opts) {
    var valObject = exports.valObjects[opts.valType];

    if(opts.arrayOk &amp;&amp; Array.isArray(value)) return true;

    if(valObject.validateFunction) {
        return valObject.validateFunction(value, opts);
    }

    var failed = {},
        out = failed,
        propMock = { set: function(v) { out = v; } };

    // 'failed' just something mutable that won't be === anything else

    valObject.coerceFunction(value, propMock, failed, opts);
    return out !== failed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var items = opts.items;

        // when free length is off, input and declared lengths must match
        if(!opts.freeLength &amp;&amp; v.length !== items.length) return false;

        // valid when all input items are valid
        for(var i = 0; i &lt; v.length; i++) {
            var isItemValid = exports.<span class="apidocCodeKeywordSpan">validate</span>(v[i], opts.items[i]);

            if(!isItemValid) return false;
        }

        return true;
    }
}
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.command" id="apidoc.module.plotly.js.command">module plotly.js.command</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.command.computeAPICommandBindings" id="apidoc.element.plotly.js.command.computeAPICommandBindings">
        function <span class="apidocSignatureSpan">plotly.js.command.</span>computeAPICommandBindings
        <span class="apidocSignatureSpan">(gd, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">computeAPICommandBindings = function (gd, method, args) {
    var bindings;

    if(!Array.isArray(args)) args = [];

    switch(method) {
        case 'restyle':
            bindings = computeDataBindings(gd, args);
            break;
        case 'relayout':
            bindings = computeLayoutBindings(gd, args);
            break;
        case 'update':
            bindings = computeDataBindings(gd, [args[0], args[2]])
                .concat(computeLayoutBindings(gd, [args[1]]));
            break;
        case 'animate':
            bindings = computeAnimateBindings(gd, args);
            break;
        default:
            // This is the case where intelligent logic about what affects
            // this command is not implemented. It causes no ill effects.
            // For example, addFrames simply won't bind to a control component.
            bindings = [];
    }
    return bindings;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if(!Array.isArray(args)) args = [];

// If any command has no method, refuse to bind:
if(!method) {
    return false;
}
var bindings = exports.<span class="apidocCodeKeywordSpan">computeAPICommandBindings</span>(gd, method, args);

// Right now, handle one and *only* one property being set:
if(bindings.length !== 1) {
    return false;
}

if(!refBinding) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.command.executeAPICommand" id="apidoc.element.plotly.js.command.executeAPICommand">
        function <span class="apidocSignatureSpan">plotly.js.command.</span>executeAPICommand
        <span class="apidocSignatureSpan">(gd, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">executeAPICommand = function (gd, method, args) {
    var apiMethod = Plotly[method];

    var allArgs = [gd];

    if(!Array.isArray(args)) args = [];

    for(var i = 0; i &lt; args.length; i++) {
        allArgs.push(args[i]);
    }

    return apiMethod.apply(null, allArgs).catch(function(err) {
        Lib.warn('API call to Plotly.' + method + ' rejected.', err);
        return Promise.reject(err);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.command.hasSimpleAPICommandBindings" id="apidoc.element.plotly.js.command.hasSimpleAPICommandBindings">
        function <span class="apidocSignatureSpan">plotly.js.command.</span>hasSimpleAPICommandBindings
        <span class="apidocSignatureSpan">(gd, commandList, bindingsByValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasSimpleAPICommandBindings = function (gd, commandList, bindingsByValue) {
    var i;
    var n = commandList.length;

    var refBinding;

    for(i = 0; i &lt; n; i++) {
        var binding;
        var command = commandList[i];
        var method = command.method;
        var args = command.args;

        if(!Array.isArray(args)) args = [];

        // If any command has no method, refuse to bind:
        if(!method) {
            return false;
        }
        var bindings = exports.computeAPICommandBindings(gd, method, args);

        // Right now, handle one and *only* one property being set:
        if(bindings.length !== 1) {
            return false;
        }

        if(!refBinding) {
            refBinding = bindings[0];
            if(Array.isArray(refBinding.traces)) {
                refBinding.traces.sort();
            }
        } else {
            binding = bindings[0];
            if(binding.type !== refBinding.type) {
                return false;
            }
            if(binding.prop !== refBinding.prop) {
                return false;
            }
            if(Array.isArray(refBinding.traces)) {
                if(Array.isArray(binding.traces)) {
                    binding.traces.sort();
                    for(var j = 0; j &lt; refBinding.traces.length; j++) {
                        if(refBinding.traces[j] !== binding.traces[j]) {
                            return false;
                        }
                    }
                } else {
                    return false;
                }
            } else {
                if(binding.prop !== refBinding.prop) {
                    return false;
                }
            }
        }

        binding = bindings[0];
        var value = binding.value;
        if(Array.isArray(value)) {
            if(value.length === 1) {
                value = value[0];
            } else {
                return false;
            }
        }
        if(bindingsByValue) {
            bindingsByValue[value] = i;
        }
    }

    return refBinding;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(!ret.cache) {
    ret.cache = {};
}

// Either create or just recompute this:
ret.lookupTable = {};

var binding = exports.<span class="apidocCodeKeywordSpan">hasSimpleAPICommandBindings</span>(gd, commandList, ret.lookupTable);

if(container &amp;&amp; container._commandObserver) {
    if(!binding) {
        // If container exists and there are no longer any bindings,
        // remove existing:
        if(container._commandObserver.remove) {
            container._commandObserver.remove();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.command.manageCommandObserver" id="apidoc.element.plotly.js.command.manageCommandObserver">
        function <span class="apidocSignatureSpan">plotly.js.command.</span>manageCommandObserver
        <span class="apidocSignatureSpan">(gd, container, commandList, onchange)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">manageCommandObserver = function (gd, container, commandList, onchange) {
    var ret = {};
    var enabled = true;

    if(container &amp;&amp; container._commandObserver) {
        ret = container._commandObserver;
    }

    if(!ret.cache) {
        ret.cache = {};
    }

    // Either create or just recompute this:
    ret.lookupTable = {};

    var binding = exports.hasSimpleAPICommandBindings(gd, commandList, ret.lookupTable);

    if(container &amp;&amp; container._commandObserver) {
        if(!binding) {
            // If container exists and there are no longer any bindings,
            // remove existing:
            if(container._commandObserver.remove) {
                container._commandObserver.remove();
                container._commandObserver = null;
                return ret;
            }
        } else {
            // If container exists and there *are* bindings, then the lookup
            // table should have been updated and check is already attached,
            // so there's nothing to be done:
            return ret;


        }
    }

    // Determine whether there's anything to do for this binding:

    if(binding) {
        // Build the cache:
        bindingValueHasChanged(gd, binding, ret.cache);

        ret.check = function check() {
            if(!enabled) return;

            var update = bindingValueHasChanged(gd, binding, ret.cache);

            if(update.changed &amp;&amp; onchange) {
                // Disable checks for the duration of this command in order to avoid
                // infinite loops:
                if(ret.lookupTable[update.value] !== undefined) {
                    ret.disable();
                    Promise.resolve(onchange({
                        value: update.value,
                        type: binding.type,
                        prop: binding.prop,
                        traces: binding.traces,
                        index: ret.lookupTable[update.value]
                    })).then(ret.enable, ret.enable);
                }
            }

            return update.changed;
        };

        var checkEvents = [
            'plotly_relayout',
            'plotly_redraw',
            'plotly_restyle',
            'plotly_update',
            'plotly_animatingframe',
            'plotly_afterplot'
        ];

        for(var i = 0; i &lt; checkEvents.length; i++) {
            gd._internalOn(checkEvents[i], ret.check);
        }

        ret.remove = function() {
            for(var i = 0; i &lt; checkEvents.length; i++) {
                gd._removeInternalListener(checkEvents[i], ret.check);
            }
        };
    } else {
        // TODO: It'd be really neat to actually give a *reason* for this, but at least a warning
        // is a start
        Lib.warn('Unable to automatically bind plot updates to API command');

        ret.lookupTable = {};
        ret.remove = function() {};
    }

    ret.disable = function disable() {
        enabled = false;
    };

    ret.enable = function enable() {
        enabled = true;
    };

    if(container) {
        container._commandObserver = ret;
    }

    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.common" id="apidoc.module.plotly.js.common">module plotly.js.common</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.common.doesDirExist" id="apidoc.element.plotly.js.common.doesDirExist">
        function <span class="apidocSignatureSpan">plotly.js.common.</span>doesDirExist
        <span class="apidocSignatureSpan">(dirPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doesDirExist = function (dirPath) {
    try {
        if(fs.statSync(dirPath).isDirectory()) return true;
    }
    catch(e) {
        return false;
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
logger('make build/credentials.json');
}

// Make artifact folders for image tests
function makeTestImageFolders() {

function makeOne(folderPath, info) {
    if(!common.<span class="apidocCodeKeywordSpan">doesDirExist</span>(folderPath)) {
        fs.mkdirSync(folderPath);
        logger('initialize ' + info);
    }
    else logger(info + ' is present');
}

makeOne(constants.pathToTestImages, 'test image folder');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.common.doesFileExist" id="apidoc.element.plotly.js.common.doesFileExist">
        function <span class="apidocSignatureSpan">plotly.js.common.</span>doesFileExist
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doesFileExist = function (filePath) {
    try {
        if(fs.statSync(filePath).isFile()) return true;
    }
    catch(e) {
        return false;
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    date.toLocaleDateString(),
    date.toLocaleTimeString(),
    date.toString().match(/\(([A-Za-z\s].*)\)/)[1]
].join(' ');
};

exports.getTimeLastModified = function(filePath) {
if(!exports.<span class="apidocCodeKeywordSpan">doesFileExist</span>(filePath)) {
    throw new Error(filePath + ' does not exist');
}

var stats = fs.statSync(filePath),
    formattedTime = exports.formatTime(stats.mtime);

return formattedTime;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.common.execCmd" id="apidoc.element.plotly.js.common.execCmd">
        function <span class="apidocSignatureSpan">plotly.js.common.</span>execCmd
        <span class="apidocSignatureSpan">(cmd, cb, errorCb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">execCmd = function (cmd, cb, errorCb) {
    cb = cb ? cb : function() {};
    errorCb = errorCb ? errorCb : function(err) { if(err) throw err; };

    exec(cmd, function(err) {
        errorCb(err);
        cb();
    })
    .stdout.pipe(process.stdout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

case 'run':
    msg = 'Booting up ' + constants.testContainerName + ' docker container';
    cmd = containerCommands.dockerRun;

    // if docker-run fails, try docker-start.
    errorCb = function(err) {
        if(err) common.<span class="apidocCodeKeywordSpan">execCmd</span>('docker start ' + constants.testContainerName
);
    };

    break;

case 'setup':
    msg = 'Setting up ' + constants.testContainerName + ' docker container for testing';
    cmd = containerCommands.getRunCmd(isCI, containerCommands.setup);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.common.formatTime" id="apidoc.element.plotly.js.common.formatTime">
        function <span class="apidocSignatureSpan">plotly.js.common.</span>formatTime
        <span class="apidocSignatureSpan">(date)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatTime = function (date) {
    return [
        date.toLocaleDateString(),
        date.toLocaleTimeString(),
        date.toString().match(/\(([A-Za-z\s].*)\)/)[1]
    ].join(' ');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

exports.getTimeLastModified = function(filePath) {
    if(!exports.doesFileExist(filePath)) {
        throw new Error(filePath + ' does not exist');
    }

    var stats = fs.statSync(filePath),
        formattedTime = exports.<span class="apidocCodeKeywordSpan">formatTime</span>(stats.mtime);

    return formattedTime;
};

exports.touch = function(filePath) {
    fs.closeSync(fs.openSync(filePath, 'w'));
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.common.getTimeLastModified" id="apidoc.element.plotly.js.common.getTimeLastModified">
        function <span class="apidocSignatureSpan">plotly.js.common.</span>getTimeLastModified
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTimeLastModified = function (filePath) {
    if(!exports.doesFileExist(filePath)) {
        throw new Error(filePath + ' does not exist');
    }

    var stats = fs.statSync(filePath),
        formattedTime = exports.formatTime(stats.mtime);

    return formattedTime;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.common.throwOnError" id="apidoc.element.plotly.js.common.throwOnError">
        function <span class="apidocSignatureSpan">plotly.js.common.</span>throwOnError
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwOnError = function (err) {
    if(err) throw err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.common.touch" id="apidoc.element.plotly.js.common.touch">
        function <span class="apidocSignatureSpan">plotly.js.common.</span>touch
        <span class="apidocSignatureSpan">(filePath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">touch = function (filePath) {
    fs.closeSync(fs.openSync(filePath, 'w'));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.common.writeFile" id="apidoc.element.plotly.js.common.writeFile">
        function <span class="apidocSignatureSpan">plotly.js.common.</span>writeFile
        <span class="apidocSignatureSpan">(filePath, content, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeFile = function (filePath, content, cb) {
    fs.writeFile(filePath, content, function(err) {
        if(err) throw err;
        if(cb) cb();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Create a credentials json file,
// to be required in jasmine test suites and test dashboard
function makeCredentialsFile() {
var credentials = JSON.stringify({
    MAPBOX_ACCESS_TOKEN: constants.mapboxAccessToken
}, null, 2);

common.<span class="apidocCodeKeywordSpan">writeFile</span>(constants.pathToCredentials, credentials);
logger('make build/credentials.json');
}

// Make artifact folders for image tests
function makeTestImageFolders() {

function makeOne(folderPath, info) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.constraint_mapping" id="apidoc.module.plotly.js.constraint_mapping">module plotly.js.constraint_mapping</a></h1>

</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.container_commands" id="apidoc.module.plotly.js.container_commands">module plotly.js.container_commands</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.container_commands.getRunCmd" id="apidoc.element.plotly.js.container_commands.getRunCmd">
        function <span class="apidocSignatureSpan">plotly.js.container_commands.</span>getRunCmd
        <span class="apidocSignatureSpan">(isCI, commands)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getRunCmd = function (isCI, commands) {
    var _commands = Array.isArray(commands) ? commands.slice() : [commands];

    if(isCI) return getRunCI(_commands);

    // add setup commands locally
    _commands = [containerCommands.setup].concat(_commands);
    return getRunLocal(_commands);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if(err) common.execCmd('docker start ' + constants.testContainerName);
    };

    break;

case 'setup':
    msg = 'Setting up ' + constants.testContainerName + ' docker container for testing';
    cmd = containerCommands.<span class="apidocCodeKeywordSpan">getRunCmd</span>(isCI, containerCommands.setup);
    break;

case 'stop':
    msg = 'Stopping ' + constants.testContainerName + ' docker container';
    cmd = 'docker stop ' + constants.testContainerName;
    break;
...</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.dates" id="apidoc.module.plotly.js.dates">module plotly.js.dates</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.dates.cleanDate" id="apidoc.element.plotly.js.dates.cleanDate">
        function <span class="apidocSignatureSpan">plotly.js.dates.</span>cleanDate
        <span class="apidocSignatureSpan">(v, dflt, calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanDate = function (v, dflt, calendar) {
    if(exports.isJSDate(v) || typeof v === 'number') {
        // do not allow milliseconds (old) or jsdate objects (inherently
        // described as gregorian dates) with world calendars
        if(isWorldCalendar(calendar)) {
            logError('JS Dates and milliseconds are incompatible with world calendars', v);
            return dflt;
        }

        // NOTE: if someone puts in a year as a number rather than a string,
        // this will mistakenly convert it thinking it's milliseconds from 1970
        // that is: '2012' -&gt; Jan. 1, 2012, but 2012 -&gt; 2012 epoch milliseconds
        v = exports.ms2DateTimeLocal(+v);
        if(!v &amp;&amp; dflt !== undefined) return dflt;
    }
    else if(!exports.isDateTime(v, calendar)) {
        logError('unrecognized date', v);
        return dflt;
    }
    return v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if(typeof pos === 'string' &amp;&amp; (ax._categories || []).length) {
                newPos = ax._categories.indexOf(pos);
                containerOut[attr] = (newPos === -1) ? dflt : newPos;
                return;
            }
        }
        else if(ax.type === 'date') {
            containerOut[attr] = Lib.<span class="apidocCodeKeywordSpan">cleanDate</span>(pos, BADNUM, ax.calendar);
            return;
        }
    }
    // finally make sure we have a number (unless date type already returned a string)
    containerOut[attr] = isNumeric(pos) ? Number(pos) : dflt;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.dates.dateTick0" id="apidoc.element.plotly.js.dates.dateTick0">
        function <span class="apidocSignatureSpan">plotly.js.dates.</span>dateTick0
        <span class="apidocSignatureSpan">(calendar, sunday)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateTick0 = function (calendar, sunday) {
    if(isWorldCalendar(calendar)) {
        return sunday ?
            Registry.getComponentMethod('calendars', 'CANONICAL_SUNDAY')[calendar] :
            Registry.getComponentMethod('calendars', 'CANONICAL_TICK')[calendar];
    }
    else {
        return sunday ? '2000-01-02' : '2000-01-01';
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//      log with linear ticks: L# where # is the linear tick spacing
//      log showing powers plus some intermediates:
//          D1 shows all digits, D2 shows 2 and 5
axes.autoTicks = function(ax, roughDTick) {
    var base;

    if(ax.type === 'date') {
ax.tick0 = Lib.<span class="apidocCodeKeywordSpan">dateTick0</span>(ax.calendar);
// the criteria below are all based on the rough spacing we calculate
// being &gt; half of the final unit - so precalculate twice the rough val
var roughX2 = 2 * roughDTick;

if(roughX2 &gt; ONEAVGYEAR) {
    roughDTick /= ONEAVGYEAR;
    base = Math.pow(10, Math.floor(Math.log(roughDTick) / Math.LN10));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.dates.dateTime2ms" id="apidoc.element.plotly.js.dates.dateTime2ms">
        function <span class="apidocSignatureSpan">plotly.js.dates.</span>dateTime2ms
        <span class="apidocSignatureSpan">(s, calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateTime2ms = function (s, calendar) {
    // first check if s is a date object
    if(exports.isJSDate(s)) {
        // Convert to the UTC milliseconds that give the same
        // hours as this date has in the local timezone
        s = Number(s) - s.getTimezoneOffset() * ONEMIN;
        if(s &gt;= MIN_MS &amp;&amp; s &lt;= MAX_MS) return s;
        return BADNUM;
    }
    // otherwise only accept strings and numbers
    if(typeof s !== 'string' &amp;&amp; typeof s !== 'number') return BADNUM;

    s = String(s);

    var isWorld = isWorldCalendar(calendar);

    // to handle out-of-range dates in international calendars, accept
    // 'G' as a prefix to force the built-in gregorian calendar.
    var s0 = s.charAt(0);
    if(isWorld &amp;&amp; (s0 === 'G' || s0 === 'g')) {
        s = s.substr(1);
        calendar = '';
    }

    var isChinese = isWorld &amp;&amp; calendar.substr(0, 7) === 'chinese';

    var match = s.match(isChinese ? DATETIME_REGEXP_CN : DATETIME_REGEXP);
    if(!match) return BADNUM;
    var y = match[1],
        m = match[3] || '1',
        d = Number(match[5] || 1),
        H = Number(match[7] || 0),
        M = Number(match[9] || 0),
        S = Number(match[11] || 0);

    if(isWorld) {
        // disallow 2-digit years for world calendars
        if(y.length === 2) return BADNUM;
        y = Number(y);

        var cDate;
        try {
            var calInstance = Registry.getComponentMethod('calendars', 'getCal')(calendar);
            if(isChinese) {
                var isIntercalary = m.charAt(m.length - 1) === 'i';
                m = parseInt(m, 10);
                cDate = calInstance.newDate(y, calInstance.toMonthIndex(y, m, isIntercalary), d);
            }
            else {
                cDate = calInstance.newDate(y, Number(m), d);
            }
        }
        catch(e) { return BADNUM; } // Invalid ... date

        if(!cDate) return BADNUM;

        return ((cDate.toJD() - EPOCHJD) * ONEDAY) +
            (H * ONEHOUR) + (M * ONEMIN) + (S * ONESEC);
    }

    if(y.length === 2) {
        y = (Number(y) + 2000 - YFIRST) % 100 + YFIRST;
    }
    else y = Number(y);

    // new Date uses months from 0; subtract 1 here just so we
    // don't have to do it again during the validity test below
    m -= 1;

    // javascript takes new Date(0..99,m,d) to mean 1900-1999, so
    // to support years 0-99 we need to use setFullYear explicitly
    // Note that 2000 is a leap year.
    var date = new Date(Date.UTC(2000, m, d, H, M));
    date.setUTCFullYear(y);

    if(date.getUTCMonth() !== m) return BADNUM;
    if(date.getUTCDate() !== d) return BADNUM;

    return date.getTime() + S * ONESEC;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if(date.getUTCMonth() !== m) return BADNUM;
    if(date.getUTCDate() !== d) return BADNUM;

    return date.getTime() + S * ONESEC;
};

MIN_MS = exports.MIN_MS = exports.<span class="apidocCodeKeywordSpan">dateTime2ms</span>('-9999');
MAX_MS = exports.MAX_MS = exports.dateTime2ms('9999-12-31 23:59:59.9999');

// is string s a date? (see above)
exports.isDateTime = function(s, calendar) {
    return (exports.dateTime2ms(s, calendar) !== BADNUM);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.dates.dfltRange" id="apidoc.element.plotly.js.dates.dfltRange">
        function <span class="apidocSignatureSpan">plotly.js.dates.</span>dfltRange
        <span class="apidocSignatureSpan">(calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dfltRange = function (calendar) {
    if(isWorldCalendar(calendar)) {
        return Registry.getComponentMethod('calendars', 'DFLTRANGE')[calendar];
    }
    else {
        return ['2000-01-01', '2001-01-01'];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     */
    ax.cleanRange = function(rangeAttr) {
if(!rangeAttr) rangeAttr = 'range';
var range = Lib.nestedProperty(ax, rangeAttr).get(),
    axLetter = (ax._id || 'x').charAt(0),
    i, dflt;

if(ax.type === 'date') dflt = Lib.<span class="apidocCodeKeywordSpan">dfltRange</span>(ax.calendar);
else if(axLetter === 'y') dflt = constants.DFLTRANGEY;
else dflt = constants.DFLTRANGEX;

// make sure we don't later mutate the defaults
dflt = dflt.slice();

if(!range || range.length !== 2) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.dates.findExactDates" id="apidoc.element.plotly.js.dates.findExactDates">
        function <span class="apidocSignatureSpan">plotly.js.dates.</span>findExactDates
        <span class="apidocSignatureSpan">(data, calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findExactDates = function (data, calendar) {
    var exactYears = 0,
        exactMonths = 0,
        exactDays = 0,
        blankCount = 0,
        d,
        di;

    var calInstance = (
        isWorldCalendar(calendar) &amp;&amp;
        Registry.getComponentMethod('calendars', 'getCal')(calendar)
    );

    for(var i = 0; i &lt; data.length; i++) {
        di = data[i];

        // not date data at all
        if(!isNumeric(di)) {
            blankCount ++;
            continue;
        }

        // not an exact date
        if(di % ONEDAY) continue;

        if(calInstance) {
            try {
                d = calInstance.fromJD(di / ONEDAY + EPOCHJD);
                if(d.day() === 1) {
                    if(d.month() === 1) exactYears++;
                    else exactMonths++;
                }
                else exactDays++;
            }
            catch(e) {
                // invalid date in this calendar - ignore it here.
            }
        }
        else {
            d = new Date(di);
            if(d.getUTCDate() === 1) {
                if(d.getUTCMonth() === 0) exactYears++;
                else exactMonths++;
            }
            else exactDays++;
        }
    }
    exactMonths += exactYears;
    exactDays += exactMonths;

    var dataCount = data.length - blankCount;

    return {
        exactYears: exactYears / dataCount,
        exactMonths: exactMonths / dataCount,
        exactDays: exactDays / dataCount
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
}
return binStart;
}


function autoShiftMonthBins(binStart, data, dtick, dataMin, calendar) {
var stats = Lib.<span class="apidocCodeKeywordSpan">findExactDates</span>(data, calendar);
// number of data points that needs to be an exact value
// to shift that increment to (near) the bin center
var threshold = 0.8;

if(stats.exactDays &gt; threshold) {
    var numMonths = Number(dtick.substr(1));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.dates.formatDate" id="apidoc.element.plotly.js.dates.formatDate">
        function <span class="apidocSignatureSpan">plotly.js.dates.</span>formatDate
        <span class="apidocSignatureSpan">(x, fmt, tr, calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatDate = function (x, fmt, tr, calendar) {
    var headStr,
        dateStr;

    calendar = isWorldCalendar(calendar) &amp;&amp; calendar;

    if(fmt) return modDateFormat(fmt, x, calendar);

    if(calendar) {
        try {
            var dateJD = Math.floor((x + 0.05) / ONEDAY) + EPOCHJD,
                cDate = Registry.getComponentMethod('calendars', 'getCal')(calendar)
                    .fromJD(dateJD);

            if(tr === 'y') dateStr = yearFormatWorld(cDate);
            else if(tr === 'm') dateStr = monthFormatWorld(cDate);
            else if(tr === 'd') {
                headStr = yearFormatWorld(cDate);
                dateStr = dayFormatWorld(cDate);
            }
            else {
                headStr = yearMonthDayFormatWorld(cDate);
                dateStr = formatTime(x, tr);
            }
        }
        catch(e) { return 'Invalid'; }
    }
    else {
        var d = new Date(Math.floor(x + 0.05));

        if(tr === 'y') dateStr = yearFormat(d);
        else if(tr === 'm') dateStr = monthFormat(d);
        else if(tr === 'd') {
            headStr = yearFormat(d);
            dateStr = dayFormat(d);
        }
        else {
            headStr = yearMonthDayFormat(d);
            dateStr = formatTime(x, tr);
        }
    }

    return dateStr + (headStr ? '\n' + headStr : '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
dateStr, h, m, s, msec10, d;

    if(isWorldCalendar(calendar)) {
var dateJD = Math.floor(msRounded / ONEDAY) + EPOCHJD,
    timeMs = Math.floor(mod(ms, ONEDAY));
try {
    dateStr = Registry.getComponentMethod('calendars', 'getCal')(calendar)
        .fromJD(dateJD).<span class="apidocCodeKeywordSpan">formatDate</span>('yyyy-mm-dd');
}
catch(e) {
    // invalid date in this calendar - fall back to Gyyyy-mm-dd
    dateStr = utcFormat('G%Y-%m-%d')(new Date(msRounded));
}

// yyyy does NOT guarantee 4-digit years. YYYY mostly does, but does
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.dates.incrementMonth" id="apidoc.element.plotly.js.dates.incrementMonth">
        function <span class="apidocSignatureSpan">plotly.js.dates.</span>incrementMonth
        <span class="apidocSignatureSpan">(ms, dMonth, calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">incrementMonth = function (ms, dMonth, calendar) {
    calendar = isWorldCalendar(calendar) &amp;&amp; calendar;

    // pull time out and operate on pure dates, then add time back at the end
    // this gives maximum precision - not that we *normally* care if we're
    // incrementing by month, but better to be safe!
    var timeMs = mod(ms, ONEDAY);
    ms = Math.round(ms - timeMs);

    if(calendar) {
        try {
            var dateJD = Math.round(ms / ONEDAY) + EPOCHJD,
                calInstance = Registry.getComponentMethod('calendars', 'getCal')(calendar),
                cDate = calInstance.fromJD(dateJD);

            if(dMonth % 12) calInstance.add(cDate, dMonth, 'm');
            else calInstance.add(cDate, dMonth / 12, 'y');

            return (cDate.toJD() - EPOCHJD) * ONEDAY + timeMs;
        }
        catch(e) {
            logError('invalid ms ' + ms + ' in calendar ' + calendar);
            // then keep going in gregorian even though the result will be 'Invalid'
        }
    }

    var y = new Date(ms + THREEDAYS);
    return y.setUTCMonth(y.getUTCMonth() + dMonth) + timeMs - THREEDAYS;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(isNumeric(dtick)) return x + axSign * dtick;

// everything else is a string, one character plus a number
var tType = dtick.charAt(0),
    dtSigned = axSign * Number(dtick.substr(1));

// Dates: months (or years - see Lib.incrementMonth)
if(tType === 'M') return Lib.<span class="apidocCodeKeywordSpan">incrementMonth</span>(x, dtSigned, calendar);

// Log scales: Linear, Digits
else if(tType === 'L') return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10;

// log10 of 2,5,10, or all digits (logs just have to be
// close enough to round)
else if(tType === 'D') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.dates.isDateTime" id="apidoc.element.plotly.js.dates.isDateTime">
        function <span class="apidocSignatureSpan">plotly.js.dates.</span>isDateTime
        <span class="apidocSignatureSpan">(s, calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDateTime = function (s, calendar) {
    return (exports.dateTime2ms(s, calendar) !== BADNUM);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        // NOTE: if someone puts in a year as a number rather than a string,
        // this will mistakenly convert it thinking it's milliseconds from 1970
        // that is: '2012' -&gt; Jan. 1, 2012, but 2012 -&gt; 2012 epoch milliseconds
        v = exports.ms2DateTimeLocal(+v);
        if(!v &amp;&amp; dflt !== undefined) return dflt;
    }
    else if(!exports.<span class="apidocCodeKeywordSpan">isDateTime</span>(v, calendar)) {
        logError('unrecognized date', v);
        return dflt;
    }
    return v;
};

/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.dates.isJSDate" id="apidoc.element.plotly.js.dates.isJSDate">
        function <span class="apidocSignatureSpan">plotly.js.dates.</span>isJSDate
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isJSDate = function (v) {
    return typeof v === 'object' &amp;&amp; v !== null &amp;&amp; typeof v.getTime === 'function';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * make now will cover all possibilities. mostly this will all be taken
 * care of in initial parsing, should only be an issue for hand-entered data
 * currently (2016) this range is:
 *   1946-2045
 */
exports.dateTime2ms = function(s, calendar) {
// first check if s is a date object
if(exports.<span class="apidocCodeKeywordSpan">isJSDate</span>(s)) {
    // Convert to the UTC milliseconds that give the same
    // hours as this date has in the local timezone
    s = Number(s) - s.getTimezoneOffset() * ONEMIN;
    if(s &gt;= MIN_MS &amp;&amp; s &lt;= MAX_MS) return s;
    return BADNUM;
}
// otherwise only accept strings and numbers
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.dates.ms2DateTime" id="apidoc.element.plotly.js.dates.ms2DateTime">
        function <span class="apidocSignatureSpan">plotly.js.dates.</span>ms2DateTime
        <span class="apidocSignatureSpan">(ms, r, calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ms2DateTime = function (ms, r, calendar) {
    if(typeof ms !== 'number' || !(ms &gt;= MIN_MS &amp;&amp; ms &lt;= MAX_MS)) return BADNUM;

    if(!r) r = 0;

    var msecTenths = Math.floor(mod(ms + 0.05, 1) * 10),
        msRounded = Math.round(ms - msecTenths / 10),
        dateStr, h, m, s, msec10, d;

    if(isWorldCalendar(calendar)) {
        var dateJD = Math.floor(msRounded / ONEDAY) + EPOCHJD,
            timeMs = Math.floor(mod(ms, ONEDAY));
        try {
            dateStr = Registry.getComponentMethod('calendars', 'getCal')(calendar)
                .fromJD(dateJD).formatDate('yyyy-mm-dd');
        }
        catch(e) {
            // invalid date in this calendar - fall back to Gyyyy-mm-dd
            dateStr = utcFormat('G%Y-%m-%d')(new Date(msRounded));
        }

        // yyyy does NOT guarantee 4-digit years. YYYY mostly does, but does
        // other things for a few calendars, so we can't trust it. Just pad
        // it manually (after the '-' if there is one)
        if(dateStr.charAt(0) === '-') {
            while(dateStr.length &lt; 11) dateStr = '-0' + dateStr.substr(1);
        }
        else {
            while(dateStr.length &lt; 10) dateStr = '0' + dateStr;
        }

        // TODO: if this is faster, we could use this block for extracting
        // the time components of regular gregorian too
        h = (r &lt; NINETYDAYS) ? Math.floor(timeMs / ONEHOUR) : 0;
        m = (r &lt; NINETYDAYS) ? Math.floor((timeMs % ONEHOUR) / ONEMIN) : 0;
        s = (r &lt; THREEHOURS) ? Math.floor((timeMs % ONEMIN) / ONESEC) : 0;
        msec10 = (r &lt; FIVEMIN) ? (timeMs % ONESEC) * 10 + msecTenths : 0;
    }
    else {
        d = new Date(msRounded);

        dateStr = utcFormat('%Y-%m-%d')(d);

        // &lt;90 days: add hours and minutes - never *only* add hours
        h = (r &lt; NINETYDAYS) ? d.getUTCHours() : 0;
        m = (r &lt; NINETYDAYS) ? d.getUTCMinutes() : 0;
        // &lt;3 hours: add seconds
        s = (r &lt; THREEHOURS) ? d.getUTCSeconds() : 0;
        // &lt;5 minutes: add ms (plus one extra digit, this is msec*10)
        msec10 = (r &lt; FIVEMIN) ? d.getUTCMilliseconds() * 10 + msecTenths : 0;
    }

    return includeTime(dateStr, h, m, s, msec10);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.dates.ms2DateTimeLocal" id="apidoc.element.plotly.js.dates.ms2DateTimeLocal">
        function <span class="apidocSignatureSpan">plotly.js.dates.</span>ms2DateTimeLocal
        <span class="apidocSignatureSpan">(ms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ms2DateTimeLocal = function (ms) {
    if(!(ms &gt;= MIN_MS + ONEDAY &amp;&amp; ms &lt;= MAX_MS - ONEDAY)) return BADNUM;

    var msecTenths = Math.floor(mod(ms + 0.05, 1) * 10),
        d = new Date(Math.round(ms - msecTenths / 10)),
        dateStr = d3.time.format('%Y-%m-%d')(d),
        h = d.getHours(),
        m = d.getMinutes(),
        s = d.getSeconds(),
        msec10 = d.getUTCMilliseconds() * 10 + msecTenths;

    return includeTime(dateStr, h, m, s, msec10);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        logError('JS Dates and milliseconds are incompatible with world calendars', v);
        return dflt;
    }

    // NOTE: if someone puts in a year as a number rather than a string,
    // this will mistakenly convert it thinking it's milliseconds from 1970
    // that is: '2012' -&gt; Jan. 1, 2012, but 2012 -&gt; 2012 epoch milliseconds
    v = exports.<span class="apidocCodeKeywordSpan">ms2DateTimeLocal</span>(+v);
    if(!v &amp;&amp; dflt !== undefined) return dflt;
}
else if(!exports.isDateTime(v, calendar)) {
    logError('unrecognized date', v);
    return dflt;
}
return v;
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.draw" id="apidoc.module.plotly.js.draw">module plotly.js.draw</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.draw.draw" id="apidoc.element.plotly.js.draw.draw">
        function <span class="apidocSignatureSpan">plotly.js.</span>draw
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function draw(gd) {
    var fullLayout = gd._fullLayout;

    fullLayout._infolayer.selectAll('.annotation').remove();

    for(var i = 0; i &lt; fullLayout.annotations.length; i++) {
        if(fullLayout.annotations[i].visible) {
            drawOne(gd, i);
        }
    }

    return Plots.previousPromises(gd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

return gd._promises.length &amp;&amp; Promise.all(gd._promises);
};

exports.drawMainTitle = function(gd) {
var fullLayout = gd._fullLayout;

Titles.<span class="apidocCodeKeywordSpan">draw</span>(gd, 'gtitle', {
    propContainer: fullLayout,
    propName: 'title',
    dfltName: 'Plot',
    attributes: {
        x: fullLayout.width / 2,
        y: fullLayout._size.t / 2,
        'text-anchor': 'middle'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.draw.drawOne" id="apidoc.element.plotly.js.draw.drawOne">
        function <span class="apidocSignatureSpan">plotly.js.draw.</span>drawOne
        <span class="apidocSignatureSpan">(gd, index)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function drawOne(gd, index) {
    var layout = gd.layout,
        fullLayout = gd._fullLayout,
        gs = gd._fullLayout._size;

    // remove the existing annotation if there is one
    fullLayout._infolayer.selectAll('.annotation[data-index="' + index + '"]').remove();

    // remember a few things about what was already there,
    var optionsIn = (layout.annotations || [])[index],
        options = fullLayout.annotations[index];

    var annClipID = 'clip' + fullLayout._uid + '_ann' + index;

    // this annotation is gone - quit now after deleting it
    // TODO: use d3 idioms instead of deleting and redrawing every time
    if(!optionsIn || options.visible === false) {
        d3.selectAll('#' + annClipID).remove();
        return;
    }

    var xa = Axes.getFromId(gd, options.xref),
        ya = Axes.getFromId(gd, options.yref),

        // calculated pixel positions
        // x &amp; y each will get text, head, and tail as appropriate
        annPosPx = {x: {}, y: {}},
        textangle = +options.textangle || 0;

    // create the components
    // made a single group to contain all, so opacity can work right
    // with border/arrow together this could handle a whole bunch of
    // cleanup at this point, but works for now
    var annGroup = fullLayout._infolayer.append('g')
        .classed('annotation', true)
        .attr('data-index', String(index))
        .style('opacity', options.opacity);

    // another group for text+background so that they can rotate together
    var annTextGroup = annGroup.append('g')
        .classed('annotation-text-g', true)
        .attr('data-index', String(index));

    var annTextGroupInner = annTextGroup.append('g')
        .style('pointer-events', options.captureevents ? 'all' : null)
        .call(setCursor, 'default')
        .on('click', function() {
            gd._dragging = false;
            gd.emit('plotly_clickannotation', {
                index: index,
                annotation: optionsIn,
                fullAnnotation: options
            });
        });

    if(options.hovertext) {
        annTextGroupInner
        .on('mouseover', function() {
            var hoverOptions = options.hoverlabel;
            var hoverFont = hoverOptions.font;
            var bBox = this.getBoundingClientRect();
            var bBoxRef = gd.getBoundingClientRect();

            Fx.loneHover({
                x0: bBox.left - bBoxRef.left,
                x1: bBox.right - bBoxRef.left,
                y: (bBox.top + bBox.bottom) / 2 - bBoxRef.top,
                text: options.hovertext,
                color: hoverOptions.bgcolor,
                borderColor: hoverOptions.bordercolor,
                fontFamily: hoverFont.family,
                fontSize: hoverFont.size,
                fontColor: hoverFont.color
            }, {
                container: fullLayout._hoverlayer.node(),
                outerContainer: fullLayout._paper.node()
            });
        })
        .on('mouseout', function() {
            Fx.loneUnhover(fullLayout._hoverlayer.node());
        });
    }

    var borderwidth = options.borderwidth,
        borderpad = options.borderpad,
        borderfull = borderwidth + borderpad;

    var annTextBG = annTextGroupInner.append('rect')
        .attr('class', 'bg')
        .style('stroke-width', borderwidth + 'px')
        .call(Color.stroke, options.bordercolor)
        .call(Color.fill, options.bgcolor);

    var isSizeConstrained = options.width || options.height;

    var annTextClip = fullLayout._defs.select('.clips')
        .selectAll('#' + annClipID)
        .data(isSizeConstrained ? [0] : []);

    annTextClip.enter().append('clipPath')
        .classed('annclip', true)
        .attr('id', annClipID)
      .append('rect');
    annTextClip.exit().remove();

    var font = options.font;

    var annText = annTextGroupInner.append('text')
        .classed('annotation', true)
        .attr('data-unformatted', options.text)
        .text(options.text);

    function textLayout(s) {
        s.call(Drawing.font, font)
        .attr({
            'text-anc ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.events" id="apidoc.module.plotly.js.events">module plotly.js.events</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.events.init" id="apidoc.element.plotly.js.events.init">
        function <span class="apidocSignatureSpan">plotly.js.events.</span>init
        <span class="apidocSignatureSpan">(plotObj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (plotObj) {

<span class="apidocCodeCommentSpan">    /*
     * If we have already instantiated an emitter for this plot
     * return early.
     */
</span>    if(plotObj._ev instanceof EventEmitter) return plotObj;

    var ev = new EventEmitter();
    var internalEv = new EventEmitter();

    /*
     * Assign to plot._ev while we still live in a land
     * where plot is a DOM element with stuff attached to it.
     * In the future we can make plot the event emitter itself.
     */
    plotObj._ev = ev;

    /*
     * Create a second event handler that will manage events *internally*.
     * This allows parts of plotly to respond to thing like relayout without
     * having to use the user-facing event handler. They cannot peacefully
     * coexist on the same handler because a user invoking
     * plotObj.removeAllListeners() would detach internal events, breaking
     * plotly.
     */
    plotObj._internalEv = internalEv;

    /*
     * Assign bound methods from the ev to the plot object. These methods
     * will reference the 'this' of plot._ev even though they are methods
     * of plot. This will keep the event machinery away from the plot object
     * which currently is often a DOM element but presents an API that will
     * continue to function when plot becomes an emitter. Not all EventEmitter
     * methods have been bound to `plot` as some do not currently add value to
     * the Plotly event API.
     */
    plotObj.on = ev.on.bind(ev);
    plotObj.once = ev.once.bind(ev);
    plotObj.removeListener = ev.removeListener.bind(ev);
    plotObj.removeAllListeners = ev.removeAllListeners.bind(ev);

    /*
     * Create funtions for managing internal events. These are *only* triggered
     * by the mirroring of external events via the emit function.
     */
    plotObj._internalOn = internalEv.on.bind(internalEv);
    plotObj._internalOnce = internalEv.once.bind(internalEv);
    plotObj._removeInternalListener = internalEv.removeListener.bind(internalEv);
    plotObj._removeAllInternalListeners = internalEv.removeAllListeners.bind(internalEv);

    /*
     * We must wrap emit to continue to support JQuery events. The idea
     * is to check to see if the user is using JQuery events, if they are
     * we emit JQuery events to trigger user handlers as well as the EventEmitter
     * events.
     */
    plotObj.emit = function(event, data) {
        if(typeof jQuery !== 'undefined') {
            jQuery(plotObj).trigger(event, data);
        }

        ev.emit(event, data);
        internalEv.emit(event, data);
    };

    return plotObj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Plotly.plot = function(gd, data, layout, config) {
var frames;

gd = helpers.getGraphDiv(gd);

// Events.init is idempotent and bails early if gd has already been init'd
Events.<span class="apidocCodeKeywordSpan">init</span>(gd);

if(Lib.isPlainObject(data)) {
    var obj = data;
    data = obj.data;
    layout = obj.layout;
    config = obj.config;
    frames = obj.frames;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.events.purge" id="apidoc.element.plotly.js.events.purge">
        function <span class="apidocSignatureSpan">plotly.js.events.</span>purge
        <span class="apidocSignatureSpan">(plotObj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">purge = function (plotObj) {
    delete plotObj._ev;
    delete plotObj.on;
    delete plotObj.once;
    delete plotObj.removeListener;
    delete plotObj.removeAllListeners;
    delete plotObj.emit;

    delete plotObj._ev;
    delete plotObj._internalEv;
    delete plotObj._internalOn;
    delete plotObj._internalOnce;
    delete plotObj._removeInternalListener;
    delete plotObj._removeAllInternalListeners;

    return plotObj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
Plotly.newPlot = function(gd, data, layout, config) {
   gd = helpers.getGraphDiv(gd);

   // remove gl contexts
   Plots.cleanPlot([], {}, gd._fullData || {}, gd._fullLayout || {});

   Plots.<span class="apidocCodeKeywordSpan">purge</span>(gd);
   return Plotly.plot(gd, data, layout, config);
};

/**
* Wrap negative indicies to their positive counterparts.
*
* @param {Number[]} indices An array of indices
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.events.triggerHandler" id="apidoc.element.plotly.js.events.triggerHandler">
        function <span class="apidocSignatureSpan">plotly.js.events.</span>triggerHandler
        <span class="apidocSignatureSpan">(plotObj, event, data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">triggerHandler = function (plotObj, event, data) {
    var jQueryHandlerValue;
    var nodeEventHandlerValue;
<span class="apidocCodeCommentSpan">    /*
     * If Jquery exists run all its handlers for this event and
     * collect the return value of the LAST handler function
     */
</span>    if(typeof jQuery !== 'undefined') {
        jQueryHandlerValue = jQuery(plotObj).triggerHandler(event, data);
    }

    /*
     * Now run all the node style event handlers
     */
    var ev = plotObj._ev;
    if(!ev) return jQueryHandlerValue;

    var handlers = ev._events[event];
    if(!handlers) return jQueryHandlerValue;

    /*
     * handlers can be function or an array of functions
     */
    if(typeof handlers === 'function') handlers = [handlers];
    var lastHandler = handlers.pop();

    /*
     * Call all the handlers except the last one.
     */
    for(var i = 0; i &lt; handlers.length; i++) {
        handlers[i](data);
    }

    /*
     * Now call the final handler and collect its value
     */
    nodeEventHandlerValue = lastHandler(data);

    /*
     * Return either the jquery handler value if it exists or the
     * nodeEventHandler value. Jquery event value superceeds nodejs
     * events for backwards compatability reasons.
     */
    return jQueryHandlerValue !== undefined ? jQueryHandlerValue :
        nodeEventHandlerValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var jQueryHandlerValue;
var nodeEventHandlerValue;
/*
 * If Jquery exists run all its handlers for this event and
 * collect the return value of the LAST handler function
 */
if(typeof jQuery !== 'undefined') {
    jQueryHandlerValue = jQuery(plotObj).<span class="apidocCodeKeywordSpan">triggerHandler</span>(event, data);
}

/*
 * Now run all the node style event handlers
 */
var ev = plotObj._ev;
if(!ev) return jQueryHandlerValue;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.extend" id="apidoc.module.plotly.js.extend">module plotly.js.extend</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.extend.extendDeep" id="apidoc.element.plotly.js.extend.extendDeep">
        function <span class="apidocSignatureSpan">plotly.js.extend.</span>extendDeep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendDeep = function () {
    return _extend(arguments, true, false, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    for(var i = 0; i &lt; args.length; i++) {
        arg = args[i];

        if(arg === gd) copy[i] = arg;
        else if(typeof arg === 'object') {
            copy[i] = Array.isArray(arg) ?
                Lib.<span class="apidocCodeKeywordSpan">extendDeep</span>([], arg) :
                Lib.extendDeepAll({}, arg);
        }
        else copy[i] = arg;
    }

    return copy;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.extend.extendDeepAll" id="apidoc.element.plotly.js.extend.extendDeepAll">
        function <span class="apidocSignatureSpan">plotly.js.extend.</span>extendDeepAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendDeepAll = function () {
    return _extend(arguments, true, true, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for(var i = 0; i &lt; args.length; i++) {
        arg = args[i];

        if(arg === gd) copy[i] = arg;
        else if(typeof arg === 'object') {
            copy[i] = Array.isArray(arg) ?
                Lib.extendDeep([], arg) :
                Lib.<span class="apidocCodeKeywordSpan">extendDeepAll</span>({}, arg);
        }
        else copy[i] = arg;
    }

    return copy;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.extend.extendDeepNoArrays" id="apidoc.element.plotly.js.extend.extendDeepNoArrays">
        function <span class="apidocSignatureSpan">plotly.js.extend.</span>extendDeepNoArrays
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendDeepNoArrays = function () {
    return _extend(arguments, true, false, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if(data.hasOwnProperty(key)) {
                if((match = key.match(dottedPropertyRegex))) {
datum = data[key];
prop = match[1];

delete data[key];

data[prop] = lib.<span class="apidocCodeKeywordSpan">extendDeepNoArrays</span>(data[prop] || {}, lib.objectFromPath(key, lib.expandObjectPaths
(datum))[prop]);
                } else if((match = key.match(indexedPropertyRegex))) {
datum = data[key];

prop = match[1];
idx = parseInt(match[2]);

delete data[key];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.extend.extendFlat" id="apidoc.element.plotly.js.extend.extendFlat">
        function <span class="apidocSignatureSpan">plotly.js.extend.</span>extendFlat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendFlat = function () {
    return _extend(arguments, false, false, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function opaqueSetBackground(gd, bgColor) {
gd._fullLayout._paperdiv.style('background', 'white');
Plotly.defaultConfig.setBackground(gd, bgColor);
}

function setPlotContext(gd, config) {
if(!gd._context) gd._context = Lib.<span class="apidocCodeKeywordSpan">extendFlat</span>({}, Plotly.defaultConfig);
var context = gd._context;

if(config) {
    Object.keys(config).forEach(function(key) {
        if(key in context) {
            if(key === 'setBackground' &amp;&amp; config[key] === 'opaque') {
                context[key] = opaqueSetBackground;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.geo" id="apidoc.module.plotly.js.geo">module plotly.js.geo</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.geo.geo" id="apidoc.element.plotly.js.geo.geo">
        function <span class="apidocSignatureSpan">plotly.js.</span>geo
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Geo(options) {
    this.id = options.id;
    this.graphDiv = options.graphDiv;
    this.container = options.container;
    this.topojsonURL = options.topojsonURL;

    this.topojsonName = null;
    this.topojson = null;

    this.projectionType = null;
    this.projection = null;

    this.clipAngle = null;
    this.setScale = null;
    this.path = null;

    this.zoom = null;
    this.zoomReset = null;

    this.makeFramework();

    this.traceHash = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.geo.prototype" id="apidoc.module.plotly.js.geo.prototype">module plotly.js.geo.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.geo.prototype.adjustLayout" id="apidoc.element.plotly.js.geo.prototype.adjustLayout">
        function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>adjustLayout
        <span class="apidocSignatureSpan">(geoLayout, graphSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">adjustLayout = function (geoLayout, graphSize) {
    var domain = geoLayout.domain;

    var left = graphSize.l + graphSize.w * domain.x[0] + geoLayout._marginX,
        top = graphSize.t + graphSize.h * (1 - domain.y[1]) + geoLayout._marginY;

    Drawing.setTranslate(this.framework, left, top);

    var dimsAttrs = {
        x: 0,
        y: 0,
        width: geoLayout._width,
        height: geoLayout._height
    };

    this.clipDef.select('rect')
        .attr(dimsAttrs);

    this.framework.select('.bglayer').select('rect')
        .attr(dimsAttrs)
        .call(Color.fill, geoLayout.bgcolor);

    this.xaxis._offset = left;
    this.xaxis._length = geoLayout._width;

    this.yaxis._offset = top;
    this.yaxis._length = geoLayout._height;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// TODO don't reset projection on all graph edits
_this.projection = null;

_this.setScale = createGeoScale(geoLayout, graphSize);
_this.makeProjection(geoLayout);
_this.makePath();
_this.<span class="apidocCodeKeywordSpan">adjustLayout</span>(geoLayout, graphSize);

_this.zoom = createGeoZoom(_this, geoLayout);
_this.zoomReset = createGeoZoomReset(_this, geoLayout);
_this.mockAxis = createMockAxis(fullLayout);

_this.framework
    .call(_this.zoom)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.geo.prototype.drawGraticule" id="apidoc.element.plotly.js.geo.prototype.drawGraticule">
        function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>drawGraticule
        <span class="apidocSignatureSpan">(selection, axisName, geoLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drawGraticule = function (selection, axisName, geoLayout) {
    var axisLayout = geoLayout[axisName];

    if(axisLayout.showgrid !== true) return;

    var scopeDefaults = constants.scopeDefaults[geoLayout.scope],
        lonaxisRange = scopeDefaults.lonaxisRange,
        lataxisRange = scopeDefaults.lataxisRange,
        step = axisName === 'lonaxis' ?
            [axisLayout.dtick] :
            [0, axisLayout.dtick],
        graticule = makeGraticule(lonaxisRange, lataxisRange, step);

    selection.append('g')
        .datum(graticule)
        .attr('class', axisName + 'graticule')
            .append('path')
                .attr('class', 'graticulepath');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // N.B. html('') does not work in IE11
    gBaseLayer.selectAll('*').remove();

    for(var i = 0; i &lt; baseLayers.length; i++) {
        layerName = baseLayers[i];

        if(axesNames.indexOf(layerName) !== -1) {
            this.<span class="apidocCodeKeywordSpan">drawGraticule</span>(gBaseLayer, layerName, geoLayout);
        }
        else this.drawTopo(gBaseLayer, layerName, geoLayout);
    }

    this.styleLayout(geoLayout);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.geo.prototype.drawLayout" id="apidoc.element.plotly.js.geo.prototype.drawLayout">
        function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>drawLayout
        <span class="apidocSignatureSpan">(geoLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drawLayout = function (geoLayout) {
    var gBaseLayer = this.framework.select('g.baselayer'),
        baseLayers = constants.baseLayers,
        axesNames = constants.axesNames,
        layerName;

    // TODO move to more d3-idiomatic pattern (that's work on replot)
    // N.B. html('') does not work in IE11
    gBaseLayer.selectAll('*').remove();

    for(var i = 0; i &lt; baseLayers.length; i++) {
        layerName = baseLayers[i];

        if(axesNames.indexOf(layerName) !== -1) {
            this.drawGraticule(gBaseLayer, layerName, geoLayout);
        }
        else this.drawTopo(gBaseLayer, layerName, geoLayout);
    }

    this.styleLayout(geoLayout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    else _this.onceTopojsonIsLoaded(geoCalcData, geoLayout);

    // TODO handle topojson-is-loading case
    // to avoid making multiple request while streaming
};

proto.onceTopojsonIsLoaded = function(geoCalcData, geoLayout) {
    this.<span class="apidocCodeKeywordSpan">drawLayout</span>(geoLayout);

    Plots.generalUpdatePerTraceModule(this, geoCalcData, geoLayout);

    this.render();
};

proto.makeProjection = function(geoLayout) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.geo.prototype.drawTopo" id="apidoc.element.plotly.js.geo.prototype.drawTopo">
        function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>drawTopo
        <span class="apidocSignatureSpan">(selection, layerName, geoLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drawTopo = function (selection, layerName, geoLayout) {
    if(geoLayout['show' + layerName] !== true) return;

    var topojson = this.topojson,
        datum = layerName === 'frame' ?
            constants.sphereSVG :
            topojsonFeature(topojson, topojson.objects[layerName]);

    selection.append('g')
        .datum(datum)
        .attr('class', layerName)
          .append('path')
            .attr('class', 'basepath');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

for(var i = 0; i &lt; baseLayers.length; i++) {
    layerName = baseLayers[i];

    if(axesNames.indexOf(layerName) !== -1) {
        this.drawGraticule(gBaseLayer, layerName, geoLayout);
    }
    else this.<span class="apidocCodeKeywordSpan">drawTopo</span>(gBaseLayer, layerName, geoLayout);
}

this.styleLayout(geoLayout);
};

function styleFillLayer(selection, layerName, geoLayout) {
var layerAdj = constants.layerNameToAdjective[layerName];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.geo.prototype.isLonLatOverEdges" id="apidoc.element.plotly.js.geo.prototype.isLonLatOverEdges">
        function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>isLonLatOverEdges
        <span class="apidocSignatureSpan">(lonlat)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isLonLatOverEdges = function (lonlat) {
    var clipAngle = this.clipAngle;

    if(clipAngle === null) return false;

    var p = this.projection.rotate(),
        angle = d3.geo.distance(lonlat, [-p[0], -p[1]]),
        maxAngle = clipAngle * Math.PI / 180;

    return angle &gt; maxAngle;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if(!lonlatPx) return null;

    return 'translate(' + lonlatPx[0] + ',' + lonlatPx[1] + ')';
}

// hide paths over edges of clipped projections
function hideShowPoints(d) {
    return _this.<span class="apidocCodeKeywordSpan">isLonLatOverEdges</span>(d.lonlat) ? '0' : '1.0';
}

framework.selectAll('path.basepath').attr('d', path);
framework.selectAll('path.graticulepath').attr('d', path);

gChoropleth.selectAll('path.choroplethlocation').attr('d', path);
gChoropleth.selectAll('path.basepath').attr('d', path);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.geo.prototype.makeFramework" id="apidoc.element.plotly.js.geo.prototype.makeFramework">
        function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>makeFramework
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeFramework = function () {
    var fullLayout = this.graphDiv._fullLayout;
    var clipId = 'clip' + fullLayout._uid + this.id;

    var defGroup = fullLayout._defs.selectAll('g.clips')
        .data([0]);
    defGroup.enter().append('g')
        .classed('clips', true);

    var clipDef = this.clipDef = defGroup.selectAll('#' + clipId)
        .data([0]);

    clipDef.enter().append('clipPath').attr('id', clipId)
        .append('rect');

    var framework = this.framework = d3.select(this.container).append('g');

    framework
        .attr('class', 'geo ' + this.id)
        .style('pointer-events', 'all')
        .call(Drawing.setClipUrl, clipId);

    framework.append('g')
        .attr('class', 'bglayer')
        .append('rect');

    framework.append('g').attr('class', 'baselayer');
    framework.append('g').attr('class', 'choroplethlayer');
    framework.append('g').attr('class', 'baselayeroverchoropleth');
    framework.append('g').attr('class', 'scattergeolayer');

    // N.B. disable dblclick zoom default
    framework.on('dblclick.zoom', null);

    this.xaxis = { _id: 'x' };
    this.yaxis = { _id: 'y' };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.clipAngle = null;
    this.setScale = null;
    this.path = null;

    this.zoom = null;
    this.zoomReset = null;

    this.<span class="apidocCodeKeywordSpan">makeFramework</span>();

    this.traceHash = {};
}

module.exports = Geo;

var proto = Geo.prototype;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.geo.prototype.makePath" id="apidoc.element.plotly.js.geo.prototype.makePath">
        function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>makePath
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makePath = function () {
    this.path = d3.geo.path().projection(this.projection);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// N.B. 'geoLayout' is unambiguous, no need for 'user' geo layout here

// TODO don't reset projection on all graph edits
_this.projection = null;

_this.setScale = createGeoScale(geoLayout, graphSize);
_this.makeProjection(geoLayout);
_this.<span class="apidocCodeKeywordSpan">makePath</span>();
_this.adjustLayout(geoLayout, graphSize);

_this.zoom = createGeoZoom(_this, geoLayout);
_this.zoomReset = createGeoZoomReset(_this, geoLayout);
_this.mockAxis = createMockAxis(fullLayout);

_this.framework
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.geo.prototype.makeProjection" id="apidoc.element.plotly.js.geo.prototype.makeProjection">
        function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>makeProjection
        <span class="apidocSignatureSpan">(geoLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeProjection = function (geoLayout) {
    var projLayout = geoLayout.projection,
        projType = projLayout.type,
        isNew = this.projection === null || projType !== this.projectionType,
        projection;

    if(isNew) {
        this.projectionType = projType;
        projection = this.projection = d3.geo[constants.projNames[projType]]();
    }
    else projection = this.projection;

    projection
        .translate(projLayout._translate0)
        .precision(constants.precision);

    if(!geoLayout._isAlbersUsa) {
        projection
            .rotate(projLayout._rotate)
            .center(projLayout._center);
    }

    if(geoLayout._clipAngle) {
        this.clipAngle = geoLayout._clipAngle;  // needed in proto.render
        projection
            .clipAngle(geoLayout._clipAngle - constants.clipPad);
    }
    else this.clipAngle = null;  // for graph edits

    if(projLayout.parallels) {
        projection
            .parallels(projLayout.parallels);
    }

    if(isNew) this.setScale(projection);

    projection
        .translate(projLayout._translate)
        .scale(projLayout._scale);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// N.B. 'geoLayout' is unambiguous, no need for 'user' geo layout here

// TODO don't reset projection on all graph edits
_this.projection = null;

_this.setScale = createGeoScale(geoLayout, graphSize);
_this.<span class="apidocCodeKeywordSpan">makeProjection</span>(geoLayout);
_this.makePath();
_this.adjustLayout(geoLayout, graphSize);

_this.zoom = createGeoZoom(_this, geoLayout);
_this.zoomReset = createGeoZoomReset(_this, geoLayout);
_this.mockAxis = createMockAxis(fullLayout);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.geo.prototype.onceTopojsonIsLoaded" id="apidoc.element.plotly.js.geo.prototype.onceTopojsonIsLoaded">
        function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>onceTopojsonIsLoaded
        <span class="apidocSignatureSpan">(geoCalcData, geoLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onceTopojsonIsLoaded = function (geoCalcData, geoLayout) {
    this.drawLayout(geoLayout);

    Plots.generalUpdatePerTraceModule(this, geoCalcData, geoLayout);

    this.render();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    topojsonNameNew = topojsonUtils.getTopojsonName(geoLayout);

    if(_this.topojson === null || topojsonNameNew !== _this.topojsonName) {
_this.topojsonName = topojsonNameNew;

if(PlotlyGeoAssets.topojson[_this.topojsonName] !== undefined) {
    _this.topojson = PlotlyGeoAssets.topojson[_this.topojsonName];
    _this.<span class="apidocCodeKeywordSpan">onceTopojsonIsLoaded</span>(geoCalcData, geoLayout);
}
else {
    topojsonPath = topojsonUtils.getTopojsonPath(
        _this.topojsonURL,
        _this.topojsonName
    );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.geo.prototype.plot" id="apidoc.element.plotly.js.geo.prototype.plot">
        function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>plot
        <span class="apidocSignatureSpan">(geoCalcData, fullLayout, promises)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">plot = function (geoCalcData, fullLayout, promises) {
    var _this = this,
        geoLayout = fullLayout[_this.id],
        graphSize = fullLayout._size;

    var topojsonNameNew, topojsonPath;

    // N.B. 'geoLayout' is unambiguous, no need for 'user' geo layout here

    // TODO don't reset projection on all graph edits
    _this.projection = null;

    _this.setScale = createGeoScale(geoLayout, graphSize);
    _this.makeProjection(geoLayout);
    _this.makePath();
    _this.adjustLayout(geoLayout, graphSize);

    _this.zoom = createGeoZoom(_this, geoLayout);
    _this.zoomReset = createGeoZoomReset(_this, geoLayout);
    _this.mockAxis = createMockAxis(fullLayout);

    _this.framework
        .call(_this.zoom)
        .on('dblclick.zoom', _this.zoomReset);

    _this.framework.on('mousemove', function() {
        var mouse = d3.mouse(this),
            lonlat = _this.projection.invert(mouse);

        if(!lonlat || isNaN(lonlat[0]) || isNaN(lonlat[1])) return;

        var evt = d3.event;
        evt.xpx = mouse[0];
        evt.ypx = mouse[1];

        _this.xaxis.c2p = function() { return mouse[0]; };
        _this.xaxis.p2c = function() { return lonlat[0]; };
        _this.yaxis.c2p = function() { return mouse[1]; };
        _this.yaxis.p2c = function() { return lonlat[1]; };

        Fx.hover(_this.graphDiv, evt, _this.id);
    });

    _this.framework.on('mouseout', function() {
        Fx.loneUnhover(fullLayout._toppaper);
    });

    _this.framework.on('click', function() {
        Fx.click(_this.graphDiv, d3.event);
    });

    topojsonNameNew = topojsonUtils.getTopojsonName(geoLayout);

    if(_this.topojson === null || topojsonNameNew !== _this.topojsonName) {
        _this.topojsonName = topojsonNameNew;

        if(PlotlyGeoAssets.topojson[_this.topojsonName] !== undefined) {
            _this.topojson = PlotlyGeoAssets.topojson[_this.topojsonName];
            _this.onceTopojsonIsLoaded(geoCalcData, geoLayout);
        }
        else {
            topojsonPath = topojsonUtils.getTopojsonPath(
                _this.topojsonURL,
                _this.topojsonName
            );

            promises.push(new Promise(function(resolve, reject) {
                d3.json(topojsonPath, function(error, topojson) {
                    if(error) {
                        if(error.status === 404) {
                            reject(new Error([
                                'plotly.js could not find topojson file at',
                                topojsonPath, '.',
                                'Make sure the *topojsonURL* plot config option',
                                'is set properly.'
                            ].join(' ')));
                        }
                        else {
                            reject(new Error([
                                'unexpected error while fetching topojson file at',
                                topojsonPath
                            ].join(' ')));
                        }
                        return;
                    }

                    _this.topojson = topojson;
                    PlotlyGeoAssets.topojson[_this.topojsonName] = topojson;

                    _this.onceTopojsonIsLoaded(geoCalcData, geoLayout);
                    resolve();
                });
            }));
        }
    }
    else _this.onceTopojsonIsLoaded(geoCalcData, geoLayout);

    // TODO handle topojson-is-loading case
    // to avoid making multiple request while streaming
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        fullLayout._infolayer.selectAll('.cb' + uid).remove();
    }
}

// loop over the base plot modules present on graph
var basePlotModules = fullLayout._basePlotModules;
for(i = 0; i &lt; basePlotModules.length; i++) {
    basePlotModules[i].<span class="apidocCodeKeywordSpan">plot</span>(gd);
}

// keep reference to shape layers in subplots
var layerSubplot = fullLayout._paper.selectAll('.layer-subplot');
fullLayout._shapeSubplotLayers = layerSubplot.selectAll('.shapelayer');

// styling separate from drawing
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.geo.prototype.render" id="apidoc.element.plotly.js.geo.prototype.render">
        function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>render
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">render = function () {
    var _this = this,
        framework = _this.framework,
        gChoropleth = framework.select('g.choroplethlayer'),
        gScatterGeo = framework.select('g.scattergeolayer'),
        path = _this.path;

    function translatePoints(d) {
        var lonlatPx = _this.projection(d.lonlat);
        if(!lonlatPx) return null;

        return 'translate(' + lonlatPx[0] + ',' + lonlatPx[1] + ')';
    }

    // hide paths over edges of clipped projections
    function hideShowPoints(d) {
        return _this.isLonLatOverEdges(d.lonlat) ? '0' : '1.0';
    }

    framework.selectAll('path.basepath').attr('d', path);
    framework.selectAll('path.graticulepath').attr('d', path);

    gChoropleth.selectAll('path.choroplethlocation').attr('d', path);
    gChoropleth.selectAll('path.basepath').attr('d', path);

    gScatterGeo.selectAll('path.js-line').attr('d', path);

    if(_this.clipAngle !== null) {
        gScatterGeo.selectAll('path.point')
            .style('opacity', hideShowPoints)
            .attr('transform', translatePoints);
        gScatterGeo.selectAll('text')
            .style('opacity', hideShowPoints)
            .attr('transform', translatePoints);
    }
    else {
        gScatterGeo.selectAll('path.point')
            .attr('transform', translatePoints);
        gScatterGeo.selectAll('text')
            .attr('transform', translatePoints);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var geo = fullLayout[geoIds[i]]._subplot;

    if(attr === 'zoom') {
        var scale = geo.projection.scale();
        var newScale = (val === 'in') ? 2 * scale : 0.5 * scale;
        geo.projection.scale(newScale);
        geo.zoom.scale(newScale);
        geo.<span class="apidocCodeKeywordSpan">render</span>();
    }
    else if(attr === 'reset') geo.zoomReset();
}
}

modeBarButtons.hoverClosestGl2d = {
name: 'hoverClosestGl2d',
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.geo.prototype.styleLayer" id="apidoc.element.plotly.js.geo.prototype.styleLayer">
        function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>styleLayer
        <span class="apidocSignatureSpan">(selection, layerName, geoLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">styleLayer = function (selection, layerName, geoLayout) {
    var fillLayers = constants.fillLayers,
        lineLayers = constants.lineLayers;

    if(fillLayers.indexOf(layerName) !== -1) {
        styleFillLayer(selection, layerName, geoLayout);
    }
    else if(lineLayers.indexOf(layerName) !== -1) {
        styleLineLayer(selection, layerName, geoLayout);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

for(var i = 0; i &lt; baseLayers.length; i++) {
    layerName = baseLayers[i];

    if(axesNames.indexOf(layerName) !== -1) {
        styleGraticule(gBaseLayer, layerName, geoLayout);
    }
    else this.<span class="apidocCodeKeywordSpan">styleLayer</span>(gBaseLayer, layerName, geoLayout);
}
};

proto.isLonLatOverEdges = function(lonlat) {
var clipAngle = this.clipAngle;

if(clipAngle === null) return false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.geo.prototype.styleLayout" id="apidoc.element.plotly.js.geo.prototype.styleLayout">
        function <span class="apidocSignatureSpan">plotly.js.geo.prototype.</span>styleLayout
        <span class="apidocSignatureSpan">(geoLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">styleLayout = function (geoLayout) {
    var gBaseLayer = this.framework.select('g.baselayer'),
        baseLayers = constants.baseLayers,
        axesNames = constants.axesNames,
        layerName;

    for(var i = 0; i &lt; baseLayers.length; i++) {
        layerName = baseLayers[i];

        if(axesNames.indexOf(layerName) !== -1) {
            styleGraticule(gBaseLayer, layerName, geoLayout);
        }
        else this.styleLayer(gBaseLayer, layerName, geoLayout);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if(axesNames.indexOf(layerName) !== -1) {
        this.drawGraticule(gBaseLayer, layerName, geoLayout);
    }
    else this.drawTopo(gBaseLayer, layerName, geoLayout);
}

this.<span class="apidocCodeKeywordSpan">styleLayout</span>(geoLayout);
};

function styleFillLayer(selection, layerName, geoLayout) {
var layerAdj = constants.layerNameToAdjective[layerName];

selection.select('.' + layerName)
    .selectAll('path')
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.geo_location_utils" id="apidoc.module.plotly.js.geo_location_utils">module plotly.js.geo_location_utils</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.geo_location_utils.locationToFeature" id="apidoc.element.plotly.js.geo_location_utils.locationToFeature">
        function <span class="apidocSignatureSpan">plotly.js.geo_location_utils.</span>locationToFeature
        <span class="apidocSignatureSpan">(locationmode, location, features)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">locationToFeature = function (locationmode, location, features) {
    var locationId = getLocationId(locationmode, location);

    if(locationId) {
        for(var i = 0; i &lt; features.length; i++) {
            var feature = features[i];

            if(feature.id === locationId) return feature;
        }

        Lib.warn([
            'Location with id', locationId,
            'does not have a matching topojson feature at this resolution.'
        ].join(' '));
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.geojson_utils" id="apidoc.module.plotly.js.geojson_utils">module plotly.js.geojson_utils</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.geojson_utils.calcTraceToLineCoords" id="apidoc.element.plotly.js.geojson_utils.calcTraceToLineCoords">
        function <span class="apidocSignatureSpan">plotly.js.geojson_utils.</span>calcTraceToLineCoords
        <span class="apidocSignatureSpan">(calcTrace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">calcTraceToLineCoords = function (calcTrace) {
    var trace = calcTrace[0].trace;
    var connectgaps = trace.connectgaps;

    var coords = [];
    var lineString = [];

    for(var i = 0; i &lt; calcTrace.length; i++) {
        var calcPt = calcTrace[i];
        var lonlat = calcPt.lonlat;

        if(lonlat[0] !== BADNUM) {
            lineString.push(lonlat);
        } else if(!connectgaps &amp;&amp; lineString.length &gt; 0) {
            coords.push(lineString);
            lineString = [];
        }
    }

    if(lineString.length &gt; 0) {
        coords.push(lineString);
    }

    return coords;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.geojson_utils.makeBlank" id="apidoc.element.plotly.js.geojson_utils.makeBlank">
        function <span class="apidocSignatureSpan">plotly.js.geojson_utils.</span>makeBlank
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeBlank = function () {
    return {
        type: 'Point',
        coordinates: []
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.geojson_utils.makeLine" id="apidoc.element.plotly.js.geojson_utils.makeLine">
        function <span class="apidocSignatureSpan">plotly.js.geojson_utils.</span>makeLine
        <span class="apidocSignatureSpan">(coords, trace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeLine = function (coords, trace) {
    var out = {};

    if(coords.length === 1) {
        out = {
            type: 'LineString',
            coordinates: coords[0]
        };
    }
    else {
        out = {
            type: 'MultiLineString',
            coordinates: coords
        };
    }

    if(trace) out.trace = trace;

    return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.geojson_utils.makePolygon" id="apidoc.element.plotly.js.geojson_utils.makePolygon">
        function <span class="apidocSignatureSpan">plotly.js.geojson_utils.</span>makePolygon
        <span class="apidocSignatureSpan">(coords, trace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makePolygon = function (coords, trace) {
    var out = {};

    if(coords.length === 1) {
        out = {
            type: 'Polygon',
            coordinates: coords
        };
    }
    else {
        var _coords = new Array(coords.length);

        for(var i = 0; i &lt; coords.length; i++) {
            _coords[i] = [coords[i]];
        }

        out = {
            type: 'MultiPolygon',
            coordinates: _coords
        };
    }

    if(trace) out.trace = trace;

    return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.graph_interact" id="apidoc.module.plotly.js.graph_interact">module plotly.js.graph_interact</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.graph_interact.click" id="apidoc.element.plotly.js.graph_interact.click">
        function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>click
        <span class="apidocSignatureSpan">(gd, evt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">click = function (gd, evt) {
    var annotationsDone = Registry.getComponentMethod('annotations', 'onClick')(gd, gd._hoverdata);

    function emitClick() { gd.emit('plotly_click', {points: gd._hoverdata, event: evt}); }

    if(gd._hoverdata &amp;&amp; evt &amp;&amp; evt.target) {
        if(annotationsDone &amp;&amp; annotationsDone.then) {
            annotationsDone.then(emitClick);
        }
        else emitClick();

        // why do we get a double event without this???
        if(evt.stopImmediatePropagation) evt.stopImmediatePropagation();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    name = 'download';
}

if(canUseSaveLink) {
    saveLink.href = url;
    saveLink.download = name;
    document.body.appendChild(saveLink);
    saveLink.<span class="apidocCodeKeywordSpan">click</span>();
    document.body.removeChild(saveLink);
    resolve(name);
}

// IE 10+ (native saveAs)
if(typeof navigator !== 'undefined' &amp;&amp; navigator.msSaveBlob) {
    navigator.msSaveBlob(new Blob([url]), name);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.graph_interact.getClosest" id="apidoc.element.plotly.js.graph_interact.getClosest">
        function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>getClosest
        <span class="apidocSignatureSpan">(cd, distfn, pointData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getClosest = function (cd, distfn, pointData) {
    // do we already have a point number? (array mode only)
    if(pointData.index !== false) {
        if(pointData.index &gt;= 0 &amp;&amp; pointData.index &lt; cd.length) {
            pointData.distance = 0;
        }
        else pointData.index = false;
    }
    else {
        // apply the distance function to each data point
        // this is the longest loop... if this bogs down, we may need
        // to create pre-sorted data (by x or y), not sure how to
        // do this for 'closest'
        for(var i = 0; i &lt; cd.length; i++) {
            var newDistance = distfn(cd[i]);
            if(newDistance &lt;= pointData.distance) {
                pointData.index = i;
                pointData.distance = newDistance;
            }
        }
    }
    return pointData;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
maxPos = (hovermode === 'closest') ?
    thisBarMaxPos :
    function(di) {
        return Math.max(thisBarMaxPos(di), di.p + t.bargroupwidth / 2);
    };

var distfn = Fx.getDistanceFunction(hovermode, dx, dy);
Fx.<span class="apidocCodeKeywordSpan">getClosest</span>(cd, distfn, pointData);

// skip the rest (for this trace) if we didn't find a close point
if(pointData.index === false) return;

// the closest data point
var index = pointData.index,
    di = cd[index],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.graph_interact.getDistanceFunction" id="apidoc.element.plotly.js.graph_interact.getDistanceFunction">
        function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>getDistanceFunction
        <span class="apidocSignatureSpan">(mode, dx, dy, dxy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDistanceFunction = function (mode, dx, dy, dxy) {
    if(mode === 'closest') return dxy || quadrature(dx, dy);
    return mode === 'x' ? dx : dy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

maxPos = (hovermode === 'closest') ?
    thisBarMaxPos :
    function(di) {
        return Math.max(thisBarMaxPos(di), di.p + t.bargroupwidth / 2);
    };

var distfn = Fx.<span class="apidocCodeKeywordSpan">getDistanceFunction</span>(hovermode, dx, dy);
Fx.getClosest(cd, distfn, pointData);

// skip the rest (for this trace) if we didn't find a close point
if(pointData.index === false) return;

// the closest data point
var index = pointData.index,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.graph_interact.hover" id="apidoc.element.plotly.js.graph_interact.hover">
        function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>hover
        <span class="apidocSignatureSpan">(gd, evt, subplot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hover = function (gd, evt, subplot) {
    if(typeof gd === 'string') gd = document.getElementById(gd);
    if(gd._lastHoverTime === undefined) gd._lastHoverTime = 0;

    // If we have an update queued, discard it now
    if(gd._hoverTimer !== undefined) {
        clearTimeout(gd._hoverTimer);
        gd._hoverTimer = undefined;
    }
    // Is it more than 100ms since the last update?  If so, force
    // an update now (synchronously) and exit
    if(Date.now() &gt; gd._lastHoverTime + constants.HOVERMINTIME) {
        hover(gd, evt, subplot);
        gd._lastHoverTime = Date.now();
        return;
    }
    // Queue up the next hover for 100ms from now (if no further events)
    gd._hoverTimer = setTimeout(function() {
        hover(gd, evt, subplot);
        gd._lastHoverTime = Date.now();
        gd._hoverTimer = undefined;
    }, constants.HOVERMINTIME);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
xa._length, ya._length, 'ns', 'ew');

            maindrag.onmousemove = function(evt) {
// This is on `gd._fullLayout`, *not* fullLayout because the reference
// changes by the time this is called again.
gd._fullLayout._rehover = function() {
    if(gd._fullLayout._hoversubplot === subplot) {
        fx.<span class="apidocCodeKeywordSpan">hover</span>(gd, evt, subplot);
    }
};

fx.hover(gd, evt, subplot);

// Note that we have *not* used the cached fullLayout variable here
// since that may be outdated when this is called as a callback later on
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.graph_interact.inbox" id="apidoc.element.plotly.js.graph_interact.inbox">
        function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>inbox
        <span class="apidocSignatureSpan">(v0, v1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inbox = function (v0, v1) {
    if(v0 * v1 &lt; 0 || v0 === 0) {
        return constants.MAXDIST * (0.6 - 0.3 / Math.max(3, Math.abs(v0 - v1)));
    }
    return Infinity;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var t = cd[0].t;
var xa = pointData.xa;
var ya = pointData.ya;

var posVal, thisBarMinPos, thisBarMaxPos, minPos, maxPos, dx, dy;

var positionFn = function(di) {
    return Fx.<span class="apidocCodeKeywordSpan">inbox</span>(minPos(di) - posVal, maxPos(di) - posVal);
};

if(trace.orientation === 'h') {
    posVal = yval;
    thisBarMinPos = function(di) { return di.y - di.w / 2; };
    thisBarMaxPos = function(di) { return di.y + di.w / 2; };
    dx = function(di) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.graph_interact.init" id="apidoc.element.plotly.js.graph_interact.init">
        function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>init
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (gd) {
    var fullLayout = gd._fullLayout;

    if(!fullLayout._has('cartesian') || gd._context.staticPlot) return;

    var subplots = Object.keys(fullLayout._plots || {}).sort(function(a, b) {
        // sort overlays last, then by x axis number, then y axis number
        if((fullLayout._plots[a].mainplot &amp;&amp; true) ===
            (fullLayout._plots[b].mainplot &amp;&amp; true)) {
            var aParts = a.split('y'),
                bParts = b.split('y');
            return (aParts[0] === bParts[0]) ?
                (Number(aParts[1] || 1) - Number(bParts[1] || 1)) :
                (Number(aParts[0] || 1) - Number(bParts[0] || 1));
        }
        return fullLayout._plots[a].mainplot ? 1 : -1;
    });

    subplots.forEach(function(subplot) {
        var plotinfo = fullLayout._plots[subplot];

        if(!fullLayout._has('cartesian')) return;

        var xa = plotinfo.xaxis,
            ya = plotinfo.yaxis,

            // the y position of the main x axis line
            y0 = (xa._linepositions[subplot] || [])[3],

            // the x position of the main y axis line
            x0 = (ya._linepositions[subplot] || [])[3];

        var DRAGGERSIZE = constants.DRAGGERSIZE;
        if(isNumeric(y0) &amp;&amp; xa.side === 'top') y0 -= DRAGGERSIZE;
        if(isNumeric(x0) &amp;&amp; ya.side !== 'right') x0 -= DRAGGERSIZE;

        // main and corner draggers need not be repeated for
        // overlaid subplots - these draggers drag them all
        if(!plotinfo.mainplot) {
            // main dragger goes over the grids and data, so we use its
            // mousemove events for all data hover effects
            var maindrag = dragBox(gd, plotinfo, 0, 0,
                xa._length, ya._length, 'ns', 'ew');

            maindrag.onmousemove = function(evt) {
                // This is on `gd._fullLayout`, *not* fullLayout because the reference
                // changes by the time this is called again.
                gd._fullLayout._rehover = function() {
                    if(gd._fullLayout._hoversubplot === subplot) {
                        fx.hover(gd, evt, subplot);
                    }
                };

                fx.hover(gd, evt, subplot);

                // Note that we have *not* used the cached fullLayout variable here
                // since that may be outdated when this is called as a callback later on
                gd._fullLayout._lasthover = maindrag;
                gd._fullLayout._hoversubplot = subplot;
            };

<span class="apidocCodeCommentSpan">            /*
             * IMPORTANT:
             * We must check for the presence of the drag cover here.
             * If we don't, a 'mouseout' event is triggered on the
             * maindrag before each 'click' event, which has the effect
             * of clearing the hoverdata; thus, cancelling the click event.
             */
</span>            maindrag.onmouseout = function(evt) {
                if(gd._dragging) return;

                // When the mouse leaves this maindrag, unset the hovered subplot.
                // This may cause problems if it leaves the subplot directly *onto*
                // another subplot, but that's a tiny corner case at the moment.
                gd._fullLayout._hoversubplot = null;

                dragElement.unhover(gd, evt);
            };

            maindrag.onclick = function(evt) {
                fx.click(gd, evt);
            };

            // corner draggers
            if(gd._context.showAxisDragHandles) {
                dragBox(gd, plotinfo, -DRAGGERSIZE, -DRAGGERSIZE,
                    DRAGGERSIZE, DRAGGERSIZE, 'n', 'w');
                dragBox(gd, plotinfo, xa._length, -DRAGGERSIZE,
                    DRAGGERSIZE, DRAGGERSIZE, 'n', 'e');
                dragBox(gd, plotinfo, -DRAGGERSIZE, ya._length,
                    DRAGGERSIZE, DRAGGERSIZE, 's', 'w');
                dragBox(gd, plotinfo, xa._length, ya._length,
                    DRAGGERSIZE, DRAGGERSIZE, 's', 'e');
            }
        }
        if(gd._context.showAxisDragHandles) {
            // x axis draggers - if you have overlaid plots, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Plotly.plot = function(gd, data, layout, config) {
var frames;

gd = helpers.getGraphDiv(gd);

// Events.init is idempotent and bails early if gd has already been init'd
Events.<span class="apidocCodeKeywordSpan">init</span>(gd);

if(Lib.isPlainObject(data)) {
    var obj = data;
    data = obj.data;
    layout = obj.layout;
    config = obj.config;
    frames = obj.frames;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.graph_interact.isHoriz" id="apidoc.element.plotly.js.graph_interact.isHoriz">
        function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>isHoriz
        <span class="apidocSignatureSpan">(fullData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isHoriz = function (fullData) {
    var isHoriz = true;

    for(var i = 0; i &lt; fullData.length; i++) {
        var trace = fullData[i];

        if(trace.orientation !== 'h') {
            isHoriz = false;
            break;
        }
    }

    return isHoriz;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    coerce('dragmode');

    var hovermodeDflt;
    if(layoutOut._has('cartesian')) {
        // flag for 'horizontal' plots:
        // determines the state of the mode bar 'compare' hovermode button
        var isHoriz = layoutOut._isHoriz = fx.<span class="apidocCodeKeywordSpan">isHoriz</span>(fullData);
        hovermodeDflt = isHoriz ? 'y' : 'x';
    }
    else hovermodeDflt = 'closest';

    coerce('hovermode', hovermodeDflt);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.graph_interact.loneHover" id="apidoc.element.plotly.js.graph_interact.loneHover">
        function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>loneHover
        <span class="apidocSignatureSpan">(hoverItem, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loneHover = function (hoverItem, opts) {
    var pointData = {
        color: hoverItem.color || Color.defaultLine,
        x0: hoverItem.x0 || hoverItem.x || 0,
        x1: hoverItem.x1 || hoverItem.x || 0,
        y0: hoverItem.y0 || hoverItem.y || 0,
        y1: hoverItem.y1 || hoverItem.y || 0,
        xLabel: hoverItem.xLabel,
        yLabel: hoverItem.yLabel,
        zLabel: hoverItem.zLabel,
        text: hoverItem.text,
        name: hoverItem.name,
        idealAlign: hoverItem.idealAlign,

        // optional extra bits of styling
        borderColor: hoverItem.borderColor,
        fontFamily: hoverItem.fontFamily,
        fontSize: hoverItem.fontSize,
        fontColor: hoverItem.fontColor,

        // filler to make createHoverText happy
        trace: {
            index: 0,
            hoverinfo: ''
        },
        xa: {_offset: 0},
        ya: {_offset: 0},
        index: 0
    };

    var container3 = d3.select(opts.container),
        outerContainer3 = opts.outerContainer ?
            d3.select(opts.outerContainer) : container3;

    var fullOpts = {
        hovermode: 'closest',
        rotateLabels: false,
        bgColor: opts.bgColor || Color.background,
        container: container3,
        outerContainer: outerContainer3
    };

    var hoverLabel = createHoverText([pointData], fullOpts);
    alignHoverText(hoverLabel, fullOpts.rotateLabels);

    return hoverLabel.node();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        annTextGroupInner
        .on('mouseover', function() {
var hoverOptions = options.hoverlabel;
var hoverFont = hoverOptions.font;
var bBox = this.getBoundingClientRect();
var bBoxRef = gd.getBoundingClientRect();

Fx.<span class="apidocCodeKeywordSpan">loneHover</span>({
    x0: bBox.left - bBoxRef.left,
    x1: bBox.right - bBoxRef.left,
    y: (bBox.top + bBox.bottom) / 2 - bBoxRef.top,
    text: options.hovertext,
    color: hoverOptions.bgcolor,
    borderColor: hoverOptions.bordercolor,
    fontFamily: hoverFont.family,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.graph_interact.loneUnhover" id="apidoc.element.plotly.js.graph_interact.loneUnhover">
        function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>loneUnhover
        <span class="apidocSignatureSpan">(containerOrSelection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loneUnhover = function (containerOrSelection) {
    // duck type whether the arg is a d3 selection because ie9 doesn't
    // handle instanceof like modern browsers do.
    var selection = Lib.isD3Selection(containerOrSelection) ?
            containerOrSelection :
            d3.select(containerOrSelection);

    selection.selectAll('g.hovertext').remove();
    selection.selectAll('.spikeline').remove();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            fontColor: hoverFont.color
        }, {
            container: fullLayout._hoverlayer.node(),
            outerContainer: fullLayout._paper.node()
        });
    })
    .on('mouseout', function() {
        Fx.<span class="apidocCodeKeywordSpan">loneUnhover</span>(fullLayout._hoverlayer.node());
    });
}

var borderwidth = options.borderwidth,
    borderpad = options.borderpad,
    borderfull = borderwidth + borderpad;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.graph_interact.supplyLayoutDefaults" id="apidoc.element.plotly.js.graph_interact.supplyLayoutDefaults">
        function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>supplyLayoutDefaults
        <span class="apidocSignatureSpan">(layoutIn, layoutOut, fullData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">supplyLayoutDefaults = function (layoutIn, layoutOut, fullData) {

    function coerce(attr, dflt) {
        return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
    }

    coerce('dragmode');

    var hovermodeDflt;
    if(layoutOut._has('cartesian')) {
        // flag for 'horizontal' plots:
        // determines the state of the mode bar 'compare' hovermode button
        var isHoriz = layoutOut._isHoriz = fx.isHoriz(fullData);
        hovermodeDflt = isHoriz ? 'y' : 'x';
    }
    else hovermodeDflt = 'closest';

    coerce('hovermode', hovermodeDflt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

plots.supplyLayoutModuleDefaults = function(layoutIn, layoutOut, fullData, transitionData) {
    var i, _module;

    // can't be be part of basePlotModules loop
    // in order to handle the orphan axes case
    Plotly.Axes.<span class="apidocCodeKeywordSpan">supplyLayoutDefaults</span>(layoutIn, layoutOut, fullData);

    // base plot module layout defaults
    var basePlotModules = layoutOut._basePlotModules;
    for(i = 0; i &lt; basePlotModules.length; i++) {
_module = basePlotModules[i];

// done above already
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.graph_interact.unhover" id="apidoc.element.plotly.js.graph_interact.unhover">
        function <span class="apidocSignatureSpan">plotly.js.graph_interact.</span>unhover
        <span class="apidocSignatureSpan">(gd, evt, subplot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unhover = function (gd, evt, subplot) {
    if(typeof gd === 'string') gd = document.getElementById(gd);

    // Important, clear any queued hovers
    if(gd._hoverTimer) {
        clearTimeout(gd._hoverTimer);
        gd._hoverTimer = undefined;
    }

    unhover.raw(gd, evt, subplot);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if(gd._dragging) return;

    // When the mouse leaves this maindrag, unset the hovered subplot.
    // This may cause problems if it leaves the subplot directly *onto*
    // another subplot, but that's a tiny corner case at the moment.
    gd._fullLayout._hoversubplot = null;

    dragElement.<span class="apidocCodeKeywordSpan">unhover</span>(gd, evt);
};

maindrag.onclick = function(evt) {
    fx.click(gd, evt);
};

// corner draggers
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.helpers" id="apidoc.module.plotly.js.helpers">module plotly.js.helpers</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.helpers.cleanData" id="apidoc.element.plotly.js.helpers.cleanData">
        function <span class="apidocSignatureSpan">plotly.js.helpers.</span>cleanData
        <span class="apidocSignatureSpan">(data, existingData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanData = function (data, existingData) {

    // Enforce unique IDs
    var suids = [], // seen uids --- so we can weed out incoming repeats
        uids = data.concat(Array.isArray(existingData) ? existingData : [])
               .filter(function(trace) { return 'uid' in trace; })
               .map(function(trace) { return trace.uid; });

    for(var tracei = 0; tracei &lt; data.length; tracei++) {
        var trace = data[tracei];
        var i;

        // assign uids to each trace and detect collisions.
        if(!('uid' in trace) || suids.indexOf(trace.uid) !== -1) {
            var newUid;

            for(i = 0; i &lt; 100; i++) {
                newUid = Lib.randstr(uids);
                if(suids.indexOf(newUid) === -1) break;
            }
            trace.uid = Lib.randstr(uids);
            uids.push(trace.uid);
        }
        // keep track of already seen uids, so that if there are
        // doubles we force the trace with a repeat uid to
        // acquire a new one
        suids.push(trace.uid);

        // BACKWARD COMPATIBILITY FIXES

        // use xbins to bin data in x, and ybins to bin data in y
        if(trace.type === 'histogramy' &amp;&amp; 'xbins' in trace &amp;&amp; !('ybins' in trace)) {
            trace.ybins = trace.xbins;
            delete trace.xbins;
        }

        // error_y.opacity is obsolete - merge into color
        if(trace.error_y &amp;&amp; 'opacity' in trace.error_y) {
            var dc = Color.defaults,
                yeColor = trace.error_y.color ||
                (Registry.traceIs(trace, 'bar') ? Color.defaultLine : dc[tracei % dc.length]);
            trace.error_y.color = Color.addOpacity(
                Color.rgb(yeColor),
                Color.opacity(yeColor) * trace.error_y.opacity);
            delete trace.error_y.opacity;
        }

        // convert bardir to orientation, and put the data into
        // the axes it's eventually going to be used with
        if('bardir' in trace) {
            if(trace.bardir === 'h' &amp;&amp; (Registry.traceIs(trace, 'bar') ||
                     trace.type.substr(0, 9) === 'histogram')) {
                trace.orientation = 'h';
                exports.swapXYData(trace);
            }
            delete trace.bardir;
        }

        // now we have only one 1D histogram type, and whether
        // it uses x or y data depends on trace.orientation
        if(trace.type === 'histogramy') exports.swapXYData(trace);
        if(trace.type === 'histogramx' || trace.type === 'histogramy') {
            trace.type = 'histogram';
        }

        // scl-&gt;scale, reversescl-&gt;reversescale
        if('scl' in trace) {
            trace.colorscale = trace.scl;
            delete trace.scl;
        }
        if('reversescl' in trace) {
            trace.reversescale = trace.reversescl;
            delete trace.reversescl;
        }

        // axis ids x1 -&gt; x, y1-&gt; y
        if(trace.xaxis) trace.xaxis = Axes.cleanId(trace.xaxis, 'x');
        if(trace.yaxis) trace.yaxis = Axes.cleanId(trace.yaxis, 'y');

        // scene ids scene1 -&gt; scene
        if(Registry.traceIs(trace, 'gl3d') &amp;&amp; trace.scene) {
            trace.scene = Plots.subplotsRegistry.gl3d.cleanId(trace.scene);
        }

        if(!Registry.traceIs(trace, 'pie') &amp;&amp; !Registry.traceIs(trace, 'bar')) {
            if(Array.isArray(trace.textposition)) {
                trace.textposition = trace.textposition.map(cleanTextPosition);
            }
            else if(trace.textposition) {
                trace.textposition = cleanTextPosition(trace.textposition);
            }
        }

        // fix typo in colorscale definition
        if(Registry.traceIs(trace, '2dMap')) {
            if(trace.colorscale === 'YIGnBu') trace.colorscale = 'YlGnBu';
            if(trace.colorscale === 'YIOrRd') trace.colorscale = 'YlOrRd';
        }
        if(Registry.traceIs(trace, 'markerColorscale') &amp;&amp; trace.marker) {
            var cont = trace.marker;
            if(cont.colorscale === 'YIGnBu') cont.colorscale = 'YlGnBu';
            if(cont.colorscale === 'YIOrRd') cont.colorscale = 'YlOrRd';
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    gd._promises = [];

    var graphWasEmpty = ((gd.data || []).length === 0 &amp;&amp; Array.isArray(data));

    // if there is already data on the graph, append the new data
    // if you only want to redraw, pass a non-array for data
    if(Array.isArray(data)) {
helpers.<span class="apidocCodeKeywordSpan">cleanData</span>(data, gd.data);

if(graphWasEmpty) gd.data = data;
else gd.data.push.apply(gd.data, data);

// for routines outside graph_obj that want a clean tab
// (rather than appending to an existing one) gd.empty
// is used to determine whether to make a new tab
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.helpers.cleanLayout" id="apidoc.element.plotly.js.helpers.cleanLayout">
        function <span class="apidocSignatureSpan">plotly.js.helpers.</span>cleanLayout
        <span class="apidocSignatureSpan">(layout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanLayout = function (layout) {
    var i, j;

    if(!layout) layout = {};

    // cannot have (x|y)axis1, numbering goes axis, axis2, axis3...
    if(layout.xaxis1) {
        if(!layout.xaxis) layout.xaxis = layout.xaxis1;
        delete layout.xaxis1;
    }
    if(layout.yaxis1) {
        if(!layout.yaxis) layout.yaxis = layout.yaxis1;
        delete layout.yaxis1;
    }

    var axList = Axes.list({_fullLayout: layout});
    for(i = 0; i &lt; axList.length; i++) {
        var ax = axList[i];
        if(ax.anchor &amp;&amp; ax.anchor !== 'free') {
            ax.anchor = Axes.cleanId(ax.anchor);
        }
        if(ax.overlaying) ax.overlaying = Axes.cleanId(ax.overlaying);

        // old method of axis type - isdate and islog (before category existed)
        if(!ax.type) {
            if(ax.isdate) ax.type = 'date';
            else if(ax.islog) ax.type = 'log';
            else if(ax.isdate === false &amp;&amp; ax.islog === false) ax.type = 'linear';
        }
        if(ax.autorange === 'withzero' || ax.autorange === 'tozero') {
            ax.autorange = true;
            ax.rangemode = 'tozero';
        }
        delete ax.islog;
        delete ax.isdate;
        delete ax.categories; // replaced by _categories

        // prune empty domain arrays made before the new nestedProperty
        if(emptyContainer(ax, 'domain')) delete ax.domain;

        // autotick -&gt; tickmode
        if(ax.autotick !== undefined) {
            if(ax.tickmode === undefined) {
                ax.tickmode = ax.autotick ? 'auto' : 'linear';
            }
            delete ax.autotick;
        }
    }

    var annotationsLen = Array.isArray(layout.annotations) ? layout.annotations.length : 0;
    for(i = 0; i &lt; annotationsLen; i++) {
        var ann = layout.annotations[i];

        if(!Lib.isPlainObject(ann)) continue;

        if(ann.ref) {
            if(ann.ref === 'paper') {
                ann.xref = 'paper';
                ann.yref = 'paper';
            }
            else if(ann.ref === 'data') {
                ann.xref = 'x';
                ann.yref = 'y';
            }
            delete ann.ref;
        }

        cleanAxRef(ann, 'xref');
        cleanAxRef(ann, 'yref');
    }

    var shapesLen = Array.isArray(layout.shapes) ? layout.shapes.length : 0;
    for(i = 0; i &lt; shapesLen; i++) {
        var shape = layout.shapes[i];

        if(!Lib.isPlainObject(shape)) continue;

        cleanAxRef(shape, 'xref');
        cleanAxRef(shape, 'yref');
    }

    var legend = layout.legend;
    if(legend) {
        // check for old-style legend positioning (x or y is +/- 100)
        if(legend.x &gt; 3) {
            legend.x = 1.02;
            legend.xanchor = 'left';
        }
        else if(legend.x &lt; -2) {
            legend.x = -0.02;
            legend.xanchor = 'right';
        }

        if(legend.y &gt; 3) {
            legend.y = 1.02;
            legend.yanchor = 'bottom';
        }
        else if(legend.y &lt; -2) {
            legend.y = -0.02;
            legend.yanchor = 'top';
        }
    }

<span class="apidocCodeCommentSpan">    /*
     * Moved from rotate -&gt; orbit for dragmode
     */
</span>    if(layout.dragmode === 'rotate') layout.dragmode = 'orbit';

    // cannot have scene1, numbering goes scene, scene2, scene3...
    if(layout.scene1) {
        if(!layout.scene) layout.scene = layout.scene1;
        delete layout.scene1;
    }

    /*
     * Clean up Scene layouts
     */
    var sceneIds = Plots.getSubplotIds(layout, 'gl3d');
    for(i = 0; i &lt; sceneIds.length; i++) {
        var scene = layout[sceneIds[i]];

        // clean old Camera coords
        var cameraposition = scene.cameraposition;
        if(Array.isArray(cameraposition) &amp;&amp; cameraposition[0].length === 4) {
            var rotation = cameraposition[0],
                center = cameraposition[1],
                radius = cameraposition[2],
                mat = m4FromQuat([], rotation),
                eye = [];

            for(j = 0; j &lt; 3; ++j) {
                eye[j] = center[i] + radius * mat[2 + 4 * j];
            }

            scene.camera = {
                eye: {x: eye[0], y: eye[1], z: eye[2]}, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    // for routines outside graph_obj that want a clean tab
    // (rather than appending to an existing one) gd.empty
    // is used to determine whether to make a new tab
    gd.empty = false;
}

if(!gd.layout || graphWasEmpty) gd.layout = helpers.<span class="apidocCodeKeywordSpan">cleanLayout</span>(layout);

// if the user is trying to drag the axes, allow new data and layout
// to come in but don't allow a replot.
if(gd._dragging &amp;&amp; !gd._transitioning) {
    // signal to drag handler that after everything else is done
    // we need to replot, because something has changed
    gd._replotPending = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.helpers.clearPromiseQueue" id="apidoc.element.plotly.js.helpers.clearPromiseQueue">
        function <span class="apidocSignatureSpan">plotly.js.helpers.</span>clearPromiseQueue
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearPromiseQueue = function (gd) {
    if(Array.isArray(gd._promises) &amp;&amp; gd._promises.length &gt; 0) {
        Lib.log('Clearing previous rejected promises from queue.');
    }

    gd._promises = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * to apply different values to each trace.
 *
 * If the array is too short, it will wrap around (useful for
 * style files that want to specify cyclical default values).
 */
Plotly.restyle = function restyle(gd, astr, val, traces) {
gd = helpers.getGraphDiv(gd);
helpers.<span class="apidocCodeKeywordSpan">clearPromiseQueue</span>(gd);

var aobj = {};
if(typeof astr === 'string') aobj[astr] = val;
else if(Lib.isPlainObject(astr)) {
    // the 3-arg form
    aobj = Lib.extendFlat({}, astr);
    if(traces === undefined) traces = val;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.helpers.coerceTraceIndices" id="apidoc.element.plotly.js.helpers.coerceTraceIndices">
        function <span class="apidocSignatureSpan">plotly.js.helpers.</span>coerceTraceIndices
        <span class="apidocSignatureSpan">(gd, traceIndices)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coerceTraceIndices = function (gd, traceIndices) {
    if(isNumeric(traceIndices)) {
        return [traceIndices];
    }
    else if(!Array.isArray(traceIndices) || !traceIndices.length) {
        return gd.data.map(function(_, i) { return i; });
    }

    return traceIndices;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function _restyle(gd, aobj, _traces) {
var fullLayout = gd._fullLayout,
    fullData = gd._fullData,
    data = gd.data,
    i;

var traces = helpers.<span class="apidocCodeKeywordSpan">coerceTraceIndices</span>(gd, _traces);

// initialize flags
var flags = {
    docalc: false,
    docalcAutorange: false,
    doplot: false,
    dostyle: false,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.helpers.getGraphDiv" id="apidoc.element.plotly.js.helpers.getGraphDiv">
        function <span class="apidocSignatureSpan">plotly.js.helpers.</span>getGraphDiv
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getGraphDiv = function (gd) {
    var gdElement;

    if(typeof gd === 'string') {
        gdElement = document.getElementById(gd);

        if(gdElement === null) {
            throw new Error('No DOM element with id \'' + gd + '\' exists on the page.');
        }

        return gdElement;
    }
    else if(gd === null || gd === undefined) {
        throw new Error('DOM element provided is null or undefined');
    }

    return gd;  // otherwise assume that gd is a DOM element
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object} config
 *      configuration options (see ./plot_config.js for more info)
 *
 */
Plotly.plot = function(gd, data, layout, config) {
var frames;

gd = helpers.<span class="apidocCodeKeywordSpan">getGraphDiv</span>(gd);

// Events.init is idempotent and bails early if gd has already been init'd
Events.init(gd);

if(Lib.isPlainObject(data)) {
    var obj = data;
    data = obj.data;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.helpers.hasParent" id="apidoc.element.plotly.js.helpers.hasParent">
        function <span class="apidocSignatureSpan">plotly.js.helpers.</span>hasParent
        <span class="apidocSignatureSpan">(aobj, attr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasParent = function (aobj, attr) {
    var attrParent = getParent(attr);
    while(attrParent) {
        if(attrParent in aobj) return true;
        attrParent = getParent(attrParent);
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // attr can be an array to set several at once (all to the same val)
    function doextra(attr, val, i) {
if(Array.isArray(attr)) {
    attr.forEach(function(a) { doextra(a, val, i); });
    return;
}
// quit if explicitly setting this elsewhere
if(attr in aobj || helpers.<span class="apidocCodeKeywordSpan">hasParent</span>(aobj, attr)) return;

var extraparam;
if(attr.substr(0, 6) === 'LAYOUT') {
    extraparam = Lib.nestedProperty(gd.layout, attr.replace('LAYOUT', ''));
} else {
    extraparam = Lib.nestedProperty(data[traces[i]], attr);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.helpers.manageArrayContainers" id="apidoc.element.plotly.js.helpers.manageArrayContainers">
        function <span class="apidocSignatureSpan">plotly.js.helpers.</span>manageArrayContainers
        <span class="apidocSignatureSpan">(np, newVal, undoit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">manageArrayContainers = function (np, newVal, undoit) {
    var obj = np.obj,
        parts = np.parts,
        pLength = parts.length,
        pLast = parts[pLength - 1];

    var pLastIsNumber = isNumeric(pLast);

    // delete item
    if(pLastIsNumber &amp;&amp; newVal === null) {

        // Clear item in array container when new value is null
        var contPath = parts.slice(0, pLength - 1).join('.'),
            cont = Lib.nestedProperty(obj, contPath).get();
        cont.splice(pLast, 1);

        // Note that nested property clears null / undefined at end of
        // array container, but not within them.
    }
    // create item
    else if(pLastIsNumber &amp;&amp; np.get() === undefined) {

        // When adding a new item, make sure undo command will remove it
        if(np.get() === undefined) undoit[np.astr] = null;

        np.set(newVal);
    }
    // update item
    else {

        // If the last part of attribute string isn't a number,
        // np.set is all we need.
        np.set(newVal);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    cont.orientation =
        {v: 'h', h: 'v'}[contFull.orientation];
}
helpers.swapXYData(cont);
            }
            else if(Plots.dataArrayContainers.indexOf(param.parts[0]) !== -1) {
// TODO: use manageArrays.applyContainerArrayChanges here too
helpers.<span class="apidocCodeKeywordSpan">manageArrayContainers</span>(param, newVal, undoit);
flags.docalc = true;
            }
            else {
var moduleAttrs = (contFull._module || {}).attributes || {};
var valObject = Lib.nestedProperty(moduleAttrs, ai).get() || {};

// if restyling entire attribute container, assume worse case
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.helpers.swapXYData" id="apidoc.element.plotly.js.helpers.swapXYData">
        function <span class="apidocSignatureSpan">plotly.js.helpers.</span>swapXYData
        <span class="apidocSignatureSpan">(trace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">swapXYData = function (trace) {
    var i;
    Lib.swapAttrs(trace, ['?', '?0', 'd?', '?bins', 'nbins?', 'autobin?', '?src', 'error_?']);
    if(Array.isArray(trace.z) &amp;&amp; Array.isArray(trace.z[0])) {
        if(trace.transpose) delete trace.transpose;
        else trace.transpose = true;
    }
    if(trace.error_x &amp;&amp; trace.error_y) {
        var errorY = trace.error_y,
            copyYstyle = ('copy_ystyle' in errorY) ? errorY.copy_ystyle :
                !(errorY.color || errorY.thickness || errorY.width);
        Lib.swapAttrs(trace, ['error_?.copy_ystyle']);
        if(copyYstyle) {
            Lib.swapAttrs(trace, ['error_?.color', 'error_?.thickness', 'error_?.width']);
        }
    }
    if(trace.hoverinfo) {
        var hoverInfoParts = trace.hoverinfo.split('+');
        for(i = 0; i &lt; hoverInfoParts.length; i++) {
            if(hoverInfoParts[i] === 'x') hoverInfoParts[i] = 'y';
            else if(hoverInfoParts[i] === 'y') hoverInfoParts[i] = 'x';
        }
        trace.hoverinfo = hoverInfoParts.join('+');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// convert bardir to orientation, and put the data into
// the axes it's eventually going to be used with
if('bardir' in trace) {
    if(trace.bardir === 'h' &amp;&amp; (Registry.traceIs(trace, 'bar') ||
             trace.type.substr(0, 9) === 'histogram')) {
        trace.orientation = 'h';
        exports.<span class="apidocCodeKeywordSpan">swapXYData</span>(trace);
    }
    delete trace.bardir;
}

// now we have only one 1D histogram type, and whether
// it uses x or y data depends on trace.orientation
if(trace.type === 'histogramy') exports.swapXYData(trace);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.index" id="apidoc.module.plotly.js.index">module plotly.js.index</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.index.OptionControl" id="apidoc.element.plotly.js.index.OptionControl">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>OptionControl
        <span class="apidocSignatureSpan">(opt, optname)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">OptionControl = function (opt, optname) {
<span class="apidocCodeCommentSpan">    /*
     * An environment to contain all option setters and
     * getters that collectively modify opts.
     *
     * You can call up opts from any function in new object
     * as this.optname || this.opt
     *
     * See FitOpts for example of usage
     */
</span>    if(!opt) opt = {};
    if(!optname) optname = 'opt';

    var self = {};
    self.optionList = [];

    self._newoption = function(optObj) {
        optObj[optname] = opt;
        self[optObj.name] = optObj;
        self.optionList.push(optObj);
    };

    self['_' + optname] = opt;
    return self;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.addStyleRule" id="apidoc.element.plotly.js.index.addStyleRule">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>addStyleRule
        <span class="apidocSignatureSpan">(selector, styleString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addStyleRule = function (selector, styleString) {
    if(!lib.styleSheet) {
        var style = document.createElement('style');
        // WebKit hack :(
        style.appendChild(document.createTextNode(''));
        document.head.appendChild(style);
        lib.styleSheet = style.sheet;
    }
    var styleSheet = lib.styleSheet;

    if(styleSheet.insertRule) {
        styleSheet.insertRule(selector + '{' + styleString + '}', 0);
    }
    else if(styleSheet.addRule) {
        styleSheet.addRule(selector, styleString, 0);
    }
    else lib.warn('addStyleRule failed');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'var Lib = require(\'../src/lib\');',
    'var rules = ' + rulesStr + ';',
    '',
    'for(var selector in rules) {',
    '    var fullSelector = selector.replace(/^,/,\' ,\')',
    '        .replace(/X/g, \'.js-plotly-plot .plotly\')',
    '        .replace(/Y/g, \'.plotly-notifier\');',
    '    Lib.<span class="apidocCodeKeywordSpan">addStyleRule</span>(fullSelector, rules[selector]);',
    '}',
    ''
].join('\n');

fs.writeFile(pathOut, outStr, function(err) {
    if(err) throw err;
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.aggNums" id="apidoc.element.plotly.js.index.aggNums">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>aggNums
        <span class="apidocSignatureSpan">(f, v, a, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">aggNums = function (f, v, a, len) {
    var i,
        b;
    if(!len) len = a.length;
    if(!isNumeric(v)) v = false;
    if(Array.isArray(a[0])) {
        b = new Array(len);
        for(i = 0; i &lt; len; i++) b[i] = exports.aggNums(f, v, a[i]);
        a = b;
    }

    for(i = 0; i &lt; len; i++) {
        if(!isNumeric(v)) v = a[i];
        else if(isNumeric(a[i])) v = f(+v, +a[i]);
    }
    return v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.aggNums = function(f, v, a, len) {
var i,
    b;
if(!len) len = a.length;
if(!isNumeric(v)) v = false;
if(Array.isArray(a[0])) {
    b = new Array(len);
    for(i = 0; i &lt; len; i++) b[i] = exports.<span class="apidocCodeKeywordSpan">aggNums</span>(f, v, a[i]);
    a = b;
}

for(i = 0; i &lt; len; i++) {
    if(!isNumeric(v)) v = a[i];
    else if(isNumeric(a[i])) v = f(+v, +a[i]);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.apply2DTransform" id="apidoc.element.plotly.js.index.apply2DTransform">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>apply2DTransform
        <span class="apidocSignatureSpan">(transform)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply2DTransform = function (transform) {
    return function() {
        var args = arguments;
        if(args.length === 3) {
            args = args[0];
        }// from map
        var xy = arguments.length === 1 ? args[0] : [args[0], args[1]];
        return exports.dot(transform, [xy[0], xy[1], 1]).slice(0, 2);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var xy = arguments.length === 1 ? args[0] : [args[0], args[1]];
        return exports.dot(transform, [xy[0], xy[1], 1]).slice(0, 2);
    };
};

// applies a 2D transformation matrix to an [x1,y1,x2,y2] array (to transform a segment)
exports.apply2DTransform2 = function(transform) {
    var at = exports.<span class="apidocCodeKeywordSpan">apply2DTransform</span>(transform);
    return function(xys) {
        return at(xys.slice(0, 2)).concat(at(xys.slice(2, 4)));
    };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.apply2DTransform2" id="apidoc.element.plotly.js.index.apply2DTransform2">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>apply2DTransform2
        <span class="apidocSignatureSpan">(transform)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply2DTransform2 = function (transform) {
    var at = exports.apply2DTransform(transform);
    return function(xys) {
        return at(xys.slice(0, 2)).concat(at(xys.slice(2, 4)));
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
textX = annPosPx.x.text + dx,
textY = annPosPx.y.text + dy,

// find the edge of the text box, where we'll start the arrow:
// create transform matrix to rotate the text box corners
transform = Lib.rotationXYMatrix(textangle, textX, textY),
applyTransform = Lib.apply2DTransform(transform),
applyTransform2 = Lib.<span class="apidocCodeKeywordSpan">apply2DTransform2</span>(transform),

// calculate and transform bounding box
width = +annTextBG.attr('width'),
height = +annTextBG.attr('height'),
xLeft = textX - 0.5 * width,
xRight = xLeft + width,
yTop = textY - 0.5 * height,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.bBoxIntersect" id="apidoc.element.plotly.js.index.bBoxIntersect">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>bBoxIntersect
        <span class="apidocSignatureSpan">(a, b, pad)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bBoxIntersect = function (a, b, pad) {
    pad = pad || 0;
    return (a.left &lt;= b.right + pad &amp;&amp;
            b.left &lt;= a.right + pad &amp;&amp;
            a.top &lt;= b.bottom + pad &amp;&amp;
            b.top &lt;= a.bottom + pad);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        left: x - bb.width / 2,
        // impose a 2px gap
        right: x + bb.width / 2 + 2,
        width: bb.width + 2
    });
});
for(i = 0; i &lt; lbbArray.length - 1; i++) {
    if(Lib.<span class="apidocCodeKeywordSpan">bBoxIntersect</span>(lbbArray[i], lbbArray[i + 1])) {
        // any overlap at all - set 30 degrees
        autoangle = 30;
        break;
    }
}
if(autoangle) {
    var tickspacing = Math.abs(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.cleanDate" id="apidoc.element.plotly.js.index.cleanDate">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>cleanDate
        <span class="apidocSignatureSpan">(v, dflt, calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanDate = function (v, dflt, calendar) {
    if(exports.isJSDate(v) || typeof v === 'number') {
        // do not allow milliseconds (old) or jsdate objects (inherently
        // described as gregorian dates) with world calendars
        if(isWorldCalendar(calendar)) {
            logError('JS Dates and milliseconds are incompatible with world calendars', v);
            return dflt;
        }

        // NOTE: if someone puts in a year as a number rather than a string,
        // this will mistakenly convert it thinking it's milliseconds from 1970
        // that is: '2012' -&gt; Jan. 1, 2012, but 2012 -&gt; 2012 epoch milliseconds
        v = exports.ms2DateTimeLocal(+v);
        if(!v &amp;&amp; dflt !== undefined) return dflt;
    }
    else if(!exports.isDateTime(v, calendar)) {
        logError('unrecognized date', v);
        return dflt;
    }
    return v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if(typeof pos === 'string' &amp;&amp; (ax._categories || []).length) {
                newPos = ax._categories.indexOf(pos);
                containerOut[attr] = (newPos === -1) ? dflt : newPos;
                return;
            }
        }
        else if(ax.type === 'date') {
            containerOut[attr] = Lib.<span class="apidocCodeKeywordSpan">cleanDate</span>(pos, BADNUM, ax.calendar);
            return;
        }
    }
    // finally make sure we have a number (unless date type already returned a string)
    containerOut[attr] = isNumeric(pos) ? Number(pos) : dflt;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.cleanNumber" id="apidoc.element.plotly.js.index.cleanNumber">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>cleanNumber
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cleanNumber(v) {
    if(typeof v === 'string') {
        v = v.replace(JUNK, '');
    }

    if(isNumeric(v)) return Number(v);

    return BADNUM;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var inc = Math.max(1, (a.length - 1) / 1000),
        curvenums = 0,
        curvecats = 0,
        ai;

    for(var i = 0; i &lt; a.length; i += inc) {
        ai = a[Math.round(i)];
        if(Lib.<span class="apidocCodeKeywordSpan">cleanNumber</span>(ai) !== BADNUM) curvenums++;
        else if(typeof ai === 'string' &amp;&amp; ai !== '' &amp;&amp; ai !== 'None') curvecats
++;
    }

    return curvecats &gt; curvenums * 2;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.coerce" id="apidoc.element.plotly.js.index.coerce">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>coerce
        <span class="apidocSignatureSpan">(containerIn, containerOut, attributes, attribute, dflt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coerce = function (containerIn, containerOut, attributes, attribute, dflt) {
    var opts = nestedProperty(attributes, attribute).get(),
        propIn = nestedProperty(containerIn, attribute),
        propOut = nestedProperty(containerOut, attribute),
        v = propIn.get();

    if(dflt === undefined) dflt = opts.dflt;

<span class="apidocCodeCommentSpan">    /**
     * arrayOk: value MAY be an array, then we do no value checking
     * at this point, because it can be more complicated than the
     * individual form (eg. some array vals can be numbers, even if the
     * single values must be color strings)
     */
</span>    if(opts.arrayOk &amp;&amp; Array.isArray(v)) {
        propOut.set(v);
        return v;
    }

    exports.valObjects[opts.valType].coerceFunction(v, propOut, dflt, opts);

    return propOut.get();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    var items = opts.items,
        vOut = [];
    dflt = Array.isArray(dflt) ? dflt : [];

    for(var i = 0; i &lt; items.length; i++) {
        exports.<span class="apidocCodeKeywordSpan">coerce</span>(v, vOut, items, '[' + i + ']', dflt[i]);
    }

    propOut.set(vOut);
},
validateFunction: function(v, opts) {
    if(!Array.isArray(v)) return false;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.coerce2" id="apidoc.element.plotly.js.index.coerce2">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>coerce2
        <span class="apidocSignatureSpan">(containerIn, containerOut, attributes, attribute, dflt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coerce2 = function (containerIn, containerOut, attributes, attribute, dflt) {
    var propIn = nestedProperty(containerIn, attribute),
        propOut = exports.coerce(containerIn, containerOut, attributes, attribute, dflt),
        valIn = propIn.get();

    return (valIn !== undefined &amp;&amp; valIn !== null) ? propOut : false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var letter = options.letter,
    font = options.font || {},
    defaultTitle = 'Click to enter ' +
        (options.title || (letter.toUpperCase() + ' axis')) +
        ' title';

function coerce2(attr, dflt) {
    return Lib.<span class="apidocCodeKeywordSpan">coerce2</span>(containerIn, containerOut, layoutAttributes, attr, dflt);
}

var visible = coerce('visible', !options.cheateronly);

var axType = containerOut.type;

if(axType === 'date') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.coerceFont" id="apidoc.element.plotly.js.index.coerceFont">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>coerceFont
        <span class="apidocSignatureSpan">(coerce, attr, dfltObj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">coerceFont = function (coerce, attr, dfltObj) {
    var out = {};

    dfltObj = dfltObj || {};

    out.family = coerce(attr + '.family', dfltObj.family);
    out.size = coerce(attr + '.size', dfltObj.size);
    out.color = coerce(attr + '.color', dfltObj.color);

    return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

plots.supplyLayoutGlobalDefaults = function(layoutIn, layoutOut) {
function coerce(attr, dflt) {
    return Lib.coerce(layoutIn, layoutOut, plots.layoutAttributes, attr, dflt);
}

var globalFont = Lib.<span class="apidocCodeKeywordSpan">coerceFont</span>(coerce, 'font');

coerce('title');

Lib.coerceFont(coerce, 'titlefont', {
    family: globalFont.family,
    size: Math.round(globalFont.size * 1.4),
    color: globalFont.color
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.constrain" id="apidoc.element.plotly.js.index.constrain">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>constrain
        <span class="apidocSignatureSpan">(v, v0, v1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constrain = function (v, v0, v1) {
    if(v0 &gt; v1) return Math.max(v1, Math.min(v0, v));
    return Math.max(v0, Math.min(v1, v));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

posPx.text = posPx.tail + textShift;

// constrain pixel/paper referenced so the draggers are at least
// partially visible
var maxPx = fullLayout[(axLetter === 'x') ? 'width' : 'height'];
if(axRef === 'paper') {
    posPx.head = Lib.<span class="apidocCodeKeywordSpan">constrain</span>(posPx.head, 1, maxPx - 1);
}
if(tailRef === 'pixel') {
    var shiftPlus = -Math.max(posPx.tail - 3, posPx.text),
        shiftMinus = Math.min(posPx.tail + 3, posPx.text) - maxPx;
    if(shiftPlus &gt; 0) {
        posPx.tail += shiftPlus;
        posPx.text += shiftPlus;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.containsAny" id="apidoc.element.plotly.js.index.containsAny">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>containsAny
        <span class="apidocSignatureSpan">(s, fragments)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">containsAny = function (s, fragments) {
    for(var i = 0; i &lt; fragments.length; i++) {
        if(s.indexOf(fragments[i]) !== -1) return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if(refAutorange(toggledObj, 'x') || refAutorange(toggledObj, 'y') &amp;&amp;
            ai.indexOf('updatemenus') === -1) {
        flags.docalc = true;
    }
}
else if((refAutorange(obji, 'x') || refAutorange(obji, 'y')) &amp;&amp;
        !Lib.<span class="apidocCodeKeywordSpan">containsAny</span>(ai, ['color', 'opacity', 'align'
;, 'dash', 'updatemenus'])) {
    flags.docalc = true;
}

// prepare the edits object we'll send to applyContainerArrayChanges
if(!arrayEdits[arrayStr]) arrayEdits[arrayStr] = {};
var objEdits = arrayEdits[arrayStr][i];
if(!objEdits) objEdits = arrayEdits[arrayStr][i] = {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.dateTick0" id="apidoc.element.plotly.js.index.dateTick0">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>dateTick0
        <span class="apidocSignatureSpan">(calendar, sunday)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateTick0 = function (calendar, sunday) {
    if(isWorldCalendar(calendar)) {
        return sunday ?
            Registry.getComponentMethod('calendars', 'CANONICAL_SUNDAY')[calendar] :
            Registry.getComponentMethod('calendars', 'CANONICAL_TICK')[calendar];
    }
    else {
        return sunday ? '2000-01-02' : '2000-01-01';
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//      log with linear ticks: L# where # is the linear tick spacing
//      log showing powers plus some intermediates:
//          D1 shows all digits, D2 shows 2 and 5
axes.autoTicks = function(ax, roughDTick) {
    var base;

    if(ax.type === 'date') {
ax.tick0 = Lib.<span class="apidocCodeKeywordSpan">dateTick0</span>(ax.calendar);
// the criteria below are all based on the rough spacing we calculate
// being &gt; half of the final unit - so precalculate twice the rough val
var roughX2 = 2 * roughDTick;

if(roughX2 &gt; ONEAVGYEAR) {
    roughDTick /= ONEAVGYEAR;
    base = Math.pow(10, Math.floor(Math.log(roughDTick) / Math.LN10));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.dateTime2ms" id="apidoc.element.plotly.js.index.dateTime2ms">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>dateTime2ms
        <span class="apidocSignatureSpan">(s, calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dateTime2ms = function (s, calendar) {
    // first check if s is a date object
    if(exports.isJSDate(s)) {
        // Convert to the UTC milliseconds that give the same
        // hours as this date has in the local timezone
        s = Number(s) - s.getTimezoneOffset() * ONEMIN;
        if(s &gt;= MIN_MS &amp;&amp; s &lt;= MAX_MS) return s;
        return BADNUM;
    }
    // otherwise only accept strings and numbers
    if(typeof s !== 'string' &amp;&amp; typeof s !== 'number') return BADNUM;

    s = String(s);

    var isWorld = isWorldCalendar(calendar);

    // to handle out-of-range dates in international calendars, accept
    // 'G' as a prefix to force the built-in gregorian calendar.
    var s0 = s.charAt(0);
    if(isWorld &amp;&amp; (s0 === 'G' || s0 === 'g')) {
        s = s.substr(1);
        calendar = '';
    }

    var isChinese = isWorld &amp;&amp; calendar.substr(0, 7) === 'chinese';

    var match = s.match(isChinese ? DATETIME_REGEXP_CN : DATETIME_REGEXP);
    if(!match) return BADNUM;
    var y = match[1],
        m = match[3] || '1',
        d = Number(match[5] || 1),
        H = Number(match[7] || 0),
        M = Number(match[9] || 0),
        S = Number(match[11] || 0);

    if(isWorld) {
        // disallow 2-digit years for world calendars
        if(y.length === 2) return BADNUM;
        y = Number(y);

        var cDate;
        try {
            var calInstance = Registry.getComponentMethod('calendars', 'getCal')(calendar);
            if(isChinese) {
                var isIntercalary = m.charAt(m.length - 1) === 'i';
                m = parseInt(m, 10);
                cDate = calInstance.newDate(y, calInstance.toMonthIndex(y, m, isIntercalary), d);
            }
            else {
                cDate = calInstance.newDate(y, Number(m), d);
            }
        }
        catch(e) { return BADNUM; } // Invalid ... date

        if(!cDate) return BADNUM;

        return ((cDate.toJD() - EPOCHJD) * ONEDAY) +
            (H * ONEHOUR) + (M * ONEMIN) + (S * ONESEC);
    }

    if(y.length === 2) {
        y = (Number(y) + 2000 - YFIRST) % 100 + YFIRST;
    }
    else y = Number(y);

    // new Date uses months from 0; subtract 1 here just so we
    // don't have to do it again during the validity test below
    m -= 1;

    // javascript takes new Date(0..99,m,d) to mean 1900-1999, so
    // to support years 0-99 we need to use setFullYear explicitly
    // Note that 2000 is a leap year.
    var date = new Date(Date.UTC(2000, m, d, H, M));
    date.setUTCFullYear(y);

    if(date.getUTCMonth() !== m) return BADNUM;
    if(date.getUTCDate() !== d) return BADNUM;

    return date.getTime() + S * ONESEC;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if(date.getUTCMonth() !== m) return BADNUM;
    if(date.getUTCDate() !== d) return BADNUM;

    return date.getTime() + S * ONESEC;
};

MIN_MS = exports.MIN_MS = exports.<span class="apidocCodeKeywordSpan">dateTime2ms</span>('-9999');
MAX_MS = exports.MAX_MS = exports.dateTime2ms('9999-12-31 23:59:59.9999');

// is string s a date? (see above)
exports.isDateTime = function(s, calendar) {
    return (exports.dateTime2ms(s, calendar) !== BADNUM);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.dfltRange" id="apidoc.element.plotly.js.index.dfltRange">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>dfltRange
        <span class="apidocSignatureSpan">(calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dfltRange = function (calendar) {
    if(isWorldCalendar(calendar)) {
        return Registry.getComponentMethod('calendars', 'DFLTRANGE')[calendar];
    }
    else {
        return ['2000-01-01', '2001-01-01'];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     */
    ax.cleanRange = function(rangeAttr) {
if(!rangeAttr) rangeAttr = 'range';
var range = Lib.nestedProperty(ax, rangeAttr).get(),
    axLetter = (ax._id || 'x').charAt(0),
    i, dflt;

if(ax.type === 'date') dflt = Lib.<span class="apidocCodeKeywordSpan">dfltRange</span>(ax.calendar);
else if(axLetter === 'y') dflt = constants.DFLTRANGEY;
else dflt = constants.DFLTRANGEX;

// make sure we don't later mutate the defaults
dflt = dflt.slice();

if(!range || range.length !== 2) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.distinctVals" id="apidoc.element.plotly.js.index.distinctVals">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>distinctVals
        <span class="apidocSignatureSpan">(valsIn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distinctVals = function (valsIn) {
    var vals = valsIn.slice();  // otherwise we sort the original array...
    vals.sort(exports.sorterAsc);

    var l = vals.length - 1,
        minDiff = (vals[l] - vals[0]) || 1,
        errDiff = minDiff / (l || 1) / 10000,
        v2 = [vals[0]];

    for(var i = 0; i &lt; l; i++) {
        // make sure values aren't just off by a rounding error
        if(vals[i + 1] &gt; vals[i] + errDiff) {
            minDiff = Math.min(minDiff, vals[i + 1] - vals[i]);
            v2.push(vals[i + 1]);
        }
    }

    return {vals: v2, minDiff: minDiff};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var size0;
if(nbins) size0 = ((dataMax - dataMin) / nbins);
else {
    // totally auto: scale off std deviation so the highest bin is
    // somewhat taller than the total number of bins, but don't let
    // the size get smaller than the 'nice' rounded down minimum
    // difference between values
    var distinctData = Lib.<span class="apidocCodeKeywordSpan">distinctVals</span>(data),
        msexp = Math.pow(10, Math.floor(
            Math.log(distinctData.minDiff) / Math.LN10)),
        minSize = msexp * Lib.roundUp(
            distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);
    size0 = Math.max(minSize, 2 * Lib.stdev(data) /
        Math.pow(data.length, is2d ? 0.25 : 0.4));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.dot" id="apidoc.element.plotly.js.index.dot">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>dot
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dot = function (x, y) {
    if(!(x.length &amp;&amp; y.length) || x.length !== y.length) return null;

    var len = x.length,
        out,
        i;

    if(x[0].length) {
        // mat-vec or mat-mat
        out = new Array(len);
        for(i = 0; i &lt; len; i++) out[i] = exports.dot(x[i], y);
    }
    else if(y[0].length) {
        // vec-mat
        var yTranspose = exports.transposeRagged(y);
        out = new Array(yTranspose.length);
        for(i = 0; i &lt; yTranspose.length; i++) out[i] = exports.dot(x, yTranspose[i]);
    }
    else {
        // vec-vec
        out = 0;
        for(i = 0; i &lt; len; i++) out += x[i] * y[i];
    }

    return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var len = x.length,
    out,
    i;

if(x[0].length) {
    // mat-vec or mat-mat
    out = new Array(len);
    for(i = 0; i &lt; len; i++) out[i] = exports.<span class="apidocCodeKeywordSpan">dot</span>(x[i], y);
}
else if(y[0].length) {
    // vec-mat
    var yTranspose = exports.transposeRagged(y);
    out = new Array(yTranspose.length);
    for(i = 0; i &lt; yTranspose.length; i++) out[i] = exports.dot(x, yTranspose[i]);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.ensureArray" id="apidoc.element.plotly.js.index.ensureArray">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>ensureArray
        <span class="apidocSignatureSpan">(out, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureArray(out, n) {
    if(!Array.isArray(out)) out = [];

    // If too long, truncate. (If too short, it will grow
    // automatically so we don't care about that case)
    out.length = n;

    return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return d3.range(_count).map(function(d, i) {
        return arr[i] || arr[0];
    });
};

Âµ.util.fillArrays = function(_obj, _valueNames, _count) {
    _valueNames.forEach(function(d, i) {
        _obj[d] = Âµ.util.<span class="apidocCodeKeywordSpan">ensureArray</span>(_obj[d], _count);
    });
    return _obj;
};

Âµ.util.cloneJson = function(json) {
    return JSON.parse(JSON.stringify(json));
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.error" id="apidoc.element.plotly.js.index.error">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>error
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function () {
    if(config.logging &gt; 0) {
        var messages = ['ERROR:'];

        for(var i = 0; i &lt; arguments.length; i++) {
            messages.push(arguments[i]);
        }

        apply(console.error, messages);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// so we define the default (plotly.js) behavior here
function defaultSetBackground(gd, bgColor) {
    try {
        gd._fullLayout._paper.style('background', bgColor);
    }
    catch(e) {
        if(module.exports.logging &gt; 0) {
            console.<span class="apidocCodeKeywordSpan">error</span>(e);
        }
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.expandObjectPaths" id="apidoc.element.plotly.js.index.expandObjectPaths">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>expandObjectPaths
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expandObjectPaths = function (data) {
    var match, key, prop, datum, idx, dest, trailingPath;
    if(typeof data === 'object' &amp;&amp; !Array.isArray(data)) {
        for(key in data) {
            if(data.hasOwnProperty(key)) {
                if((match = key.match(dottedPropertyRegex))) {
                    datum = data[key];
                    prop = match[1];

                    delete data[key];

                    data[prop] = lib.extendDeepNoArrays(data[prop] || {}, lib.objectFromPath(key, lib.expandObjectPaths(datum))[
prop]);
                } else if((match = key.match(indexedPropertyRegex))) {
                    datum = data[key];

                    prop = match[1];
                    idx = parseInt(match[2]);

                    delete data[key];

                    data[prop] = data[prop] || [];

                    if(match[3] === '.') {
                        // This is the case where theere are subsequent properties into which
                        // we must recurse, e.g. transforms[0].value
                        trailingPath = match[4];
                        dest = data[prop][idx] = data[prop][idx] || {};

                        // NB: Extend deep no arrays prevents this from working on multiple
                        // nested properties in the same object, e.g.
                        //
                        // {
                        //   foo[0].bar[1].range
                        //   foo[0].bar[0].range
                        // }
                        //
                        // In this case, the extendDeepNoArrays will overwrite one array with
                        // the other, so that both properties *will not* be present in the
                        // result. Fixing this would require a more intelligent tracking
                        // of changes and merging than extendDeepNoArrays currently accomplishes.
                        lib.extendDeepNoArrays(dest, lib.objectFromPath(trailingPath, lib.expandObjectPaths(datum)));
                    } else {
                        // This is the case where this property is the end of the line,
                        // e.g. xaxis.range[0]
                        data[prop][idx] = lib.expandObjectPaths(datum);
                    }
                } else {
                    data[key] = lib.expandObjectPaths(data[key]);
                }
            }
        }
    }

    return data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Iterate through an object in-place, converting dotted properties to objects.
*
* Examples:
*
*   lib.<span class="apidocCodeKeywordSpan">expandObjectPaths</span>({'nested.test.path': 'value'});
*     =&gt; { nested: { test: {path: 'value'}}}
*
* It also handles array notation, e.g.:
*
*   lib.expandObjectPaths({'foo[1].bar': 'value'});
*     =&gt; { foo: [null, {bar: value}] }
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.extendDeep" id="apidoc.element.plotly.js.index.extendDeep">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>extendDeep
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendDeep = function () {
    return _extend(arguments, true, false, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    for(var i = 0; i &lt; args.length; i++) {
        arg = args[i];

        if(arg === gd) copy[i] = arg;
        else if(typeof arg === 'object') {
            copy[i] = Array.isArray(arg) ?
                Lib.<span class="apidocCodeKeywordSpan">extendDeep</span>([], arg) :
                Lib.extendDeepAll({}, arg);
        }
        else copy[i] = arg;
    }

    return copy;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.extendDeepAll" id="apidoc.element.plotly.js.index.extendDeepAll">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>extendDeepAll
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendDeepAll = function () {
    return _extend(arguments, true, true, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for(var i = 0; i &lt; args.length; i++) {
        arg = args[i];

        if(arg === gd) copy[i] = arg;
        else if(typeof arg === 'object') {
            copy[i] = Array.isArray(arg) ?
                Lib.extendDeep([], arg) :
                Lib.<span class="apidocCodeKeywordSpan">extendDeepAll</span>({}, arg);
        }
        else copy[i] = arg;
    }

    return copy;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.extendDeepNoArrays" id="apidoc.element.plotly.js.index.extendDeepNoArrays">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>extendDeepNoArrays
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendDeepNoArrays = function () {
    return _extend(arguments, true, false, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if(data.hasOwnProperty(key)) {
                if((match = key.match(dottedPropertyRegex))) {
datum = data[key];
prop = match[1];

delete data[key];

data[prop] = lib.<span class="apidocCodeKeywordSpan">extendDeepNoArrays</span>(data[prop] || {}, lib.objectFromPath(key, lib.expandObjectPaths
(datum))[prop]);
                } else if((match = key.match(indexedPropertyRegex))) {
datum = data[key];

prop = match[1];
idx = parseInt(match[2]);

delete data[key];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.extendFlat" id="apidoc.element.plotly.js.index.extendFlat">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>extendFlat
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendFlat = function () {
    return _extend(arguments, false, false, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function opaqueSetBackground(gd, bgColor) {
gd._fullLayout._paperdiv.style('background', 'white');
Plotly.defaultConfig.setBackground(gd, bgColor);
}

function setPlotContext(gd, config) {
if(!gd._context) gd._context = Lib.<span class="apidocCodeKeywordSpan">extendFlat</span>({}, Plotly.defaultConfig);
var context = gd._context;

if(config) {
    Object.keys(config).forEach(function(key) {
        if(key in context) {
            if(key === 'setBackground' &amp;&amp; config[key] === 'opaque') {
                context[key] = opaqueSetBackground;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.filterUnique" id="apidoc.element.plotly.js.index.filterUnique">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>filterUnique
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filterUnique(array) {
    var seen = {},
        out = [],
        j = 0;

    for(var i = 0; i &lt; array.length; i++) {
        var item = array[i];

        if(seen[item] !== 1) {
            seen[item] = 1;
            out[j++] = item;
        }
    }

    return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Return news array containing only the unique items
* found in input array.
*
* IMPORTANT: Note that items are considered unique
* if `String({})` is unique. For example;
*
*  Lib.<span class="apidocCodeKeywordSpan">filterUnique</span>([ { a: 1 }, { b: 2 } ])
*
*  returns [{ a: 1 }]
*
* and
*
*  Lib.filterUnique([ '1', 1 ])
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.filterVisible" id="apidoc.element.plotly.js.index.filterVisible">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>filterVisible
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filterVisible(container) {
    var out = [];

    for(var i = 0; i &lt; container.length; i++) {
        var item = container[i];

        if(item.visible === true) out.push(item);
    }

    return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var Axes = require('../../plots/cartesian/axes');

var draw = require('./draw').draw;


module.exports = function calcAutorange(gd) {
var fullLayout = gd._fullLayout,
    annotationList = Lib.<span class="apidocCodeKeywordSpan">filterVisible</span>(fullLayout.annotations);

if(!annotationList.length || !gd._fullData.length) return;

var annotationAxes = {};
annotationList.forEach(function(ann) {
    annotationAxes[ann.xref] = true;
    annotationAxes[ann.yref] = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.findBin" id="apidoc.element.plotly.js.index.findBin">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>findBin
        <span class="apidocSignatureSpan">(val, bins, linelow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findBin = function (val, bins, linelow) {
    if(isNumeric(bins.start)) {
        return linelow ?
            Math.ceil((val - bins.start) / bins.size) - 1 :
            Math.floor((val - bins.start) / bins.size);
    }
    else {
        var n1 = 0,
            n2 = bins.length,
            c = 0,
            n,
            test;
        if(bins[bins.length - 1] &gt;= bins[0]) {
            test = linelow ? lessThan : lessOrEqual;
        } else {
            test = linelow ? greaterOrEqual : greaterThan;
        }
        // c is just to avoid infinite loops if there's an error
        while(n1 &lt; n2 &amp;&amp; c++ &lt; 100) {
            n = Math.floor((n1 + n2) / 2);
            if(test(bins[n], val)) n1 = n + 1;
            else n2 = n;
        }
        if(c &gt; 90) loggers.log('Long binary search...');
        return n1 - 1;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    var i1, i2, text;

    if(hasColumnText) text = Lib.init2dArray(col2vals.length, col1vals.length);

    for(i = 0; i &lt; colLen; i++) {
        if(col1[i] !== BADNUM &amp;&amp; col2[i] !== BADNUM) {
i1 = Lib.<span class="apidocCodeKeywordSpan">findBin</span>(col1[i] + col1dv.minDiff / 2, col1vals);
i2 = Lib.findBin(col2[i] + col2dv.minDiff / 2, col2vals);

for(j = 0; j &lt; arrayVarNames.length; j++) {
    arrayVarName = arrayVarNames[j];
    arrayVar = trace[arrayVarName];
    newArray = newArrays[j];
    newArray[i2][i1] = arrayVar[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.findExactDates" id="apidoc.element.plotly.js.index.findExactDates">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>findExactDates
        <span class="apidocSignatureSpan">(data, calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findExactDates = function (data, calendar) {
    var exactYears = 0,
        exactMonths = 0,
        exactDays = 0,
        blankCount = 0,
        d,
        di;

    var calInstance = (
        isWorldCalendar(calendar) &amp;&amp;
        Registry.getComponentMethod('calendars', 'getCal')(calendar)
    );

    for(var i = 0; i &lt; data.length; i++) {
        di = data[i];

        // not date data at all
        if(!isNumeric(di)) {
            blankCount ++;
            continue;
        }

        // not an exact date
        if(di % ONEDAY) continue;

        if(calInstance) {
            try {
                d = calInstance.fromJD(di / ONEDAY + EPOCHJD);
                if(d.day() === 1) {
                    if(d.month() === 1) exactYears++;
                    else exactMonths++;
                }
                else exactDays++;
            }
            catch(e) {
                // invalid date in this calendar - ignore it here.
            }
        }
        else {
            d = new Date(di);
            if(d.getUTCDate() === 1) {
                if(d.getUTCMonth() === 0) exactYears++;
                else exactMonths++;
            }
            else exactDays++;
        }
    }
    exactMonths += exactYears;
    exactDays += exactMonths;

    var dataCount = data.length - blankCount;

    return {
        exactYears: exactYears / dataCount,
        exactMonths: exactMonths / dataCount,
        exactDays: exactDays / dataCount
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
}
return binStart;
}


function autoShiftMonthBins(binStart, data, dtick, dataMin, calendar) {
var stats = Lib.<span class="apidocCodeKeywordSpan">findExactDates</span>(data, calendar);
// number of data points that needs to be an exact value
// to shift that increment to (near) the bin center
var threshold = 0.8;

if(stats.exactDays &gt; threshold) {
    var numMonths = Number(dtick.substr(1));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.formatDate" id="apidoc.element.plotly.js.index.formatDate">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>formatDate
        <span class="apidocSignatureSpan">(x, fmt, tr, calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatDate = function (x, fmt, tr, calendar) {
    var headStr,
        dateStr;

    calendar = isWorldCalendar(calendar) &amp;&amp; calendar;

    if(fmt) return modDateFormat(fmt, x, calendar);

    if(calendar) {
        try {
            var dateJD = Math.floor((x + 0.05) / ONEDAY) + EPOCHJD,
                cDate = Registry.getComponentMethod('calendars', 'getCal')(calendar)
                    .fromJD(dateJD);

            if(tr === 'y') dateStr = yearFormatWorld(cDate);
            else if(tr === 'm') dateStr = monthFormatWorld(cDate);
            else if(tr === 'd') {
                headStr = yearFormatWorld(cDate);
                dateStr = dayFormatWorld(cDate);
            }
            else {
                headStr = yearMonthDayFormatWorld(cDate);
                dateStr = formatTime(x, tr);
            }
        }
        catch(e) { return 'Invalid'; }
    }
    else {
        var d = new Date(Math.floor(x + 0.05));

        if(tr === 'y') dateStr = yearFormat(d);
        else if(tr === 'm') dateStr = monthFormat(d);
        else if(tr === 'd') {
            headStr = yearFormat(d);
            dateStr = dayFormat(d);
        }
        else {
            headStr = yearMonthDayFormat(d);
            dateStr = formatTime(x, tr);
        }
    }

    return dateStr + (headStr ? '\n' + headStr : '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
dateStr, h, m, s, msec10, d;

    if(isWorldCalendar(calendar)) {
var dateJD = Math.floor(msRounded / ONEDAY) + EPOCHJD,
    timeMs = Math.floor(mod(ms, ONEDAY));
try {
    dateStr = Registry.getComponentMethod('calendars', 'getCal')(calendar)
        .fromJD(dateJD).<span class="apidocCodeKeywordSpan">formatDate</span>('yyyy-mm-dd');
}
catch(e) {
    // invalid date in this calendar - fall back to Gyyyy-mm-dd
    dateStr = utcFormat('G%Y-%m-%d')(new Date(msRounded));
}

// yyyy does NOT guarantee 4-digit years. YYYY mostly does, but does
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.getPlotDiv" id="apidoc.element.plotly.js.index.getPlotDiv">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>getPlotDiv
        <span class="apidocSignatureSpan">(el)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPlotDiv = function (el) {
    for(; el &amp;&amp; el.removeAttribute; el = el.parentNode) {
        if(lib.isPlotDiv(el)) return el;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
_context.style('pointer-events', 'all');
        }

        if(_callback) _callback.call(that);
    }

    if(tex) {
        var gd = Lib.<span class="apidocCodeKeywordSpan">getPlotDiv</span>(that.node());
        ((gd &amp;&amp; gd._promises) || []).push(new Promise(function(resolve) {
that.style({visibility: 'hidden'});
var config = {fontSize: parseInt(that.style('font-size'), 10)};

texToSVG(tex[2], config, function(_svgEl, _glyphDefs, _svgBBox) {
    parent.selectAll('svg.' + svgClass).remove();
    parent.selectAll('g.' + svgClass + '-group').remove();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.identity" id="apidoc.element.plotly.js.index.identity">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>identity
        <span class="apidocSignatureSpan">(d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function identity(d) { return d; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.incrementMonth" id="apidoc.element.plotly.js.index.incrementMonth">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>incrementMonth
        <span class="apidocSignatureSpan">(ms, dMonth, calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">incrementMonth = function (ms, dMonth, calendar) {
    calendar = isWorldCalendar(calendar) &amp;&amp; calendar;

    // pull time out and operate on pure dates, then add time back at the end
    // this gives maximum precision - not that we *normally* care if we're
    // incrementing by month, but better to be safe!
    var timeMs = mod(ms, ONEDAY);
    ms = Math.round(ms - timeMs);

    if(calendar) {
        try {
            var dateJD = Math.round(ms / ONEDAY) + EPOCHJD,
                calInstance = Registry.getComponentMethod('calendars', 'getCal')(calendar),
                cDate = calInstance.fromJD(dateJD);

            if(dMonth % 12) calInstance.add(cDate, dMonth, 'm');
            else calInstance.add(cDate, dMonth / 12, 'y');

            return (cDate.toJD() - EPOCHJD) * ONEDAY + timeMs;
        }
        catch(e) {
            logError('invalid ms ' + ms + ' in calendar ' + calendar);
            // then keep going in gregorian even though the result will be 'Invalid'
        }
    }

    var y = new Date(ms + THREEDAYS);
    return y.setUTCMonth(y.getUTCMonth() + dMonth) + timeMs - THREEDAYS;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(isNumeric(dtick)) return x + axSign * dtick;

// everything else is a string, one character plus a number
var tType = dtick.charAt(0),
    dtSigned = axSign * Number(dtick.substr(1));

// Dates: months (or years - see Lib.incrementMonth)
if(tType === 'M') return Lib.<span class="apidocCodeKeywordSpan">incrementMonth</span>(x, dtSigned, calendar);

// Log scales: Linear, Digits
else if(tType === 'L') return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10;

// log10 of 2,5,10, or all digits (logs just have to be
// close enough to round)
else if(tType === 'D') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.init2dArray" id="apidoc.element.plotly.js.index.init2dArray">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>init2dArray
        <span class="apidocSignatureSpan">(rowLength, colLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init2dArray = function (rowLength, colLength) {
    var array = new Array(rowLength);
    for(var i = 0; i &lt; rowLength; i++) array[i] = new Array(colLength);
    return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var col1dv = Lib.distinctVals(col1),
    col1vals = col1dv.vals,
    col2dv = Lib.distinctVals(col2),
    col2vals = col2dv.vals,
    newArrays = [];

for(i = 0; i &lt; arrayVarNames.length; i++) {
    newArrays[i] = Lib.<span class="apidocCodeKeywordSpan">init2dArray</span>(col2vals.length, col1vals.length);
}

var i1, i2, text;

if(hasColumnText) text = Lib.init2dArray(col2vals.length, col1vals.length);

for(i = 0; i &lt; colLen; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.interp" id="apidoc.element.plotly.js.index.interp">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>interp
        <span class="apidocSignatureSpan">(arr, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interp = function (arr, n) {
    if(!isNumeric(n)) throw 'n should be a finite number';
    n = n * arr.length - 0.5;
    if(n &lt; 0) return arr[0];
    if(n &gt; arr.length - 1) return arr[arr.length - 1];
    var frac = n % 1;
    return frac * arr[Math.ceil(n)] + (1 - frac) * arr[Math.floor(n)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.isArray" id="apidoc.element.plotly.js.index.isArray">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>isArray
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isArray(a) {
    return Array.isArray(a) || ab.isView(a);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/


'use strict';

// similar to Lib.mergeArray, but using inside a loop
module.exports = function arrayToCalcItem(traceAttr, calcItem, calcAttr, i) {
    if(Array.<span class="apidocCodeKeywordSpan">isArray</span>(traceAttr)) calcItem[calcAttr] = traceAttr[i];
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.isD3Selection" id="apidoc.element.plotly.js.index.isD3Selection">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>isD3Selection
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isD3Selection = function (obj) {
    return obj &amp;&amp; (typeof obj.classed === 'function');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    return hoverLabel.node();
};

fx.loneUnhover = function(containerOrSelection) {
    // duck type whether the arg is a d3 selection because ie9 doesn't
    // handle instanceof like modern browsers do.
    var selection = Lib.<span class="apidocCodeKeywordSpan">isD3Selection</span>(containerOrSelection) ?
            containerOrSelection :
            d3.select(containerOrSelection);

    selection.selectAll('g.hovertext').remove();
    selection.selectAll('.spikeline').remove();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.isDateTime" id="apidoc.element.plotly.js.index.isDateTime">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>isDateTime
        <span class="apidocSignatureSpan">(s, calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDateTime = function (s, calendar) {
    return (exports.dateTime2ms(s, calendar) !== BADNUM);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        // NOTE: if someone puts in a year as a number rather than a string,
        // this will mistakenly convert it thinking it's milliseconds from 1970
        // that is: '2012' -&gt; Jan. 1, 2012, but 2012 -&gt; 2012 epoch milliseconds
        v = exports.ms2DateTimeLocal(+v);
        if(!v &amp;&amp; dflt !== undefined) return dflt;
    }
    else if(!exports.<span class="apidocCodeKeywordSpan">isDateTime</span>(v, calendar)) {
        logError('unrecognized date', v);
        return dflt;
    }
    return v;
};

/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.isIE" id="apidoc.element.plotly.js.index.isIE">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>isIE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isIE = function () {
    return typeof window.navigator.msSaveBlob !== 'undefined';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// see comments within svgtoimg for additional
//   discussion of problems with IE
//   can now draw to canvas, but CORS tainted canvas
//   does not allow toDataURL
//   svg format will work though
if(Lib.<span class="apidocCodeKeywordSpan">isIE</span>() &amp;&amp; opts.format !== 'svg') {
    reject(new Error('Sorry IE does not support downloading from canvas. Try {format:\'svg\'} instead.'));
}

gd._snapshotInProgress = true;
var promise = toImage(gd, opts);

var filename = opts.filename || gd.fn || 'newplot';
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.isJSDate" id="apidoc.element.plotly.js.index.isJSDate">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>isJSDate
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isJSDate = function (v) {
    return typeof v === 'object' &amp;&amp; v !== null &amp;&amp; typeof v.getTime === 'function';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * make now will cover all possibilities. mostly this will all be taken
 * care of in initial parsing, should only be an issue for hand-entered data
 * currently (2016) this range is:
 *   1946-2045
 */
exports.dateTime2ms = function(s, calendar) {
// first check if s is a date object
if(exports.<span class="apidocCodeKeywordSpan">isJSDate</span>(s)) {
    // Convert to the UTC milliseconds that give the same
    // hours as this date has in the local timezone
    s = Number(s) - s.getTimezoneOffset() * ONEMIN;
    if(s &gt;= MIN_MS &amp;&amp; s &lt;= MAX_MS) return s;
    return BADNUM;
}
// otherwise only accept strings and numbers
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.isPlainObject" id="apidoc.element.plotly.js.index.isPlainObject">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>isPlainObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPlainObject(obj) {

    // We need to be a little less strict in the `imagetest` container because
    // of how async image requests are handled.
    //
    // N.B. isPlainObject(new Constructor()) will return true in `imagetest`
    if(window &amp;&amp; window.process &amp;&amp; window.process.versions) {
        return Object.prototype.toString.call(obj) === '[object Object]';
    }

    return (
        Object.prototype.toString.call(obj) === '[object Object]' &amp;&amp;
        Object.getPrototypeOf(obj) === Object.prototype
    );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
    }

    var annotationsLen = Array.isArray(layout.annotations) ? layout.annotations.length : 0;
    for(i = 0; i &lt; annotationsLen; i++) {
var ann = layout.annotations[i];

if(!Lib.<span class="apidocCodeKeywordSpan">isPlainObject</span>(ann)) continue;

if(ann.ref) {
    if(ann.ref === 'paper') {
        ann.xref = 'paper';
        ann.yref = 'paper';
    }
    else if(ann.ref === 'data') {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.isPlotDiv" id="apidoc.element.plotly.js.index.isPlotDiv">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>isPlotDiv
        <span class="apidocSignatureSpan">(el)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPlotDiv = function (el) {
    var el3 = d3.select(el);
    return el3.node() instanceof HTMLElement &amp;&amp;
        el3.size() &amp;&amp;
        el3.classed('js-plotly-plot');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
return false;
};

// get the parent Plotly plot of any element. Whoo jquery-free tree climbing!
lib.getPlotDiv = function(el) {
for(; el &amp;&amp; el.removeAttribute; el = el.parentNode) {
    if(lib.<span class="apidocCodeKeywordSpan">isPlotDiv</span>(el)) return el;
}
};

lib.isPlotDiv = function(el) {
var el3 = d3.select(el);
return el3.node() instanceof HTMLElement &amp;&amp;
    el3.size() &amp;&amp;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.len" id="apidoc.element.plotly.js.index.len">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>len
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">len = function (data) {
    return exports.aggNums(function(a) { return a + 1; }, 0, data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * even need to use aggNums instead of .length, to toss out non-numerics
 */
exports.len = function(data) {
return exports.aggNums(function(a) { return a + 1; }, 0, data);
};

exports.mean = function(data, len) {
if(!len) len = exports.<span class="apidocCodeKeywordSpan">len</span>(data);
return exports.aggNums(function(a, b) { return a + b; }, 0, data) / len;
};

exports.variance = function(data, len, mean) {
if(!len) len = exports.len(data);
if(!isNumeric(mean)) mean = exports.mean(data, len);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.log" id="apidoc.element.plotly.js.index.log">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function () {
    if(config.logging &gt; 1) {
        var messages = ['LOG:'];

        for(var i = 0; i &lt; arguments.length; i++) {
            messages.push(arguments[i]);
        }

        apply(console.trace || console.log, messages);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {string} thisType
 * @param {array of strings} categoriesIn all the categories this type is in,
 *     tested by calls: traceIs(trace, oneCategory)
 * @param {object} meta meta information about the trace type
 */
exports.register = function(_module, thisType, categoriesIn, meta) {
if(exports.modules[thisType]) {
    Loggers.<span class="apidocCodeKeywordSpan">log</span>('Type ' + thisType + ' already registered');
    return;
}

var categoryObj = {};
for(var i = 0; i &lt; categoriesIn.length; i++) {
    categoryObj[categoriesIn[i]] = true;
    exports.allCategories[categoriesIn[i]] = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.mean" id="apidoc.element.plotly.js.index.mean">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>mean
        <span class="apidocSignatureSpan">(data, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mean = function (data, len) {
    if(!len) len = exports.len(data);
    return exports.aggNums(function(a, b) { return a + b; }, 0, data) / len;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.mean = function(data, len) {
    if(!len) len = exports.len(data);
    return exports.aggNums(function(a, b) { return a + b; }, 0, data) / len;
};

exports.variance = function(data, len, mean) {
    if(!len) len = exports.len(data);
    if(!isNumeric(mean)) mean = exports.<span class="apidocCodeKeywordSpan">mean</span>(data, len);

    return exports.aggNums(function(a, b) {
        return a + Math.pow(b - mean, 2);
    }, 0, data) / len;
};

exports.stdev = function(data, len, mean) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.mergeArray" id="apidoc.element.plotly.js.index.mergeArray">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>mergeArray
        <span class="apidocSignatureSpan">(traceAttr, cd, cdAttr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeArray = function (traceAttr, cd, cdAttr) {
    if(Array.isArray(traceAttr)) {
        var imax = Math.min(traceAttr.length, cd.length);
        for(var i = 0; i &lt; imax; i++) cd[i][cdAttr] = traceAttr[i];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.minExtend" id="apidoc.element.plotly.js.index.minExtend">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>minExtend
        <span class="apidocSignatureSpan">(obj1, obj2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">minExtend = function (obj1, obj2) {
    var objOut = {};
    if(typeof obj2 !== 'object') obj2 = {};
    var arrayLen = 3,
        keys = Object.keys(obj1),
        i,
        k,
        v;
    for(i = 0; i &lt; keys.length; i++) {
        k = keys[i];
        v = obj1[k];
        if(k.charAt(0) === '_' || typeof v === 'function') continue;
        else if(k === 'module') objOut[k] = v;
        else if(Array.isArray(v)) objOut[k] = v.slice(0, arrayLen);
        else if(v &amp;&amp; (typeof v === 'object')) objOut[k] = lib.minExtend(obj1[k], obj2[k]);
        else objOut[k] = v;
    }

    keys = Object.keys(obj2);
    for(i = 0; i &lt; keys.length; i++) {
        k = keys[i];
        v = obj2[k];
        if(typeof v !== 'object' || !(k in objOut) || typeof objOut[k] !== 'object') {
            objOut[k] = v;
        }
    }

    return objOut;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    v;
for(i = 0; i &lt; keys.length; i++) {
    k = keys[i];
    v = obj1[k];
    if(k.charAt(0) === '_' || typeof v === 'function') continue;
    else if(k === 'module') objOut[k] = v;
    else if(Array.isArray(v)) objOut[k] = v.slice(0, arrayLen);
    else if(v &amp;&amp; (typeof v === 'object')) objOut[k] = lib.<span class="apidocCodeKeywordSpan">minExtend</span>(obj1[k], obj2[k]);
    else objOut[k] = v;
}

keys = Object.keys(obj2);
for(i = 0; i &lt; keys.length; i++) {
    k = keys[i];
    v = obj2[k];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.mod" id="apidoc.element.plotly.js.index.mod">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>mod
        <span class="apidocSignatureSpan">(v, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mod(v, d) {
    var out = v % d;
    return out &lt; 0 ? out + d : out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    else if(tType === 'L') return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10;

    // log10 of 2,5,10, or all digits (logs just have to be
    // close enough to round)
    else if(tType === 'D') {
        var tickset = (dtick === 'D2') ? roundLog2 : roundLog1,
            x2 = x + axSign * 0.01,
            frac = Lib.roundUp(Lib.<span class="apidocCodeKeywordSpan">mod</span>(x2, 1), tickset, axrev);

        return Math.floor(x2) +
            Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;
    }
    else throw 'unrecognized dtick ' + String(dtick);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.ms2DateTime" id="apidoc.element.plotly.js.index.ms2DateTime">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>ms2DateTime
        <span class="apidocSignatureSpan">(ms, r, calendar)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ms2DateTime = function (ms, r, calendar) {
    if(typeof ms !== 'number' || !(ms &gt;= MIN_MS &amp;&amp; ms &lt;= MAX_MS)) return BADNUM;

    if(!r) r = 0;

    var msecTenths = Math.floor(mod(ms + 0.05, 1) * 10),
        msRounded = Math.round(ms - msecTenths / 10),
        dateStr, h, m, s, msec10, d;

    if(isWorldCalendar(calendar)) {
        var dateJD = Math.floor(msRounded / ONEDAY) + EPOCHJD,
            timeMs = Math.floor(mod(ms, ONEDAY));
        try {
            dateStr = Registry.getComponentMethod('calendars', 'getCal')(calendar)
                .fromJD(dateJD).formatDate('yyyy-mm-dd');
        }
        catch(e) {
            // invalid date in this calendar - fall back to Gyyyy-mm-dd
            dateStr = utcFormat('G%Y-%m-%d')(new Date(msRounded));
        }

        // yyyy does NOT guarantee 4-digit years. YYYY mostly does, but does
        // other things for a few calendars, so we can't trust it. Just pad
        // it manually (after the '-' if there is one)
        if(dateStr.charAt(0) === '-') {
            while(dateStr.length &lt; 11) dateStr = '-0' + dateStr.substr(1);
        }
        else {
            while(dateStr.length &lt; 10) dateStr = '0' + dateStr;
        }

        // TODO: if this is faster, we could use this block for extracting
        // the time components of regular gregorian too
        h = (r &lt; NINETYDAYS) ? Math.floor(timeMs / ONEHOUR) : 0;
        m = (r &lt; NINETYDAYS) ? Math.floor((timeMs % ONEHOUR) / ONEMIN) : 0;
        s = (r &lt; THREEHOURS) ? Math.floor((timeMs % ONEMIN) / ONESEC) : 0;
        msec10 = (r &lt; FIVEMIN) ? (timeMs % ONESEC) * 10 + msecTenths : 0;
    }
    else {
        d = new Date(msRounded);

        dateStr = utcFormat('%Y-%m-%d')(d);

        // &lt;90 days: add hours and minutes - never *only* add hours
        h = (r &lt; NINETYDAYS) ? d.getUTCHours() : 0;
        m = (r &lt; NINETYDAYS) ? d.getUTCMinutes() : 0;
        // &lt;3 hours: add seconds
        s = (r &lt; THREEHOURS) ? d.getUTCSeconds() : 0;
        // &lt;5 minutes: add ms (plus one extra digit, this is msec*10)
        msec10 = (r &lt; FIVEMIN) ? d.getUTCMilliseconds() * 10 + msecTenths : 0;
    }

    return includeTime(dateStr, h, m, s, msec10);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.ms2DateTimeLocal" id="apidoc.element.plotly.js.index.ms2DateTimeLocal">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>ms2DateTimeLocal
        <span class="apidocSignatureSpan">(ms)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ms2DateTimeLocal = function (ms) {
    if(!(ms &gt;= MIN_MS + ONEDAY &amp;&amp; ms &lt;= MAX_MS - ONEDAY)) return BADNUM;

    var msecTenths = Math.floor(mod(ms + 0.05, 1) * 10),
        d = new Date(Math.round(ms - msecTenths / 10)),
        dateStr = d3.time.format('%Y-%m-%d')(d),
        h = d.getHours(),
        m = d.getMinutes(),
        s = d.getSeconds(),
        msec10 = d.getUTCMilliseconds() * 10 + msecTenths;

    return includeTime(dateStr, h, m, s, msec10);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        logError('JS Dates and milliseconds are incompatible with world calendars', v);
        return dflt;
    }

    // NOTE: if someone puts in a year as a number rather than a string,
    // this will mistakenly convert it thinking it's milliseconds from 1970
    // that is: '2012' -&gt; Jan. 1, 2012, but 2012 -&gt; 2012 epoch milliseconds
    v = exports.<span class="apidocCodeKeywordSpan">ms2DateTimeLocal</span>(+v);
    if(!v &amp;&amp; dflt !== undefined) return dflt;
}
else if(!exports.isDateTime(v, calendar)) {
    logError('unrecognized date', v);
    return dflt;
}
return v;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.nestedProperty" id="apidoc.element.plotly.js.index.nestedProperty">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>nestedProperty
        <span class="apidocSignatureSpan">(container, propStr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function nestedProperty(container, propStr) {
    if(isNumeric(propStr)) propStr = String(propStr);
    else if(typeof propStr !== 'string' ||
            propStr.substr(propStr.length - 4) === '[-1]') {
        throw 'bad property string';
    }

    var j = 0,
        propParts = propStr.split('.'),
        indexed,
        indices,
        i;

    // check for parts of the nesting hierarchy that are numbers (ie array elements)
    while(j &lt; propParts.length) {
        // look for non-bracket chars, then any number of [##] blocks
        indexed = String(propParts[j]).match(/^([^\[\]]*)((\[\-?[0-9]*\])+)$/);
        if(indexed) {
            if(indexed[1]) propParts[j] = indexed[1];
            // allow propStr to start with bracketed array indices
            else if(j === 0) propParts.splice(0, 1);
            else throw 'bad property string';

            indices = indexed[2]
                .substr(1, indexed[2].length - 2)
                .split('][');

            for(i = 0; i &lt; indices.length; i++) {
                j++;
                propParts.splice(j, 0, Number(indices[i]));
            }
        }
        j++;
    }

    if(typeof container !== 'object') {
        return badContainer(container, propStr, propParts);
    }

    return {
        set: npSet(container, propParts, propStr),
        get: npGet(container, propParts),
        astr: propStr,
        parts: propParts,
        obj: container
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * you can also swap other things than x/y by providing part1 and part2
 */
lib.swapAttrs = function(cont, attrList, part1, part2) {
    if(!part1) part1 = 'x';
    if(!part2) part2 = 'y';
    for(var i = 0; i &lt; attrList.length; i++) {
        var attr = attrList[i],
            xp = lib.<span class="apidocCodeKeywordSpan">nestedProperty</span>(cont, attr.replace('?', part1)),
            yp = lib.nestedProperty(cont, attr.replace('?', part2)),
            temp = xp.get();
        xp.set(yp.get());
        yp.set(temp);
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.noneOrAll" id="apidoc.element.plotly.js.index.noneOrAll">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>noneOrAll
        <span class="apidocSignatureSpan">(containerIn, containerOut, attrList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noneOrAll = function (containerIn, containerOut, attrList) {
<span class="apidocCodeCommentSpan">    /**
     * some attributes come together, so if you have one of them
     * in the input, you should copy the default values of the others
     * to the input as well.
     */
</span>    if(!containerIn) return;

    var hasAny = false,
        hasAll = true,
        i,
        val;

    for(i = 0; i &lt; attrList.length; i++) {
        val = containerIn[attrList[i]];
        if(val !== undefined &amp;&amp; val !== null) hasAny = true;
        else hasAll = false;
    }

    if(hasAny &amp;&amp; !hasAll) {
        for(i = 0; i &lt; attrList.length; i++) {
            containerIn[attrList[i]] = containerOut[attrList[i]];
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    coerce(axLetter + 'anchor');

    // xshift, yshift
    coerce(axLetter + 'shift');
}

// if you have one coordinate you should have both
Lib.<span class="apidocCodeKeywordSpan">noneOrAll</span>(annIn, annOut, ['x', 'y']);

if(showArrow) {
    coerce('arrowcolor', borderOpacity ? annOut.bordercolor : Color.defaultLine);
    coerce('arrowhead');
    coerce('arrowsize');
    coerce('arrowwidth', ((borderOpacity &amp;&amp; borderWidth) || 1) * 2);
    coerce('standoff');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.noop" id="apidoc.element.plotly.js.index.noop">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>noop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function noop() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.notifier" id="apidoc.element.plotly.js.index.notifier">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>notifier
        <span class="apidocSignatureSpan">(text, displayLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notifier = function (text, displayLength) {
    if(NOTEDATA.indexOf(text) !== -1) return;

    NOTEDATA.push(text);

    var ts = 1000;
    if(isNumeric(displayLength)) ts = displayLength;
    else if(displayLength === 'long') ts = 3000;

    var notifierContainer = d3.select('body')
        .selectAll('.plotly-notifier')
        .data([0]);
    notifierContainer.enter()
        .append('div')
        .classed('plotly-notifier', true);

    var notes = notifierContainer.selectAll('.notifier-note').data(NOTEDATA);

    function killNote(transition) {
        transition
            .duration(700)
            .style('opacity', 0)
            .each('end', function(thisText) {
                var thisIndex = NOTEDATA.indexOf(thisText);
                if(thisIndex !== -1) NOTEDATA.splice(thisIndex, 1);
                d3.select(this).remove();
            });
    }

    notes.enter().append('div')
        .classed('notifier-note', true)
        .style('opacity', 0)
        .each(function(thisText) {
            var note = d3.select(this);

            note.append('button')
                .classed('notifier-close', true)
                .html('&amp;times;')
                .on('click', function() {
                    note.transition().call(killNote);
                });

            var p = note.append('p');
            var lines = thisText.split(/&lt;br\s*\/?&gt;/g);
            for(var i = 0; i &lt; lines.length; i++) {
                if(i) p.append('br');
                p.append('span').text(lines[i]);
            }

            note.transition()
                    .duration(700)
                    .style('opacity', 1)
                .transition()
                    .delay(ts)
                    .call(killNote);
        });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
modeBarButtons.toImage = {
    name: 'toImage',
    title: 'Download plot as a png',
    icon: Icons.camera,
    click: function(gd) {
var format = 'png';

Lib.<span class="apidocCodeKeywordSpan">notifier</span>('Taking snapshot - this may take a few seconds', 'long'
;);

if(Lib.isIE()) {
    Lib.notifier('IE only supports svg.  Changing format to svg.', 'long');
    format = 'svg';
}

downloadImage(gd, {'format': format})
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.numSeparate" id="apidoc.element.plotly.js.index.numSeparate">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>numSeparate
        <span class="apidocSignatureSpan">(value, separators, separatethousands)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numSeparate = function (value, separators, separatethousands) {
    if(!separatethousands) separatethousands = false;

    if(typeof separators !== 'string' || separators.length === 0) {
        throw new Error('Separator string required for formatting!');
    }

    if(typeof value === 'number') {
        value = String(value);
    }

    var thousandsRe = /(\d+)(\d{3})/,
        decimalSep = separators.charAt(0),
        thouSep = separators.charAt(1);

    var x = value.split('.'),
        x1 = x[0],
        x2 = x.length &gt; 1 ? decimalSep + x[1] : '';

    // Years are ignored for thousands separators
    if(thouSep &amp;&amp; (x.length &gt; 1 || x1.length &gt; 4 || separatethousands)) {
        while(thousandsRe.test(x1)) {
            x1 = x1.replace(thousandsRe, '$1' + thouSep + '$2');
        }
    }

    return x1 + x2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   return data;
};

/**
* Converts value to string separated by the provided separators.
*
* @example
* lib.<span class="apidocCodeKeywordSpan">numSeparate</span>(2016, '.,');
* // returns '2016'
*
* @example
* lib.numSeparate(3000, '.,', true);
* // returns '3,000'
*
* @example
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.objectFromPath" id="apidoc.element.plotly.js.index.objectFromPath">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>objectFromPath
        <span class="apidocSignatureSpan">(path, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectFromPath = function (path, value) {
    var keys = path.split('.'),
        tmpObj,
        obj = tmpObj = {};

    for(var i = 0; i &lt; keys.length; i++) {
        var key = keys[i];
        var el = null;

        var parts = keys[i].match(/(.*)\[([0-9]+)\]/);

        if(parts) {
            key = parts[1];
            el = parts[2];

            tmpObj = tmpObj[key] = [];

            if(i === keys.length - 1) {
                tmpObj[el] = value;
            } else {
                tmpObj[el] = {};
            }

            tmpObj = tmpObj[el];
        } else {

            if(i === keys.length - 1) {
                tmpObj[key] = value;
            } else {
                tmpObj[key] = {};
            }

            tmpObj = tmpObj[key];
        }
    }

    return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Converts a string path to an object.
*
* When given a string containing an array element, it will create a `null`
* filled array of the given size.
*
* @example
* lib.<span class="apidocCodeKeywordSpan">objectFromPath</span>('nested.test[2].path', 'value');
* // returns { nested: { test: [null, null, { path: 'value' }]}
*
* @param   {string}    path to nested value
* @param   {*}         any value to be set
*
* @return {Object} the constructed object with a full nested path
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.pauseEvent" id="apidoc.element.plotly.js.index.pauseEvent">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>pauseEvent
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pauseEvent = function (e) {
    if(e.stopPropagation) e.stopPropagation();
    if(e.preventDefault) e.preventDefault();
    e.cancelBubble = true;
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// but _ ensures this setting won't leave their page
if(!gd._context.scrollZoom &amp;&amp; !fullLayout._enablescrollzoom) {
    return;
}

// If a transition is in progress, then disable any behavior:
if(gd._transitioningWithDuration) {
    return Lib.<span class="apidocCodeKeywordSpan">pauseEvent</span>(e);
}

var pc = gd.querySelector('.plotly');

recomputeAxisLists();

// if the plot has scrollbars (more than a tiny excess)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.pushUnique" id="apidoc.element.plotly.js.index.pushUnique">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>pushUnique
        <span class="apidocSignatureSpan">(array, item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pushUnique(array, item) {
    if(item instanceof RegExp) {
        var itemStr = item.toString(),
            i;
        for(i = 0; i &lt; array.length; i++) {
            if(array[i] instanceof RegExp &amp;&amp; array[i].toString() === itemStr) {
                return array;
            }
        }
        array.push(item);
    }
    else if(item &amp;&amp; array.indexOf(item) === -1) array.push(item);

    return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function pushModule(fullTrace) {
    dataOut.push(fullTrace);

    var _module = fullTrace._module;
    if(!_module) return;

    Lib.<span class="apidocCodeKeywordSpan">pushUnique</span>(modules, _module);
    Lib.pushUnique(basePlotModules, fullTrace._module.basePlotModule);

    cnt++;
}

var carpetIndex = {};
var carpetDependents = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.randstr" id="apidoc.element.plotly.js.index.randstr">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>randstr
        <span class="apidocSignatureSpan">(existing, bits, base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function randstr(existing, bits, base) {
<span class="apidocCodeCommentSpan">    /*
     * Include number of bits, the base of the string you want
     * and an optional array of existing strings to avoid.
     */
</span>    if(!base) base = 16;
    if(bits === undefined) bits = 24;
    if(bits &lt;= 0) return '0';

    var digits = Math.log(Math.pow(2, bits)) / Math.log(base),
        res = '',
        i,
        b,
        x;

    for(i = 2; digits === Infinity; i *= 2) {
        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;
    }

    var rem = digits - Math.floor(digits);

    for(i = 0; i &lt; Math.floor(digits); i++) {
        x = Math.floor(Math.random() * base).toString(base);
        res = x + res;
    }

    if(rem) {
        b = Math.pow(base, rem);
        x = Math.floor(Math.random() * b).toString(base);
        res = x + res;
    }

    var parsed = parseInt(res, base);
    if((existing &amp;&amp; (existing.indexOf(res) &gt; -1)) ||
         (parsed !== Infinity &amp;&amp; parsed &gt;= Math.pow(2, bits))) {
        return randstr(existing, bits, base);
    }
    else return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function cleanEscapesForTex(s) {
return s.replace(/(&lt;|&amp;lt;|&amp;#60;)/g, '\\lt ')
    .replace(/(&gt;|&amp;gt;|&amp;#62;)/g, '\\gt ');
}

function texToSVG(_texString, _config, _callback) {
var randomID = 'math-output-' + Lib.<span class="apidocCodeKeywordSpan">randstr</span>([], 64);
var tmpDiv = d3.select('body').append('div')
    .attr({id: randomID})
    .style({visibility: 'hidden', position: 'absolute'})
    .style({'font-size': _config.fontSize + 'px'})
    .text(cleanEscapesForTex(_texString));

MathJax.Hub.Queue(['Typeset', MathJax.Hub, tmpDiv.node()], function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.relinkPrivateKeys" id="apidoc.element.plotly.js.index.relinkPrivateKeys">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>relinkPrivateKeys
        <span class="apidocSignatureSpan">(toContainer, fromContainer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function relinkPrivateKeys(toContainer, fromContainer) {
    var keys = Object.keys(fromContainer || {});

    for(var i = 0; i &lt; keys.length; i++) {
        var k = keys[i],
            fromVal = fromContainer[k],
            toVal = toContainer[k];

        if(k.charAt(0) === '_' || typeof fromVal === 'function') {

            // if it already exists at this point, it's something
            // that we recreate each time around, so ignore it
            if(k in toContainer) continue;

            toContainer[k] = fromVal;
        }
        else if(isArray(fromVal) &amp;&amp; isArray(toVal) &amp;&amp; isPlainObject(fromVal[0])) {

            // recurse into arrays containers
            for(var j = 0; j &lt; fromVal.length; j++) {
                if(isPlainObject(fromVal[j]) &amp;&amp; isPlainObject(toVal[j])) {
                    relinkPrivateKeys(toVal[j], fromVal[j]);
                }
            }
        }
        else if(isPlainObject(fromVal) &amp;&amp; isPlainObject(toVal)) {

            // recurse into objects, but only if they still exist
            relinkPrivateKeys(toVal, fromVal);

            if(!Object.keys(toVal).length) delete toContainer[k];
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    // in case this array gets its defaults rebuilt independent of the whole layout,
    // relink the private keys just for this array.
    if(Lib.isArray(previousContOut)) {
        var len = Math.min(previousContOut.length, contOut.length);
        for(i = 0; i &lt; len; i++) {
            Lib.<span class="apidocCodeKeywordSpan">relinkPrivateKeys</span>(contOut[i], previousContOut[i]);
        }
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.removeElement" id="apidoc.element.plotly.js.index.removeElement">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>removeElement
        <span class="apidocSignatureSpan">(el)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeElement = function (el) {
    var elParent = el &amp;&amp; el.parentNode;
    if(elParent) elParent.removeChild(el);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.element.removeChild(this.element.firstChild);
}

this.hasLogo = false;
};

proto.destroy = function() {
Lib.<span class="apidocCodeKeywordSpan">removeElement</span>(this.container.querySelector('.modebar'));
};

function createModeBar(gd, buttons) {
var fullLayout = gd._fullLayout;

var modeBar = new ModeBar({
    graphInfo: gd,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.rotationMatrix" id="apidoc.element.plotly.js.index.rotationMatrix">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>rotationMatrix
        <span class="apidocSignatureSpan">(alpha)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rotationMatrix = function (alpha) {
    var a = alpha * Math.PI / 180;
    return [[Math.cos(a), -Math.sin(a), 0],
            [Math.sin(a), Math.cos(a), 0],
            [0, 0, 1]];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        [0, 0, 1]];
};

// rotate by alpha around (x,y)
exports.rotationXYMatrix = function(a, x, y) {
return exports.dot(
    exports.dot(exports.translationMatrix(x, y),
                exports.<span class="apidocCodeKeywordSpan">rotationMatrix</span>(a)),
    exports.translationMatrix(-x, -y));
};

// applies a 2D transformation matrix to either x and y params or an [x,y] array
exports.apply2DTransform = function(transform) {
return function() {
    var args = arguments;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.rotationXYMatrix" id="apidoc.element.plotly.js.index.rotationXYMatrix">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>rotationXYMatrix
        <span class="apidocSignatureSpan">(a, x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rotationXYMatrix = function (a, x, y) {
    return exports.dot(
        exports.dot(exports.translationMatrix(x, y),
                    exports.rotationMatrix(a)),
        exports.translationMatrix(-x, -y));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
tailX = annPosPx.x.tail + dx,
tailY = annPosPx.y.tail + dy,
textX = annPosPx.x.text + dx,
textY = annPosPx.y.text + dy,

// find the edge of the text box, where we'll start the arrow:
// create transform matrix to rotate the text box corners
transform = Lib.<span class="apidocCodeKeywordSpan">rotationXYMatrix</span>(textangle, textX, textY),
applyTransform = Lib.apply2DTransform(transform),
applyTransform2 = Lib.apply2DTransform2(transform),

// calculate and transform bounding box
width = +annTextBG.attr('width'),
height = +annTextBG.attr('height'),
xLeft = textX - 0.5 * width,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.roundUp" id="apidoc.element.plotly.js.index.roundUp">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>roundUp
        <span class="apidocSignatureSpan">(val, arrayIn, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">roundUp = function (val, arrayIn, reverse) {
    var low = 0,
        high = arrayIn.length - 1,
        mid,
        c = 0,
        dlow = reverse ? 0 : 1,
        dhigh = reverse ? 1 : 0,
        rounded = reverse ? Math.ceil : Math.floor;
    // c is just to avoid infinite loops if there's an error
    while(low &lt; high &amp;&amp; c++ &lt; 100) {
        mid = rounded((low + high) / 2);
        if(arrayIn[mid] &lt;= val) low = mid + dlow;
        else high = mid - dhigh;
    }
    return arrayIn[low];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// totally auto: scale off std deviation so the highest bin is
// somewhat taller than the total number of bins, but don't let
// the size get smaller than the 'nice' rounded down minimum
// difference between values
var distinctData = Lib.distinctVals(data),
    msexp = Math.pow(10, Math.floor(
        Math.log(distinctData.minDiff) / Math.LN10)),
    minSize = msexp * Lib.<span class="apidocCodeKeywordSpan">roundUp</span>(
        distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);
size0 = Math.max(minSize, 2 * Lib.stdev(data) /
    Math.pow(data.length, is2d ? 0.25 : 0.4));

// fallback if ax.d2c output BADNUMs
// e.g. when user try to plot categorical bins
// on a layout.xaxis.type: 'linear'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.simpleMap" id="apidoc.element.plotly.js.index.simpleMap">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>simpleMap
        <span class="apidocSignatureSpan">(array, func, x1, x2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">simpleMap = function (array, func, x1, x2) {
    var len = array.length,
        out = new Array(len);
    for(var i = 0; i &lt; len; i++) out[i] = func(array[i], x1, x2);
    return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var j, minpt, maxpt, minbest, maxbest, dp, dv,
    mbest = 0,
    axReverse = false;

if(ax.range) {
    var rng = Lib.<span class="apidocCodeKeywordSpan">simpleMap</span>(ax.range, ax.r2l);
    axReverse = rng[1] &lt; rng[0];
}

// one-time setting to easily reverse the axis
// when plotting from code
if(ax.autorange === 'reversed') {
    axReverse = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.smooth" id="apidoc.element.plotly.js.index.smooth">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>smooth
        <span class="apidocSignatureSpan">(arrayIn, FWHM)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">smooth = function (arrayIn, FWHM) {
    FWHM = Math.round(FWHM) || 0; // only makes sense for integers
    if(FWHM &lt; 2) return arrayIn;

    var alen = arrayIn.length,
        alen2 = 2 * alen,
        wlen = 2 * FWHM - 1,
        w = new Array(wlen),
        arrayOut = new Array(alen),
        i,
        j,
        k,
        v;

    // first make the window array
    for(i = 0; i &lt; wlen; i++) {
        w[i] = (1 - Math.cos(Math.PI * (i + 1) / FWHM)) / (2 * FWHM);
    }

    // now do the convolution
    for(i = 0; i &lt; alen; i++) {
        v = 0;
        for(j = 0; j &lt; wlen; j++) {
            k = i + j + 1 - FWHM;

            // multibounce
            if(k &lt; -alen) k -= alen2 * Math.round(k / alen2);
            else if(k &gt;= alen2) k -= alen2 * Math.floor(k / alen2);

            // single bounce
            if(k &lt; 0) k = - 1 - k;
            else if(k &gt;= alen) k = alen2 - 1 - k;

            v += arrayIn[k] * w[j];
        }
        arrayOut[i] = v;
    }

    return arrayOut;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.sorterAsc" id="apidoc.element.plotly.js.index.sorterAsc">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>sorterAsc
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sorterAsc = function (a, b) { return a - b; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.sorterDes" id="apidoc.element.plotly.js.index.sorterDes">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>sorterDes
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sorterDes = function (a, b) { return b - a; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.stdev" id="apidoc.element.plotly.js.index.stdev">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>stdev
        <span class="apidocSignatureSpan">(data, len, mean)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stdev = function (data, len, mean) {
    return Math.sqrt(exports.variance(data, len, mean));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // the size get smaller than the 'nice' rounded down minimum
    // difference between values
    var distinctData = Lib.distinctVals(data),
        msexp = Math.pow(10, Math.floor(
            Math.log(distinctData.minDiff) / Math.LN10)),
        minSize = msexp * Lib.roundUp(
            distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);
    size0 = Math.max(minSize, 2 * Lib.<span class="apidocCodeKeywordSpan">stdev</span>(data) /
        Math.pow(data.length, is2d ? 0.25 : 0.4));

    // fallback if ax.d2c output BADNUMs
    // e.g. when user try to plot categorical bins
    // on a layout.xaxis.type: 'linear'
    if(!isNumeric(size0)) size0 = 1;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.stripTrailingSlash" id="apidoc.element.plotly.js.index.stripTrailingSlash">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>stripTrailingSlash
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stripTrailingSlash = function (str) {
    if(str.substr(-1) === '/') return str.substr(0, str.length - 1);
    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.swapAttrs" id="apidoc.element.plotly.js.index.swapAttrs">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>swapAttrs
        <span class="apidocSignatureSpan">(cont, attrList, part1, part2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">swapAttrs = function (cont, attrList, part1, part2) {
    if(!part1) part1 = 'x';
    if(!part2) part2 = 'y';
    for(var i = 0; i &lt; attrList.length; i++) {
        var attr = attrList[i],
            xp = lib.nestedProperty(cont, attr.replace('?', part1)),
            yp = lib.nestedProperty(cont, attr.replace('?', part2)),
            temp = xp.get();
        xp.set(yp.get());
        yp.set(temp);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    (Object.keys(outer[innerStr]).length === 0);
}


// swap all the data and data attributes associated with x and y
exports.swapXYData = function(trace) {
var i;
Lib.<span class="apidocCodeKeywordSpan">swapAttrs</span>(trace, ['?', '?0', 'd?', '?bins'
;, 'nbins?', 'autobin?', '?src', 'error_?']);
if(Array.isArray(trace.z) &amp;&amp; Array.isArray(trace.z[0])) {
    if(trace.transpose) delete trace.transpose;
    else trace.transpose = true;
}
if(trace.error_x &amp;&amp; trace.error_y) {
    var errorY = trace.error_y,
        copyYstyle = ('copy_ystyle' in errorY) ? errorY.copy_ystyle :
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.syncOrAsync" id="apidoc.element.plotly.js.index.syncOrAsync">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>syncOrAsync
        <span class="apidocSignatureSpan">(sequence, arg, finalStep)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">syncOrAsync = function (sequence, arg, finalStep) {
    var ret, fni;

    function continueAsync() {
        return lib.syncOrAsync(sequence, arg, finalStep);
    }

    while(sequence.length) {
        fni = sequence.splice(0, 1)[0];
        ret = fni(arg);

        if(ret &amp;&amp; ret.then) {
            return ret.then(continueAsync)
                .then(undefined, lib.promiseError);
        }
    }

    return finalStep &amp;&amp; finalStep(arg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * this doesn't happen yet because we want to make sure
 * that it gets reported
 */
lib.syncOrAsync = function(sequence, arg, finalStep) {
    var ret, fni;

    function continueAsync() {
return lib.<span class="apidocCodeKeywordSpan">syncOrAsync</span>(sequence, arg, finalStep);
    }

    while(sequence.length) {
fni = sequence.splice(0, 1)[0];
ret = fni(arg);

if(ret &amp;&amp; ret.then) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.titleCase" id="apidoc.element.plotly.js.index.titleCase">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>titleCase
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">titleCase = function (s) {
    return s.charAt(0).toUpperCase() + s.substr(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.toLogRange" id="apidoc.element.plotly.js.index.toLogRange">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>toLogRange
        <span class="apidocSignatureSpan">(val, range)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toLogRange(val, range) {
    if(val &gt; 0) return Math.log(val) / Math.LN10;

    // move a negative value reference to a log axis - just put the
    // result at the lowest range value on the plot (or if the range also went negative,
    // one millionth of the top of the range)
    var newVal = Math.log(Math.min(range[0], range[1])) / Math.LN10;
    if(!isNumeric(newVal)) newVal = Math.log(Math.max(range[0], range[1])) / Math.LN10 - 6;
    return newVal;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.translationMatrix" id="apidoc.element.plotly.js.index.translationMatrix">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>translationMatrix
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">translationMatrix = function (x, y) {
    return [[1, 0, x], [0, 1, y], [0, 0, 1]];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        [Math.sin(a), Math.cos(a), 0],
        [0, 0, 1]];
};

// rotate by alpha around (x,y)
exports.rotationXYMatrix = function(a, x, y) {
return exports.dot(
    exports.dot(exports.<span class="apidocCodeKeywordSpan">translationMatrix</span>(x, y),
                exports.rotationMatrix(a)),
    exports.translationMatrix(-x, -y));
};

// applies a 2D transformation matrix to either x and y params or an [x,y] array
exports.apply2DTransform = function(transform) {
return function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.transposeRagged" id="apidoc.element.plotly.js.index.transposeRagged">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>transposeRagged
        <span class="apidocSignatureSpan">(z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transposeRagged = function (z) {
    var maxlen = 0,
        zlen = z.length,
        i,
        j;
    // Maximum row length:
    for(i = 0; i &lt; zlen; i++) maxlen = Math.max(maxlen, z[i].length);

    var t = new Array(maxlen);
    for(i = 0; i &lt; maxlen; i++) {
        t[i] = new Array(zlen);
        for(j = 0; j &lt; zlen; j++) t[i][j] = z[j][i];
    }

    return t;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(x[0].length) {
    // mat-vec or mat-mat
    out = new Array(len);
    for(i = 0; i &lt; len; i++) out[i] = exports.dot(x[i], y);
}
else if(y[0].length) {
    // vec-mat
    var yTranspose = exports.<span class="apidocCodeKeywordSpan">transposeRagged</span>(y);
    out = new Array(yTranspose.length);
    for(i = 0; i &lt; yTranspose.length; i++) out[i] = exports.dot(x, yTranspose[i]);
}
else {
    // vec-vec
    out = 0;
    for(i = 0; i &lt; len; i++) out += x[i] * y[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.validate" id="apidoc.element.plotly.js.index.validate">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>validate
        <span class="apidocSignatureSpan">(value, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (value, opts) {
    var valObject = exports.valObjects[opts.valType];

    if(opts.arrayOk &amp;&amp; Array.isArray(value)) return true;

    if(valObject.validateFunction) {
        return valObject.validateFunction(value, opts);
    }

    var failed = {},
        out = failed,
        propMock = { set: function(v) { out = v; } };

    // 'failed' just something mutable that won't be === anything else

    valObject.coerceFunction(value, propMock, failed, opts);
    return out !== failed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var items = opts.items;

        // when free length is off, input and declared lengths must match
        if(!opts.freeLength &amp;&amp; v.length !== items.length) return false;

        // valid when all input items are valid
        for(var i = 0; i &lt; v.length; i++) {
            var isItemValid = exports.<span class="apidocCodeKeywordSpan">validate</span>(v[i], opts.items[i]);

            if(!isItemValid) return false;
        }

        return true;
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.variance" id="apidoc.element.plotly.js.index.variance">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>variance
        <span class="apidocSignatureSpan">(data, len, mean)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">variance = function (data, len, mean) {
    if(!len) len = exports.len(data);
    if(!isNumeric(mean)) mean = exports.mean(data, len);

    return exports.aggNums(function(a, b) {
        return a + Math.pow(b - mean, 2);
    }, 0, data) / len;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   return exports.aggNums(function(a, b) {
       return a + Math.pow(b - mean, 2);
   }, 0, data) / len;
};

exports.stdev = function(data, len, mean) {
   return Math.sqrt(exports.<span class="apidocCodeKeywordSpan">variance</span>(data, len, mean));
};

/**
* interp() computes a percentile (quantile) for a given distribution.
* We interpolate the distribution (to compute quantiles, we follow method #10 here:
* http://www.amstat.org/publications/jse/v14n3/langford.html).
* Typically the index or rank (n * arr.length) may be non-integer.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.index.warn" id="apidoc.element.plotly.js.index.warn">
        function <span class="apidocSignatureSpan">plotly.js.index.</span>warn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">warn = function () {
    if(config.logging &gt; 0) {
        var messages = ['WARN:'];

        for(var i = 0; i &lt; arguments.length; i++) {
            messages.push(arguments[i]);
        }

        apply(console.trace || console.log, messages);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object||string} trace
 *  trace object with prop 'type' or trace type as a string
 * @return {object}
 *  module object corresponding to trace type
 */
exports.getModule = function(trace) {
if(trace.r !== undefined) {
    Loggers.<span class="apidocCodeKeywordSpan">warn</span>('Tried to put a polar trace ' +
        'on an incompatible graph of cartesian ' +
        'data. Ignoring this dataset.', trace
    );
    return false;
}

var _module = exports.modules[getTraceType(trace)];
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.loggers" id="apidoc.module.plotly.js.loggers">module plotly.js.loggers</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.loggers.error" id="apidoc.element.plotly.js.loggers.error">
        function <span class="apidocSignatureSpan">plotly.js.loggers.</span>error
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function () {
    if(config.logging &gt; 0) {
        var messages = ['ERROR:'];

        for(var i = 0; i &lt; arguments.length; i++) {
            messages.push(arguments[i]);
        }

        apply(console.error, messages);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// so we define the default (plotly.js) behavior here
function defaultSetBackground(gd, bgColor) {
    try {
        gd._fullLayout._paper.style('background', bgColor);
    }
    catch(e) {
        if(module.exports.logging &gt; 0) {
            console.<span class="apidocCodeKeywordSpan">error</span>(e);
        }
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.loggers.log" id="apidoc.element.plotly.js.loggers.log">
        function <span class="apidocSignatureSpan">plotly.js.loggers.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">log = function () {
    if(config.logging &gt; 1) {
        var messages = ['LOG:'];

        for(var i = 0; i &lt; arguments.length; i++) {
            messages.push(arguments[i]);
        }

        apply(console.trace || console.log, messages);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {string} thisType
 * @param {array of strings} categoriesIn all the categories this type is in,
 *     tested by calls: traceIs(trace, oneCategory)
 * @param {object} meta meta information about the trace type
 */
exports.register = function(_module, thisType, categoriesIn, meta) {
if(exports.modules[thisType]) {
    Loggers.<span class="apidocCodeKeywordSpan">log</span>('Type ' + thisType + ' already registered');
    return;
}

var categoryObj = {};
for(var i = 0; i &lt; categoriesIn.length; i++) {
    categoryObj[categoriesIn[i]] = true;
    exports.allCategories[categoriesIn[i]] = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.loggers.warn" id="apidoc.element.plotly.js.loggers.warn">
        function <span class="apidocSignatureSpan">plotly.js.loggers.</span>warn
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">warn = function () {
    if(config.logging &gt; 0) {
        var messages = ['WARN:'];

        for(var i = 0; i &lt; arguments.length; i++) {
            messages.push(arguments[i]);
        }

        apply(console.trace || console.log, messages);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {object||string} trace
 *  trace object with prop 'type' or trace type as a string
 * @return {object}
 *  module object corresponding to trace type
 */
exports.getModule = function(trace) {
if(trace.r !== undefined) {
    Loggers.<span class="apidocCodeKeywordSpan">warn</span>('Tried to put a polar trace ' +
        'on an incompatible graph of cartesian ' +
        'data. Ignoring this dataset.', trace
    );
    return false;
}

var _module = exports.modules[getTraceType(trace)];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.manage_arrays" id="apidoc.module.plotly.js.manage_arrays">module plotly.js.manage_arrays</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.manage_arrays.applyContainerArrayChanges" id="apidoc.element.plotly.js.manage_arrays.applyContainerArrayChanges">
        function <span class="apidocSignatureSpan">plotly.js.manage_arrays.</span>applyContainerArrayChanges
        <span class="apidocSignatureSpan">(gd, np, edits, flags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function applyContainerArrayChanges(gd, np, edits, flags) {
    var componentType = np.astr,
        supplyComponentDefaults = Registry.getComponentMethod(componentType, 'supplyLayoutDefaults'),
        draw = Registry.getComponentMethod(componentType, 'draw'),
        drawOne = Registry.getComponentMethod(componentType, 'drawOne'),
        replotLater = flags.replot || flags.recalc || (supplyComponentDefaults === noop) ||
            (draw === noop),
        layout = gd.layout,
        fullLayout = gd._fullLayout;

    if(edits['']) {
        if(Object.keys(edits).length &gt; 1) {
            Loggers.warn('Full array edits are incompatible with other edits',
                componentType);
        }

        var fullVal = edits[''][''];

        if(isRemoveVal(fullVal)) np.set(null);
        else if(Array.isArray(fullVal)) np.set(fullVal);
        else {
            Loggers.warn('Unrecognized full array edit value', componentType, fullVal);
            return true;
        }

        if(replotLater) return false;

        supplyComponentDefaults(layout, fullLayout);
        draw(gd);
        return true;
    }

    var componentNums = Object.keys(edits).map(Number).sort(),
        componentArrayIn = np.get(),
        componentArray = componentArrayIn || [],
        // componentArrayFull is used just to keep splices in line between
        // full and input arrays, so private keys can be copied over after
        // redoing supplyDefaults
        // TODO: this assumes componentArray is in gd.layout - which will not be
        // true after we extend this to restyle
        componentArrayFull = nestedProperty(fullLayout, componentType).get();

    var deletes = [],
        firstIndexChange = -1,
        maxIndex = componentArray.length,
        i,
        j,
        componentNum,
        objEdits,
        objKeys,
        objVal,
        adding;

    // first make the add and edit changes
    for(i = 0; i &lt; componentNums.length; i++) {
        componentNum = componentNums[i];
        objEdits = edits[componentNum];
        objKeys = Object.keys(objEdits);
        objVal = objEdits[''],
        adding = isAddVal(objVal);

        if(componentNum &lt; 0 || componentNum &gt; componentArray.length - (adding ? 0 : 1)) {
            Loggers.warn('index out of range', componentType, componentNum);
            continue;
        }

        if(objVal !== undefined) {
            if(objKeys.length &gt; 1) {
                Loggers.warn(
                    'Insertion &amp; removal are incompatible with edits to the same index.',
                    componentType, componentNum);
            }

            if(isRemoveVal(objVal)) {
                deletes.push(componentNum);
            }
            else if(adding) {
                if(objVal === 'add') objVal = {};
                componentArray.splice(componentNum, 0, objVal);
                if(componentArrayFull) componentArrayFull.splice(componentNum, 0, {});
            }
            else {
                Loggers.warn('Unrecognized full object edit value',
                    componentType, componentNum, objVal);
            }

            if(firstIndexChange === -1) firstIndexChange = componentNum;
        }
        else {
            for(j = 0; j &lt; objKeys.length; j++) {
                nestedProperty(componentArray[componentNum], objKeys[j]).set(objEdits[objKeys[j]]);
            }
        }
    }

    // now do deletes
    for(i = deletes.length - 1; i &gt;= 0; i--) {
        componentArray.splice(deletes[i], 1);
        // TODO: this drops private keys that had been stored in componentArrayFull
        // does this have any ill effects?
        if(componentArrayFull) componentArrayFull.splice(deletes[i], 1);
    }

    if(!componentArray.length) np.set(null);
    else if(!componentArrayIn) np.set(componentArray);

    if(replotLater) return false;

    supplyComponentDefaults(layout, fullLayout);

    // finally draw all the components we need to
    // if we added or removed any, redraw all after it
    if(drawOne !== noop) {
        var indicesToDraw;
        if(firstIndexChange === -1) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        p.set(vi);
    }
}

// now we've collected component edits - execute them all together
for(arrayStr in arrayEdits) {
    var finished = manageArrays.<span class="apidocCodeKeywordSpan">applyContainerArrayChanges</span>(gd,
        Lib.nestedProperty(layout, arrayStr), arrayEdits[arrayStr], flags);
    if(!finished) flags.doplot = true;
}

// figure out if we need to recalculate axis constraints
var constraints = fullLayout._axisConstraintGroups;
for(var axId in rangesAltered) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.manage_arrays.containerArrayMatch" id="apidoc.element.plotly.js.manage_arrays.containerArrayMatch">
        function <span class="apidocSignatureSpan">plotly.js.manage_arrays.</span>containerArrayMatch
        <span class="apidocSignatureSpan">(astr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function containerArrayMatch(astr) {
    var rootContainers = Registry.layoutArrayContainers,
        regexpContainers = Registry.layoutArrayRegexes,
        rootPart = astr.split('[')[0],
        arrayStr,
        match;

    // look for regexp matches first, because they may be nested inside root matches
    // eg updatemenus[i].buttons is nested inside updatemenus
    for(var i = 0; i &lt; regexpContainers.length; i++) {
        match = astr.match(regexpContainers[i]);
        if(match &amp;&amp; match.index === 0) {
            arrayStr = match[0];
            break;
        }
    }

    // now look for root matches
    if(!arrayStr) arrayStr = rootContainers[rootContainers.indexOf(rootPart)];

    if(!arrayStr) return false;

    var tail = astr.substr(arrayStr.length);
    if(!tail) return {array: arrayStr, index: '', property: ''};

    match = tail.match(/^\[(0|[1-9][0-9]*)\](\.(.+))?$/);
    if(!match) return false;

    return {array: arrayStr, index: Number(match[1]), property: match[3] || ''};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// alter gd.layout

// collect array component edits for execution all together
// so we can ensure consistent behavior adding/removing items
// and order-independence for add/remove/edit all together in
// one relayout call
var containerArrayMatch = manageArrays.<span class="apidocCodeKeywordSpan">containerArrayMatch</span>(ai);
if(containerArrayMatch) {
    arrayStr = containerArrayMatch.array;
    i = containerArrayMatch.index;
    var propStr = containerArrayMatch.property,
        componentArray = Lib.nestedProperty(layout, arrayStr),
        obji = (componentArray || [])[i] || {};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.manage_arrays.isAddVal" id="apidoc.element.plotly.js.manage_arrays.isAddVal">
        function <span class="apidocSignatureSpan">plotly.js.manage_arrays.</span>isAddVal
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isAddVal(val) {
    return val === 'add' || isPlainObject(val);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // replacing the entire array: too much going on, force recalc
    if(ai.indexOf('updatemenus') === -1) flags.docalc = true;
}
else if(propStr === '') {
    // special handling of undoit if we're adding or removing an element
    // ie 'annotations[2]' which can be {...} (add) or null (remove)
    var toggledObj = vi;
    if(manageArrays.<span class="apidocCodeKeywordSpan">isAddVal</span>(vi)) {
        undoit[ai] = null;
    }
    else if(manageArrays.isRemoveVal(vi)) {
        undoit[ai] = obji;
        toggledObj = obji;
    }
    else Lib.warn('unrecognized full object value', aobj);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.manage_arrays.isRemoveVal" id="apidoc.element.plotly.js.manage_arrays.isRemoveVal">
        function <span class="apidocSignatureSpan">plotly.js.manage_arrays.</span>isRemoveVal
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isRemoveVal(val) {
    return val === null || val === 'remove';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            else if(propStr === '') {
// special handling of undoit if we're adding or removing an element
// ie 'annotations[2]' which can be {...} (add) or null (remove)
var toggledObj = vi;
if(manageArrays.isAddVal(vi)) {
    undoit[ai] = null;
}
else if(manageArrays.<span class="apidocCodeKeywordSpan">isRemoveVal</span>(vi)) {
    undoit[ai] = obji;
    toggledObj = obji;
}
else Lib.warn('unrecognized full object value', aobj);

if(refAutorange(toggledObj, 'x') || refAutorange(toggledObj, 'y') &amp;&amp;
        ai.indexOf('updatemenus') === -1) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.matrix" id="apidoc.module.plotly.js.matrix">module plotly.js.matrix</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.matrix.apply2DTransform" id="apidoc.element.plotly.js.matrix.apply2DTransform">
        function <span class="apidocSignatureSpan">plotly.js.matrix.</span>apply2DTransform
        <span class="apidocSignatureSpan">(transform)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply2DTransform = function (transform) {
    return function() {
        var args = arguments;
        if(args.length === 3) {
            args = args[0];
        }// from map
        var xy = arguments.length === 1 ? args[0] : [args[0], args[1]];
        return exports.dot(transform, [xy[0], xy[1], 1]).slice(0, 2);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var xy = arguments.length === 1 ? args[0] : [args[0], args[1]];
        return exports.dot(transform, [xy[0], xy[1], 1]).slice(0, 2);
    };
};

// applies a 2D transformation matrix to an [x1,y1,x2,y2] array (to transform a segment)
exports.apply2DTransform2 = function(transform) {
    var at = exports.<span class="apidocCodeKeywordSpan">apply2DTransform</span>(transform);
    return function(xys) {
        return at(xys.slice(0, 2)).concat(at(xys.slice(2, 4)));
    };
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.matrix.apply2DTransform2" id="apidoc.element.plotly.js.matrix.apply2DTransform2">
        function <span class="apidocSignatureSpan">plotly.js.matrix.</span>apply2DTransform2
        <span class="apidocSignatureSpan">(transform)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">apply2DTransform2 = function (transform) {
    var at = exports.apply2DTransform(transform);
    return function(xys) {
        return at(xys.slice(0, 2)).concat(at(xys.slice(2, 4)));
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
textX = annPosPx.x.text + dx,
textY = annPosPx.y.text + dy,

// find the edge of the text box, where we'll start the arrow:
// create transform matrix to rotate the text box corners
transform = Lib.rotationXYMatrix(textangle, textX, textY),
applyTransform = Lib.apply2DTransform(transform),
applyTransform2 = Lib.<span class="apidocCodeKeywordSpan">apply2DTransform2</span>(transform),

// calculate and transform bounding box
width = +annTextBG.attr('width'),
height = +annTextBG.attr('height'),
xLeft = textX - 0.5 * width,
xRight = xLeft + width,
yTop = textY - 0.5 * height,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.matrix.dot" id="apidoc.element.plotly.js.matrix.dot">
        function <span class="apidocSignatureSpan">plotly.js.matrix.</span>dot
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dot = function (x, y) {
    if(!(x.length &amp;&amp; y.length) || x.length !== y.length) return null;

    var len = x.length,
        out,
        i;

    if(x[0].length) {
        // mat-vec or mat-mat
        out = new Array(len);
        for(i = 0; i &lt; len; i++) out[i] = exports.dot(x[i], y);
    }
    else if(y[0].length) {
        // vec-mat
        var yTranspose = exports.transposeRagged(y);
        out = new Array(yTranspose.length);
        for(i = 0; i &lt; yTranspose.length; i++) out[i] = exports.dot(x, yTranspose[i]);
    }
    else {
        // vec-vec
        out = 0;
        for(i = 0; i &lt; len; i++) out += x[i] * y[i];
    }

    return out;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var len = x.length,
    out,
    i;

if(x[0].length) {
    // mat-vec or mat-mat
    out = new Array(len);
    for(i = 0; i &lt; len; i++) out[i] = exports.<span class="apidocCodeKeywordSpan">dot</span>(x[i], y);
}
else if(y[0].length) {
    // vec-mat
    var yTranspose = exports.transposeRagged(y);
    out = new Array(yTranspose.length);
    for(i = 0; i &lt; yTranspose.length; i++) out[i] = exports.dot(x, yTranspose[i]);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.matrix.init2dArray" id="apidoc.element.plotly.js.matrix.init2dArray">
        function <span class="apidocSignatureSpan">plotly.js.matrix.</span>init2dArray
        <span class="apidocSignatureSpan">(rowLength, colLength)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init2dArray = function (rowLength, colLength) {
    var array = new Array(rowLength);
    for(var i = 0; i &lt; rowLength; i++) array[i] = new Array(colLength);
    return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var col1dv = Lib.distinctVals(col1),
    col1vals = col1dv.vals,
    col2dv = Lib.distinctVals(col2),
    col2vals = col2dv.vals,
    newArrays = [];

for(i = 0; i &lt; arrayVarNames.length; i++) {
    newArrays[i] = Lib.<span class="apidocCodeKeywordSpan">init2dArray</span>(col2vals.length, col1vals.length);
}

var i1, i2, text;

if(hasColumnText) text = Lib.init2dArray(col2vals.length, col1vals.length);

for(i = 0; i &lt; colLen; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.matrix.rotationMatrix" id="apidoc.element.plotly.js.matrix.rotationMatrix">
        function <span class="apidocSignatureSpan">plotly.js.matrix.</span>rotationMatrix
        <span class="apidocSignatureSpan">(alpha)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rotationMatrix = function (alpha) {
    var a = alpha * Math.PI / 180;
    return [[Math.cos(a), -Math.sin(a), 0],
            [Math.sin(a), Math.cos(a), 0],
            [0, 0, 1]];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        [0, 0, 1]];
};

// rotate by alpha around (x,y)
exports.rotationXYMatrix = function(a, x, y) {
return exports.dot(
    exports.dot(exports.translationMatrix(x, y),
                exports.<span class="apidocCodeKeywordSpan">rotationMatrix</span>(a)),
    exports.translationMatrix(-x, -y));
};

// applies a 2D transformation matrix to either x and y params or an [x,y] array
exports.apply2DTransform = function(transform) {
return function() {
    var args = arguments;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.matrix.rotationXYMatrix" id="apidoc.element.plotly.js.matrix.rotationXYMatrix">
        function <span class="apidocSignatureSpan">plotly.js.matrix.</span>rotationXYMatrix
        <span class="apidocSignatureSpan">(a, x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rotationXYMatrix = function (a, x, y) {
    return exports.dot(
        exports.dot(exports.translationMatrix(x, y),
                    exports.rotationMatrix(a)),
        exports.translationMatrix(-x, -y));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
tailX = annPosPx.x.tail + dx,
tailY = annPosPx.y.tail + dy,
textX = annPosPx.x.text + dx,
textY = annPosPx.y.text + dy,

// find the edge of the text box, where we'll start the arrow:
// create transform matrix to rotate the text box corners
transform = Lib.<span class="apidocCodeKeywordSpan">rotationXYMatrix</span>(textangle, textX, textY),
applyTransform = Lib.apply2DTransform(transform),
applyTransform2 = Lib.apply2DTransform2(transform),

// calculate and transform bounding box
width = +annTextBG.attr('width'),
height = +annTextBG.attr('height'),
xLeft = textX - 0.5 * width,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.matrix.translationMatrix" id="apidoc.element.plotly.js.matrix.translationMatrix">
        function <span class="apidocSignatureSpan">plotly.js.matrix.</span>translationMatrix
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">translationMatrix = function (x, y) {
    return [[1, 0, x], [0, 1, y], [0, 0, 1]];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        [Math.sin(a), Math.cos(a), 0],
        [0, 0, 1]];
};

// rotate by alpha around (x,y)
exports.rotationXYMatrix = function(a, x, y) {
return exports.dot(
    exports.dot(exports.<span class="apidocCodeKeywordSpan">translationMatrix</span>(x, y),
                exports.rotationMatrix(a)),
    exports.translationMatrix(-x, -y));
};

// applies a 2D transformation matrix to either x and y params or an [x,y] array
exports.apply2DTransform = function(transform) {
return function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.matrix.transposeRagged" id="apidoc.element.plotly.js.matrix.transposeRagged">
        function <span class="apidocSignatureSpan">plotly.js.matrix.</span>transposeRagged
        <span class="apidocSignatureSpan">(z)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transposeRagged = function (z) {
    var maxlen = 0,
        zlen = z.length,
        i,
        j;
    // Maximum row length:
    for(i = 0; i &lt; zlen; i++) maxlen = Math.max(maxlen, z[i].length);

    var t = new Array(maxlen);
    for(i = 0; i &lt; maxlen; i++) {
        t[i] = new Array(zlen);
        for(j = 0; j &lt; zlen; j++) t[i][j] = z[j][i];
    }

    return t;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(x[0].length) {
    // mat-vec or mat-mat
    out = new Array(len);
    for(i = 0; i &lt; len; i++) out[i] = exports.dot(x[i], y);
}
else if(y[0].length) {
    // vec-mat
    var yTranspose = exports.<span class="apidocCodeKeywordSpan">transposeRagged</span>(y);
    out = new Array(yTranspose.length);
    for(i = 0; i &lt; yTranspose.length; i++) out[i] = exports.dot(x, yTranspose[i]);
}
else {
    // vec-vec
    out = 0;
    for(i = 0; i &lt; len; i++) out += x[i] * y[i];
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.micropolar" id="apidoc.module.plotly.js.micropolar">module plotly.js.micropolar</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.micropolar.AreaChart" id="apidoc.element.plotly.js.micropolar.AreaChart">
        function <span class="apidocSignatureSpan">plotly.js.micropolar.</span>AreaChart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function module() {
    return Âµ.PolyChart();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.micropolar.Axis" id="apidoc.element.plotly.js.micropolar.Axis">
        function <span class="apidocSignatureSpan">plotly.js.micropolar.</span>Axis
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function module() {
    var config = {
        data: [],
        layout: {}
    }, inputConfig = {}, liveConfig = {};
    var svg, container, dispatch = d3.dispatch('hover'), radialScale, angularScale;
    var exports = {};
    function render(_container) {
        container = _container || container;
        var data = config.data;
        var axisConfig = config.layout;
        if (typeof container == 'string' || container.nodeName) container = d3.select(container);
        container.datum(data).each(function(_data, _index) {
            var dataOriginal = _data.slice();
            liveConfig = {
                data: Âµ.util.cloneJson(dataOriginal),
                layout: Âµ.util.cloneJson(axisConfig)
            };
            var colorIndex = 0;
            dataOriginal.forEach(function(d, i) {
                if (!d.color) {
                    d.color = axisConfig.defaultColorRange[colorIndex];
                    colorIndex = (colorIndex + 1) % axisConfig.defaultColorRange.length;
                }
                if (!d.strokeColor) {
                    d.strokeColor = d.geometry === 'LinePlot' ? d.color : d3.rgb(d.color).darker().toString();
                }
                liveConfig.data[i].color = d.color;
                liveConfig.data[i].strokeColor = d.strokeColor;
                liveConfig.data[i].strokeDash = d.strokeDash;
                liveConfig.data[i].strokeSize = d.strokeSize;
            });
            var data = dataOriginal.filter(function(d, i) {
                var visible = d.visible;
                return typeof visible === 'undefined' || visible === true;
            });
            var isStacked = false;
            var dataWithGroupId = data.map(function(d, i) {
                isStacked = isStacked || typeof d.groupId !== 'undefined';
                return d;
            });
            if (isStacked) {
                var grouped = d3.nest().key(function(d, i) {
                    return typeof d.groupId != 'undefined' ? d.groupId : 'unstacked';
                }).entries(dataWithGroupId);
                var dataYStack = [];
                var stacked = grouped.map(function(d, i) {
                    if (d.key === 'unstacked') return d.values; else {
                        var prevArray = d.values[0].r.map(function(d, i) {
                            return 0;
                        });
                        d.values.forEach(function(d, i, a) {
                            d.yStack = [ prevArray ];
                            dataYStack.push(prevArray);
                            prevArray = Âµ.util.sumArrays(d.r, prevArray);
                        });
                        return d.values;
                    }
                });
                data = d3.merge(stacked);
            }
            data.forEach(function(d, i) {
                d.t = Array.isArray(d.t[0]) ? d.t : [ d.t ];
                d.r = Array.isArray(d.r[0]) ? d.r : [ d.r ];
            });
            var radius = Math.min(axisConfig.width - axisConfig.margin.left - axisConfig.margin.right, axisConfig.height - axisConfig
.margin.top - axisConfig.margin.bottom) / 2;
            radius = Math.max(10, radius);
            var chartCenter = [ axisConfig.margin.left + radius, axisConfig.margin.top + radius ];
            var extent;
            if (isStacked) {
                var highestStackedValue = d3.max(Âµ.util.sumArrays(Âµ.util.arrayLast(data).r[0], Âµ.util.arrayLast(dataYStack)));
                extent = [ 0, highestStackedValue ];
            } else extent = d3.extent(Âµ.util.flattenArray(data.map(function(d, i) {
                return d.r;
            })));
            if (axisConfig.radialAxis.domain != Âµ.DATAEXTENT) extent[0] = 0;
            radialScale = d3.scale.linear().domain(axisConfig.radialAxis.domain != Âµ.DATAEXTENT &amp;&amp; axisConfig.radialAxis.domain ?
axisConfig.radialAxis.domain : extent).range([ 0, radius ]);
            liveConfig.layout.radialAxis.domain = radialScale.domain();
            var angularDataMerged = Âµ.util.flattenArray(data.map(function(d, i) {
                ret ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if(_container) container = _container;
    d3.select(d3.select(container).node().parentNode).selectAll('.svg-container&gt;*:not(.chart-root)').remove();

    config = (!config) ?
        _inputConfig :
        extendDeepAll(config, _inputConfig);

    if(!plot) plot = micropolar.<span class="apidocCodeKeywordSpan">Axis</span>();
    convertedInput = micropolar.adapter.plotly().convert(config);
    plot.config(convertedInput).render(container);
    _gd.data = config.data;
    _gd.layout = config.layout;
    manager.fillLayout(_gd);
    return config;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.micropolar.BarChart" id="apidoc.element.plotly.js.micropolar.BarChart">
        function <span class="apidocSignatureSpan">plotly.js.micropolar.</span>BarChart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function module() {
    return Âµ.PolyChart();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.micropolar.DotPlot" id="apidoc.element.plotly.js.micropolar.DotPlot">
        function <span class="apidocSignatureSpan">plotly.js.micropolar.</span>DotPlot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function module() {
    return Âµ.PolyChart();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.micropolar.Legend" id="apidoc.element.plotly.js.micropolar.Legend">
        function <span class="apidocSignatureSpan">plotly.js.micropolar.</span>Legend
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function module() {
    var config = Âµ.Legend.defaultConfig();
    var dispatch = d3.dispatch('hover');
    function exports() {
        var legendConfig = config.legendConfig;
        var flattenData = config.data.map(function(d, i) {
            return [].concat(d).map(function(dB, iB) {
                var element = extendDeepAll({}, legendConfig.elements[i]);
                element.name = dB;
                element.color = [].concat(legendConfig.elements[i].color)[iB];
                return element;
            });
        });
        var data = d3.merge(flattenData);
        data = data.filter(function(d, i) {
            return legendConfig.elements[i] &amp;&amp; (legendConfig.elements[i].visibleInLegend || typeof legendConfig.elements[i].visibleInLegend
 === 'undefined');
        });
        if (legendConfig.reverseOrder) data = data.reverse();
        var container = legendConfig.container;
        if (typeof container == 'string' || container.nodeName) container = d3.select(container);
        var colors = data.map(function(d, i) {
            return d.color;
        });
        var lineHeight = legendConfig.fontSize;
        var isContinuous = legendConfig.isContinuous == null ? typeof data[0] === 'number' : legendConfig.isContinuous;
        var height = isContinuous ? legendConfig.height : lineHeight * data.length;
        var legendContainerGroup = container.classed('legend-group', true);
        var svg = legendContainerGroup.selectAll('svg').data([ 0 ]);
        var svgEnter = svg.enter().append('svg').attr({
            width: 300,
            height: height + lineHeight,
            xmlns: 'http://www.w3.org/2000/svg',
            'xmlns:xlink': 'http://www.w3.org/1999/xlink',
            version: '1.1'
        });
        svgEnter.append('g').classed('legend-axis', true);
        svgEnter.append('g').classed('legend-marks', true);
        var dataNumbered = d3.range(data.length);
        var colorScale = d3.scale[isContinuous ? 'linear' : 'ordinal']().domain(dataNumbered).range(colors);
        var dataScale = d3.scale[isContinuous ? 'linear' : 'ordinal']().domain(dataNumbered)[isContinuous ? 'range' : 'rangePoints
']([ 0, height ]);
        var shapeGenerator = function(_type, _size) {
            var squareSize = _size * 3;
            if (_type === 'line') {
                return 'M' + [ [ -_size / 2, -_size / 12 ], [ _size / 2, -_size / 12 ], [ _size / 2, _size / 12 ], [ -_size / 2,
_size / 12 ] ] + 'Z';
            } else if (d3.svg.symbolTypes.indexOf(_type) != -1) return d3.svg.symbol().type(_type).size(squareSize)(); else return
 d3.svg.symbol().type('square').size(squareSize)();
        };
        if (isContinuous) {
            var gradient = svg.select('.legend-marks').append('defs').append('linearGradient').attr({
                id: 'grad1',
                x1: '0%',
                y1: '0%',
                x2: '0%',
                y2: '100%'
            }).selectAll('stop').data(colors);
            gradient.enter().append('stop');
            gradient.attr({
                offset: function(d, i) {
                    return i / (colors.length - 1) * 100 + '%';
                }
            }).style({
                'stop-color': function(d, i) {
                    return d;
                }
            });
            svg.append('rect').classed('legend-mark', true).attr({
                height: legendConfig.height,
                width: legendConfig.colorBandWidth,
                fill: 'url(#grad1)'
            });
        } else {
            var legendElement = svg.select('.legend-marks').selectAll('path.legend-mark').data(data);
            legendElement.enter().append('path').classed('legend-mark', true);
            legendElement.attr({
                transform: function(d, i) {
                    return 'translate(' + [ lineHeight / 2, dataScale(i) + lineHeight / 2 ] + ')';
                },
                d: function(d, i) {
                    var symbolType = d.symbol;
                    return shapeGenerator(symbolType, lineHeight);
                }, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var datumClone = Âµ.util.cloneJson(d);
    datumClone.symbol = d.geometry === 'DotPlot' ? d.dotType || 'circle' : d.geometry != 'LinePlot'
; ? 'square' : 'line';
    datumClone.visibleInLegend = typeof d.visibleInLegend === 'undefined' || d.visibleInLegend;
    datumClone.color = d.geometry === 'LinePlot' ? d.strokeColor : d.color;
    return datumClone;
});

Âµ.<span class="apidocCodeKeywordSpan">Legend</span>().config({
    data: data.map(function(d, i) {
        return d.name || 'Element' + i;
    }),
    legendConfig: extendDeepAll({},
        Âµ.Legend.defaultConfig().legendConfig,
        {
            container: legendContainer,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.micropolar.LinePlot" id="apidoc.element.plotly.js.micropolar.LinePlot">
        function <span class="apidocSignatureSpan">plotly.js.micropolar.</span>LinePlot
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function module() {
    return Âµ.PolyChart();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.micropolar.PolyChart" id="apidoc.element.plotly.js.micropolar.PolyChart">
        function <span class="apidocSignatureSpan">plotly.js.micropolar.</span>PolyChart
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function module() {
    var config = [ Âµ.PolyChart.defaultConfig() ];
    var dispatch = d3.dispatch('hover');
    var dashArray = {
        solid: 'none',
        dash: [ 5, 2 ],
        dot: [ 2, 5 ]
    };
    var colorScale;
    function exports() {
        var geometryConfig = config[0].geometryConfig;
        var container = geometryConfig.container;
        if (typeof container == 'string') container = d3.select(container);
        container.datum(config).each(function(_config, _index) {
            var isStack = !!_config[0].data.yStack;
            var data = _config.map(function(d, i) {
                if (isStack) return d3.zip(d.data.t[0], d.data.r[0], d.data.yStack[0]); else return d3.zip(d.data.t[0], d.data.r
[0]);
            });
            var angularScale = geometryConfig.angularScale;
            var domainMin = geometryConfig.radialScale.domain()[0];
            var generator = {};
            generator.bar = function(d, i, pI) {
                var dataConfig = _config[pI].data;
                var h = geometryConfig.radialScale(d[1]) - geometryConfig.radialScale(0);
                var stackTop = geometryConfig.radialScale(d[2] || 0);
                var w = dataConfig.barWidth;
                d3.select(this).attr({
                    'class': 'mark bar',
                    d: 'M' + [ [ h + stackTop, -w / 2 ], [ h + stackTop, w / 2 ], [ stackTop, w / 2 ], [ stackTop, -w / 2 ] ].join
('L') + 'Z',
                    transform: function(d, i) {
                        return 'rotate(' + (geometryConfig.orientation + angularScale(d[0])) + ')';
                    }
                });
            };
            generator.dot = function(d, i, pI) {
                var stackedData = d[2] ? [ d[0], d[1] + d[2] ] : d;
                var symbol = d3.svg.symbol().size(_config[pI].data.dotSize).type(_config[pI].data.dotType)(d, i);
                d3.select(this).attr({
                    'class': 'mark dot',
                    d: symbol,
                    transform: function(d, i) {
                        var coord = convertToCartesian(getPolarCoordinates(stackedData));
                        return 'translate(' + [ coord.x, coord.y ] + ')';
                    }
                });
            };
            var line = d3.svg.line.radial().interpolate(_config[0].data.lineInterpolation).radius(function(d) {
                return geometryConfig.radialScale(d[1]);
            }).angle(function(d) {
                return geometryConfig.angularScale(d[0]) * Math.PI / 180;
            });
            generator.line = function(d, i, pI) {
                var lineData = d[2] ? data[pI].map(function(d, i) {
                    return [ d[0], d[1] + d[2] ];
                }) : data[pI];
                d3.select(this).each(generator['dot']).style({
                    opacity: function(dB, iB) {
                        return +_config[pI].data.dotVisible;
                    },
                    fill: markStyle.stroke(d, i, pI)
                }).attr({
                    'class': 'mark dot'
                });
                if (i &gt; 0) return;
                var lineSelection = d3.select(this.parentNode).selectAll('path.line').data([ 0 ]);
                lineSelection.enter().insert('path');
                lineSelection.attr({
                    'class': 'line',
                    d: line(lineData),
                    transform: function(dB, iB) {
                        return 'rotate(' + (geometryConfig.orientation + 90) + ')';
                    },
                    'pointer-events': 'none'
                }).style({
                    fill: function(dB, iB) {
                        return markStyle.fill(d, i, pI);
                    },
                    'fill-opacity': 0,
                    stroke: function(dB, iB) {
                        return markStyle.stroke(d, i, pI);
                    },
                    'stroke-width': function(dB, iB) {
                        return markStyle['stroke-width'](d, i, pI);
                    },
                    'stroke-dasharray': ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        colorScale: d3.scale.category20()
    }
};
return config;
};

Âµ.BarChart = function module() {
return Âµ.<span class="apidocCodeKeywordSpan">PolyChart</span>();
};

Âµ.BarChart.defaultConfig = function() {
var config = {
    geometryConfig: {
        geometryType: 'bar'
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.micropolar.tooltipPanel" id="apidoc.element.plotly.js.micropolar.tooltipPanel">
        function <span class="apidocSignatureSpan">plotly.js.micropolar.</span>tooltipPanel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tooltipPanel = function () {
    var tooltipEl, tooltipTextEl, backgroundEl;
    var config = {
        container: null,
        hasTick: false,
        fontSize: 12,
        color: 'white',
        padding: 5
    };
    var id = 'tooltip-' + Âµ.tooltipPanel.uid++;
    var tickSize = 10;
    var exports = function() {
        tooltipEl = config.container.selectAll('g.' + id).data([ 0 ]);
        var tooltipEnter = tooltipEl.enter().append('g').classed(id, true).style({
            'pointer-events': 'none',
            display: 'none'
        });
        backgroundEl = tooltipEnter.append('path').style({
            fill: 'white',
            'fill-opacity': .9
        }).attr({
            d: 'M0 0'
        });
        tooltipTextEl = tooltipEnter.append('text').attr({
            dx: config.padding + tickSize,
            dy: +config.fontSize * .3
        });
        return exports;
    };
    exports.text = function(_text) {
        var l = d3.hsl(config.color).l;
        var strokeColor = l &gt;= .5 ? '#aaa' : 'white';
        var fillColor = l &gt;= .5 ? 'black' : 'white';
        var text = _text || '';
        tooltipTextEl.style({
            fill: fillColor,
            'font-size': config.fontSize + 'px'
        }).text(text);
        var padding = config.padding;
        var bbox = tooltipTextEl.node().getBBox();
        var boxStyle = {
            fill: config.color,
            stroke: strokeColor,
            'stroke-width': '2px'
        };
        var backGroundW = bbox.width + padding * 2 + tickSize;
        var backGroundH = bbox.height + padding * 2;
        backgroundEl.attr({
            d: 'M' + [ [ tickSize, -backGroundH / 2 ], [ tickSize, -backGroundH / 4 ], [ config.hasTick ? 0 : tickSize, 0 ], [ tickSize
, backGroundH / 4 ], [ tickSize, backGroundH / 2 ], [ backGroundW, backGroundH / 2 ], [ backGroundW, -backGroundH / 2 ] ].join('
L') + 'Z'
        }).style(boxStyle);
        tooltipEl.attr({
            transform: 'translate(' + [ tickSize, -backGroundH / 2 + padding * 2 ] + ')'
        });
        tooltipEl.style({
            display: 'block'
        });
        return exports;
    };
    exports.move = function(_pos) {
        if (!tooltipEl) return;
        tooltipEl.attr({
            transform: 'translate(' + [ _pos[0], _pos[1] ] + ')'
        }).style({
            display: 'block'
        });
        return exports;
    };
    exports.hide = function() {
        if (!tooltipEl) return;
        tooltipEl.style({
            display: 'none'
        });
        return exports;
    };
    exports.show = function() {
        if (!tooltipEl) return;
        tooltipEl.style({
            display: 'block'
        });
        return exports;
    };
    exports.config = function(_x) {
        extendDeepAll(config, _x);
        return exports;
    };
    return exports;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return extendDeepAll(Âµ[geometry].defaultConfig(), dB);
        });
        Âµ[geometry]().config(finalGeometryConfig)();
    });
}
var guides = svg.select('.guides-group');
var tooltipContainer = svg.select('.tooltips-group');
var angularTooltip = Âµ.<span class="apidocCodeKeywordSpan">tooltipPanel</span>().config({
    container: tooltipContainer,
    fontSize: 8
})();
var radialTooltip = Âµ.tooltipPanel().config({
    container: tooltipContainer,
    fontSize: 8
})();
...</pre></li>
    </ul>




















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.micropolar_manager" id="apidoc.module.plotly.js.micropolar_manager">module plotly.js.micropolar_manager</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.micropolar_manager.fillLayout" id="apidoc.element.plotly.js.micropolar_manager.fillLayout">
        function <span class="apidocSignatureSpan">plotly.js.micropolar_manager.</span>fillLayout
        <span class="apidocSignatureSpan">(_gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fillLayout = function (_gd) {
    var container = d3.select(_gd).selectAll('.plot-container'),
        paperDiv = container.selectAll('.svg-container'),
        paper = _gd.framework &amp;&amp; _gd.framework.svg &amp;&amp; _gd.framework.svg(),
        dflts = {
            width: 800,
            height: 600,
            paper_bgcolor: Color.background,
            _container: container,
            _paperdiv: paperDiv,
            _paper: paper
        };

    _gd._fullLayout = extendDeepAll(dflts, _gd.layout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// empty it everytime for now
paperDiv.html('');

// fulfill gd requirements
if(data) gd.data = data;
if(layout) gd.layout = layout;
Polar.manager.<span class="apidocCodeKeywordSpan">fillLayout</span>(gd);

// resize canvas
paperDiv.style({
    width: gd._fullLayout.width + 'px',
    height: gd._fullLayout.height + 'px'
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.micropolar_manager.framework" id="apidoc.element.plotly.js.micropolar_manager.framework">
        function <span class="apidocSignatureSpan">plotly.js.micropolar_manager.</span>framework
        <span class="apidocSignatureSpan">(_gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">framework = function (_gd) {
    var config, previousConfigClone, plot, convertedInput, container;
    var undoManager = new UndoManager();

    function exports(_inputConfig, _container) {
        if(_container) container = _container;
        d3.select(d3.select(container).node().parentNode).selectAll('.svg-container&gt;*:not(.chart-root)').remove();

        config = (!config) ?
            _inputConfig :
            extendDeepAll(config, _inputConfig);

        if(!plot) plot = micropolar.Axis();
        convertedInput = micropolar.adapter.plotly().convert(config);
        plot.config(convertedInput).render(container);
        _gd.data = config.data;
        _gd.layout = config.layout;
        manager.fillLayout(_gd);
        return config;
    }
    exports.isPolar = true;
    exports.svg = function() { return plot.svg(); };
    exports.getConfig = function() { return config; };
    exports.getLiveConfig = function() {
        return micropolar.adapter.plotly().convert(plot.getLiveConfig(), true);
    };
    exports.getLiveScales = function() { return {t: plot.angularScale(), r: plot.radialScale()}; };
    exports.setUndoPoint = function() {
        var that = this;
        var configClone = micropolar.util.cloneJson(config);
        (function(_configClone, _previousConfigClone) {
            undoManager.add({
                undo: function() {
                    if(_previousConfigClone) that(_previousConfigClone);
                },
                redo: function() {
                    that(_configClone);
                }
            });
        })(configClone, previousConfigClone);
        previousConfigClone = micropolar.util.cloneJson(configClone);
    };
    exports.undo = function() { undoManager.undo(); };
    exports.redo = function() { undoManager.redo(); };
    return exports;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// resize canvas
paperDiv.style({
    width: gd._fullLayout.width + 'px',
    height: gd._fullLayout.height + 'px'
});

// instantiate framework
gd.framework = Polar.manager.<span class="apidocCodeKeywordSpan">framework</span>(gd);

// plot
gd.framework({data: gd.data, layout: gd.layout}, paperDiv.node());

// set undo point
gd.framework.setUndoPoint();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.norm_functions" id="apidoc.module.plotly.js.norm_functions">module plotly.js.norm_functions</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.norm_functions.density" id="apidoc.element.plotly.js.norm_functions.density">
        function <span class="apidocSignatureSpan">plotly.js.norm_functions.</span>density
        <span class="apidocSignatureSpan">(size, total, inc, yinc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">density = function (size, total, inc, yinc) {
    var nMax = size.length;
    yinc = yinc || 1;
    for(var n = 0; n &lt; nMax; n++) size[n] *= inc[n] * yinc;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.norm_functions.percent" id="apidoc.element.plotly.js.norm_functions.percent">
        function <span class="apidocSignatureSpan">plotly.js.norm_functions.</span>percent
        <span class="apidocSignatureSpan">(size, total)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">percent = function (size, total) {
    var nMax = size.length,
        norm = 100 / total;
    for(var n = 0; n &lt; nMax; n++) size[n] *= norm;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.norm_functions.probability" id="apidoc.element.plotly.js.norm_functions.probability">
        function <span class="apidocSignatureSpan">plotly.js.norm_functions.</span>probability
        <span class="apidocSignatureSpan">(size, total)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">probability = function (size, total) {
    var nMax = size.length;
    for(var n = 0; n &lt; nMax; n++) size[n] /= total;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.pie" id="apidoc.module.plotly.js.pie">module plotly.js.pie</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.pie.calc" id="apidoc.element.plotly.js.pie.calc">
        function <span class="apidocSignatureSpan">plotly.js.pie.</span>calc
        <span class="apidocSignatureSpan">(gd, trace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function calc(gd, trace) {
    var vals = trace.values,
        labels = trace.labels,
        cd = [],
        fullLayout = gd._fullLayout,
        colorMap = fullLayout._piecolormap,
        allThisTraceLabels = {},
        needDefaults = false,
        vTotal = 0,
        hiddenLabels = fullLayout.hiddenlabels || [],
        i,
        v,
        label,
        color,
        hidden,
        pt;

    if(trace.dlabel) {
        labels = new Array(vals.length);
        for(i = 0; i &lt; vals.length; i++) {
            labels[i] = String(trace.label0 + i * trace.dlabel);
        }
    }

    for(i = 0; i &lt; vals.length; i++) {
        v = vals[i];
        if(!isNumeric(v)) continue;
        v = +v;
        if(v &lt; 0) continue;

        label = labels[i];
        if(label === undefined || label === '') label = i;
        label = String(label);
        // only take the first occurrence of any given label.
        // TODO: perhaps (optionally?) sum values for a repeated label?
        if(allThisTraceLabels[label] === undefined) allThisTraceLabels[label] = true;
        else continue;

        color = tinycolor(trace.marker.colors[i]);
        if(color.isValid()) {
            color = Color.addOpacity(color, color.getAlpha());
            if(!colorMap[label]) {
                colorMap[label] = color;
            }
        }
        // have we seen this label and assigned a color to it in a previous trace?
        else if(colorMap[label]) color = colorMap[label];
        // color needs a default - mark it false, come back after sorting
        else {
            color = false;
            needDefaults = true;
        }

        hidden = hiddenLabels.indexOf(label) !== -1;

        if(!hidden) vTotal += v;

        cd.push({
            v: v,
            label: label,
            color: color,
            i: i,
            hidden: hidden
        });
    }

    if(trace.sort) cd.sort(function(a, b) { return b.v - a.v; });

<span class="apidocCodeCommentSpan">    /**
     * now go back and fill in colors we're still missing
     * this is done after sorting, so we pick defaults
     * in the order slices will be displayed
     */
</span>
    if(needDefaults) {
        for(i = 0; i &lt; cd.length; i++) {
            pt = cd[i];
            if(pt.color === false) {
                colorMap[pt.label] = pt.color = nextDefaultColor(fullLayout._piedefaultcolorcount);
                fullLayout._piedefaultcolorcount++;
            }
        }
    }

    // include the sum of all values in the first point
    if(cd[0]) cd[0].vTotal = vTotal;

    // now insert text
    if(trace.textinfo &amp;&amp; trace.textinfo !== 'none') {
        var hasLabel = trace.textinfo.indexOf('label') !== -1,
            hasText = trace.textinfo.indexOf('text') !== -1,
            hasValue = trace.textinfo.indexOf('value') !== -1,
            hasPercent = trace.textinfo.indexOf('percent') !== -1,
            separators = fullLayout.separators,
            thisText;

        for(i = 0; i &lt; cd.length; i++) {
            pt = cd[i];
            thisText = hasLabel ? [pt.label] : [];
            if(hasText &amp;&amp; trace.text[pt.i]) thisText.push(trace.text[pt.i]);
            if(hasValue) thisText.push(helpers.formatPieValue(pt.v, separators));
            if(hasPercent) thisText.push(helpers.formatPiePercent(pt.v / vTotal, separators));
            pt.text = thisText.join('&lt;br&gt;');
        }
    }

    return cd;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for(var j = 0; j &lt; modules.length; j++) {
        _module = modules[j];
        if(_module.setPositions) _module.setPositions(gd, subplotInfo);
    }
}

// calc and autorange for errorbars
ErrorBars.<span class="apidocCodeKeywordSpan">calc</span>(gd);

// TODO: autosize extra for text markers and images
// see https://github.com/plotly/plotly.js/issues/1111
return Lib.syncOrAsync([
    Registry.getComponentMethod('shapes', 'calcAutorange'),
    Registry.getComponentMethod('annotations', 'calcAutorange'),
    doAutoRangeAndConstraints,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.pie.plot" id="apidoc.element.plotly.js.pie.plot">
        function <span class="apidocSignatureSpan">plotly.js.pie.</span>plot
        <span class="apidocSignatureSpan">(gd, cdpie)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function plot(gd, cdpie) {
    var fullLayout = gd._fullLayout;

    scalePies(cdpie, fullLayout._size);

    var pieGroups = fullLayout._pielayer.selectAll('g.trace').data(cdpie);

    pieGroups.enter().append('g')
        .attr({
            'stroke-linejoin': 'round', // TODO: miter might look better but can sometimes cause problems
                                        // maybe miter with a small-ish stroke-miterlimit?
            'class': 'trace'
        });
    pieGroups.exit().remove();
    pieGroups.order();

    pieGroups.each(function(cd) {
        var pieGroup = d3.select(this),
            cd0 = cd[0],
            trace = cd0.trace,
            tiltRads = 0, // trace.tilt * Math.PI / 180,
            depthLength = (trace.depth||0) * cd0.r * Math.sin(tiltRads) / 2,
            tiltAxis = trace.tiltaxis || 0,
            tiltAxisRads = tiltAxis * Math.PI / 180,
            depthVector = [
                depthLength * Math.sin(tiltAxisRads),
                depthLength * Math.cos(tiltAxisRads)
            ],
            rSmall = cd0.r * Math.cos(tiltRads);

        var pieParts = pieGroup.selectAll('g.part')
            .data(trace.tilt ? ['top', 'sides'] : ['top']);

        pieParts.enter().append('g').attr('class', function(d) {
            return d + ' part';
        });
        pieParts.exit().remove();
        pieParts.order();

        setCoords(cd);

        pieGroup.selectAll('.top').each(function() {
            var slices = d3.select(this).selectAll('g.slice').data(cd);

            slices.enter().append('g')
                .classed('slice', true);
            slices.exit().remove();

            var quadrants = [
                    [[], []], // y&lt;0: x&lt;0, x&gt;=0
                    [[], []] // y&gt;=0: x&lt;0, x&gt;=0
                ],
                hasOutsideText = false;

            slices.each(function(pt) {
                if(pt.hidden) {
                    d3.select(this).selectAll('path,g').remove();
                    return;
                }

                quadrants[pt.pxmid[1] &lt; 0 ? 0 : 1][pt.pxmid[0] &lt; 0 ? 0 : 1].push(pt);

                var cx = cd0.cx + depthVector[0],
                    cy = cd0.cy + depthVector[1],
                    sliceTop = d3.select(this),
                    slicePath = sliceTop.selectAll('path.surface').data([pt]),
                    hasHoverData = false;

                function handleMouseOver(evt) {
                    evt.originalEvent = d3.event;

                    // in case fullLayout or fullData has changed without a replot
                    var fullLayout2 = gd._fullLayout,
                        trace2 = gd._fullData[trace.index],
                        hoverinfo = trace2.hoverinfo;

                    if(hoverinfo === 'all') hoverinfo = 'label+text+value+percent+name';

                    // in case we dragged over the pie from another subplot,
                    // or if hover is turned off
                    if(gd._dragging || fullLayout2.hovermode === false ||
                            hoverinfo === 'none' || hoverinfo === 'skip' || !hoverinfo) {
                        Fx.hover(gd, evt, 'pie');
                        return;
                    }

                    var rInscribed = getInscribedRadiusFraction(pt, cd0),
                        hoverCenterX = cx + pt.pxmid[0] * (1 - rInscribed),
                        hoverCenterY = cy + pt.pxmid[1] * (1 - rInscribed),
                        separators = fullLayout.separators,
                        thisText = [];

                    if(hoverinfo.indexOf('label') !== -1) thisText.push(pt.label);
                    if(hoverinfo.indexOf('text') !== -1) {
                        if(trace2.hovertext) {
                            thisText.push(
                                Array.isArray(trace2.hovertext) ?
                                    trace2.hovertext[pt.i] :
                                    trace2.hovertext
                            );
                        } else if(trace2.text &amp;&amp; trace2.text[pt.i]) {
                            thisText.push(trace2.text[pt.i ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        fullLayout._infolayer.selectAll('.cb' + uid).remove();
    }
}

// loop over the base plot modules present on graph
var basePlotModules = fullLayout._basePlotModules;
for(i = 0; i &lt; basePlotModules.length; i++) {
    basePlotModules[i].<span class="apidocCodeKeywordSpan">plot</span>(gd);
}

// keep reference to shape layers in subplots
var layerSubplot = fullLayout._paper.selectAll('.layer-subplot');
fullLayout._shapeSubplotLayers = layerSubplot.selectAll('.shapelayer');

// styling separate from drawing
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.pie.style" id="apidoc.element.plotly.js.pie.style">
        function <span class="apidocSignatureSpan">plotly.js.pie.</span>style
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function style(gd) {
    gd._fullLayout._pielayer.selectAll('.trace').each(function(cd) {
        var cd0 = cd[0],
            trace = cd0.trace,
            traceSelection = d3.select(this);

        traceSelection.style({opacity: trace.opacity});

        traceSelection.selectAll('.top path.surface').each(function(pt) {
            d3.select(this).call(styleOne, pt, trace);
        });
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    .classed('plotly-notifier', true);

var notes = notifierContainer.selectAll('.notifier-note').data(NOTEDATA);

function killNote(transition) {
    transition
        .duration(700)
        .<span class="apidocCodeKeywordSpan">style</span>('opacity', 0)
        .each('end', function(thisText) {
            var thisIndex = NOTEDATA.indexOf(thisText);
            if(thisIndex !== -1) NOTEDATA.splice(thisIndex, 1);
            d3.select(this).remove();
        });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.pie.styleOne" id="apidoc.element.plotly.js.pie.styleOne">
        function <span class="apidocSignatureSpan">plotly.js.pie.</span>styleOne
        <span class="apidocSignatureSpan">(s, pt, trace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function styleOne(s, pt, trace) {
    var lineColor = trace.marker.line.color;
    if(Array.isArray(lineColor)) lineColor = lineColor[pt.i] || Color.defaultLine;

    var lineWidth = trace.marker.line.width || 0;
    if(Array.isArray(lineWidth)) lineWidth = lineWidth[pt.i] || 0;

    s.style({'stroke-width': lineWidth})
    .call(Color.fill, pt.color)
    .call(Color.stroke, lineColor);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.pie.supplyDefaults" id="apidoc.element.plotly.js.pie.supplyDefaults">
        function <span class="apidocSignatureSpan">plotly.js.pie.</span>supplyDefaults
        <span class="apidocSignatureSpan">(traceIn, traceOut, defaultColor, layout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function supplyDefaults(traceIn, traceOut, defaultColor, layout) {
    function coerce(attr, dflt) {
        return Lib.coerce(traceIn, traceOut, attributes, attr, dflt);
    }

    var coerceFont = Lib.coerceFont;

    var vals = coerce('values');
    if(!Array.isArray(vals) || !vals.length) {
        traceOut.visible = false;
        return;
    }

    var labels = coerce('labels');
    if(!Array.isArray(labels)) {
        coerce('label0');
        coerce('dlabel');
    }

    var lineWidth = coerce('marker.line.width');
    if(lineWidth) coerce('marker.line.color');

    var colors = coerce('marker.colors');
    if(!Array.isArray(colors)) traceOut.marker.colors = []; // later this will get padded with default colors

    coerce('scalegroup');
    // TODO: tilt, depth, and hole all need to be coerced to the same values within a scaleegroup
    // (ideally actually, depth would get set the same *after* scaling, ie the same absolute depth)
    // and if colors aren't specified we should match these up - potentially even if separate pies
    // are NOT in the same sharegroup


    var textData = coerce('text');
    var textInfo = coerce('textinfo', Array.isArray(textData) ? 'text+percent' : 'percent');
    coerce('hovertext');

    coerce('hoverinfo', (layout._dataLength === 1) ? 'label+text+value+percent' : undefined);

    if(textInfo &amp;&amp; textInfo !== 'none') {
        var textPosition = coerce('textposition'),
            hasBoth = Array.isArray(textPosition) || textPosition === 'auto',
            hasInside = hasBoth || textPosition === 'inside',
            hasOutside = hasBoth || textPosition === 'outside';

        if(hasInside || hasOutside) {
            var dfltFont = coerceFont(coerce, 'textfont', layout.font);
            if(hasInside) coerceFont(coerce, 'insidetextfont', dfltFont);
            if(hasOutside) coerceFont(coerce, 'outsidetextfont', dfltFont);
        }
    }

    coerce('domain.x');
    coerce('domain.y');

    // 3D attributes commented out until I finish them in a later PR
    // var tilt = coerce('tilt');
    // if(tilt) {
    //     coerce('tiltaxis');
    //     coerce('depth');
    //     coerce('shading');
    // }

    coerce('hole');

    coerce('sort');
    coerce('direction');
    coerce('rotation');

    coerce('pull');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    gd._replotPending = true;
    return Promise.reject();
} else {
    // we're going ahead with a replot now
    gd._replotPending = false;
}

Plots.<span class="apidocCodeKeywordSpan">supplyDefaults</span>(gd);

var fullLayout = gd._fullLayout;

// Polar plots
if(data &amp;&amp; data[0] &amp;&amp; data[0].r) return plotPolar(gd, data, layout);

// so we don't try to re-call Plotly.plot from inside
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.pie.supplyLayoutDefaults" id="apidoc.element.plotly.js.pie.supplyLayoutDefaults">
        function <span class="apidocSignatureSpan">plotly.js.pie.</span>supplyLayoutDefaults
        <span class="apidocSignatureSpan">(layoutIn, layoutOut)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function supplyLayoutDefaults(layoutIn, layoutOut) {
    function coerce(attr, dflt) {
        return Lib.coerce(layoutIn, layoutOut, layoutAttributes, attr, dflt);
    }
    coerce('hiddenlabels');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

plots.supplyLayoutModuleDefaults = function(layoutIn, layoutOut, fullData, transitionData) {
    var i, _module;

    // can't be be part of basePlotModules loop
    // in order to handle the orphan axes case
    Plotly.Axes.<span class="apidocCodeKeywordSpan">supplyLayoutDefaults</span>(layoutIn, layoutOut, fullData);

    // base plot module layout defaults
    var basePlotModules = layoutOut._basePlotModules;
    for(i = 0; i &lt; basePlotModules.length; i++) {
_module = basePlotModules[i];

// done above already
...</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.plot_config" id="apidoc.module.plotly.js.plot_config">module plotly.js.plot_config</a></h1>






























    <h2>
        <a href="#apidoc.element.plotly.js.plot_config.setBackground" id="apidoc.element.plotly.js.plot_config.setBackground">
        function <span class="apidocSignatureSpan">plotly.js.plot_config.</span>setBackground
        <span class="apidocSignatureSpan">(gd, bgColor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function defaultSetBackground(gd, bgColor) {
    try {
        gd._fullLayout._paper.style('background', bgColor);
    }
    catch(e) {
        if(module.exports.logging &gt; 0) {
            console.error(e);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return gd;
});
};


function opaqueSetBackground(gd, bgColor) {
gd._fullLayout._paperdiv.style('background', 'white');
Plotly.defaultConfig.<span class="apidocCodeKeywordSpan">setBackground</span>(gd, bgColor);
}

function setPlotContext(gd, config) {
if(!gd._context) gd._context = Lib.extendFlat({}, Plotly.defaultConfig);
var context = gd._context;

if(config) {
...</pre></li>
    </ul>
























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.plotly" id="apidoc.module.plotly.js.plotly">module plotly.js.plotly</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.plotly.addFrames" id="apidoc.element.plotly.js.plotly.addFrames">
        function <span class="apidocSignatureSpan">plotly.js.plotly.</span>addFrames
        <span class="apidocSignatureSpan">(gd, frameList, indices)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addFrames = function (gd, frameList, indices) {
    gd = helpers.getGraphDiv(gd);

    var numericNameWarningCount = 0;

    if(frameList === null || frameList === undefined) {
        return Promise.resolve();
    }

    if(!Lib.isPlotDiv(gd)) {
        throw new Error(
            'This element is not a Plotly plot: ' + gd + '. It\'s likely that you\'ve failed ' +
            'to create a plot before adding frames. For more details, see ' +
            'https://plot.ly/javascript/animations/'
        );
    }

    var i, frame, j, idx;
    var _frames = gd._transitionData._frames;
    var _hash = gd._transitionData._frameHash;


    if(!Array.isArray(frameList)) {
        throw new Error('addFrames failure: frameList must be an Array of frame definitions' + frameList);
    }

    // Create a sorted list of insertions since we run into lots of problems if these
    // aren't in ascending order of index:
    //
    // Strictly for sorting. Make sure this is guaranteed to never collide with any
    // already-exisisting indices:
    var bigIndex = _frames.length + frameList.length * 2;

    var insertions = [];
    for(i = frameList.length - 1; i &gt;= 0; i--) {
        if(!Lib.isPlainObject(frameList[i])) continue;

        var name = (_hash[frameList[i].name] || {}).name;
        var newName = frameList[i].name;

        if(name &amp;&amp; newName &amp;&amp; typeof newName === 'number' &amp;&amp; _hash[name]) {
            numericNameWarningCount++;

            Lib.warn('addFrames: overwriting frame "' + _hash[name].name +
                '" with a frame whose name of type "number" also equates to "' +
                name + '". This is valid but may potentially lead to unexpected ' +
                'behavior since all plotly.js frame names are stored internally ' +
                'as strings.');

            if(numericNameWarningCount &gt; 5) {
                Lib.warn('addFrames: This API call has yielded too many warnings. ' +
                    'For the rest of this call, further warnings about numeric frame ' +
                    'names will be suppressed.');
            }
        }

        insertions.push({
            frame: Plots.supplyFrameDefaults(frameList[i]),
            index: (indices &amp;&amp; indices[i] !== undefined &amp;&amp; indices[i] !== null) ? indices[i] : bigIndex + i
        });
    }

    // Sort this, taking note that undefined insertions end up at the end:
    insertions.sort(function(a, b) {
        if(a.index &gt; b.index) return -1;
        if(a.index &lt; b.index) return 1;
        return 0;
    });

    var ops = [];
    var revops = [];
    var frameCount = _frames.length;

    for(i = insertions.length - 1; i &gt;= 0; i--) {
        frame = insertions[i].frame;

        if(typeof frame.name === 'number') {
            Lib.warn('Warning: addFrames accepts frames with numeric names, but the numbers are' +
                'implicitly cast to strings');

        }

        if(!frame.name) {
            // Repeatedly assign a default name, incrementing the counter each time until
            // we get a name that's not in the hashed lookup table:
            while(_hash[(frame.name = 'frame ' + gd._transitionData._counter++)]);
        }

        if(_hash[frame.name]) {
            // If frame is present, overwrite its definition:
            for(j = 0; j &lt; _frames.length; j++) {
                if((_frames[j] || {}).name === frame.name) break;
            }
            ops.push({type: 'replace', index: j, value: frame});
            revops.unshift({type: 'replace', index: j, value: _frames[j]});
        } else {
            // Otherwise insert it at the end of the list:
            idx = Math.max(0, Math.min(insertions[i].index, frameCount));

            ops.push({type: 'insert', index: idx, value: frame});
            revops.unshift({type: 'delete', index: idx});
            frameCount++;
        }
    }

    var undoFunc = Plots.modifyFrames,
        redoFunc = Plots.modifyFrames,
        undoArgs = [gd, revops],
        redoArgs = [gd, ops];

    if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);

    return Plots.modifyFrames(gd ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(!data &amp;&amp; !layout &amp;&amp; !Lib.isPlotDiv(gd)) {
    Lib.warn('Calling Plotly.plot as if redrawing ' +
        'but this container doesn\'t yet have a plot.', gd);
}

function addFrames() {
    if(frames) {
        return Plotly.<span class="apidocCodeKeywordSpan">addFrames</span>(gd, frames);
    }
}

// transfer configuration options to gd until we move over to
// a more OO like model
setPlotContext(gd, config);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plotly.addTraces" id="apidoc.element.plotly.js.plotly.addTraces">
        function <span class="apidocSignatureSpan">plotly.js.plotly.</span>addTraces
        <span class="apidocSignatureSpan">(gd, traces, newIndices)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addTraces(gd, traces, newIndices) {
    gd = helpers.getGraphDiv(gd);

    var currentIndices = [],
        undoFunc = Plotly.deleteTraces,
        redoFunc = addTraces,
        undoArgs = [gd, currentIndices],
        redoArgs = [gd, traces],  // no newIndices here
        i,
        promise;

    // all validation is done elsewhere to remove clutter here
    checkAddTracesArgs(gd, traces, newIndices);

    // make sure traces is an array
    if(!Array.isArray(traces)) {
        traces = [traces];
    }

    // make sure traces do not repeat existing ones
    traces = traces.map(function(trace) {
        return Lib.extendFlat({}, trace);
    });

    helpers.cleanData(traces, gd.data);

    // add the traces to gd.data (no redrawing yet!)
    for(i = 0; i &lt; traces.length; i++) {
        gd.data.push(traces[i]);
    }

    // to continue, we need to call moveTraces which requires currentIndices
    for(i = 0; i &lt; traces.length; i++) {
        currentIndices.push(-traces.length + i);
    }

    // if the user didn't define newIndices, they just want the traces appended
    // i.e., we can simply redraw and be done
    if(typeof newIndices === 'undefined') {
        promise = Plotly.redraw(gd);
        Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
        return promise;
    }

    // make sure indices is property defined
    if(!Array.isArray(newIndices)) {
        newIndices = [newIndices];
    }

    try {

        // this is redundant, but necessary to not catch later possible errors!
        checkMoveTracesArgs(gd, currentIndices, newIndices);
    }
    catch(error) {

        // something went wrong, reset gd to be safe and rethrow error
        gd.data.splice(gd.data.length - traces.length, traces.length);
        throw error;
    }

    // if we're here, the user has defined specific places to place the new traces
    // this requires some extra work that moveTraces will do
    Queue.startSequence(gd);
    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
    promise = Plotly.moveTraces(gd, currentIndices, newIndices);
    Queue.stopSequence(gd);
    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plotly.animate" id="apidoc.element.plotly.js.plotly.animate">
        function <span class="apidocSignatureSpan">plotly.js.plotly.</span>animate
        <span class="apidocSignatureSpan">(gd, frameOrGroupNameOrFrameList, animationOpts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">animate = function (gd, frameOrGroupNameOrFrameList, animationOpts) {
    gd = helpers.getGraphDiv(gd);

    if(!Lib.isPlotDiv(gd)) {
        throw new Error(
            'This element is not a Plotly plot: ' + gd + '. It\'s likely that you\'ve failed ' +
            'to create a plot before animating it. For more details, see ' +
            'https://plot.ly/javascript/animations/'
        );
    }

    var trans = gd._transitionData;

    // This is the queue of frames that will be animated as soon as possible. They
    // are popped immediately upon the *start* of a transition:
    if(!trans._frameQueue) {
        trans._frameQueue = [];
    }

    animationOpts = Plots.supplyAnimationDefaults(animationOpts);
    var transitionOpts = animationOpts.transition;
    var frameOpts = animationOpts.frame;

    // Since frames are popped immediately, an empty queue only means all frames have
    // *started* to transition, not that the animation is complete. To solve that,
    // track a separate counter that increments at the same time as frames are added
    // to the queue, but decrements only when the transition is complete.
    if(trans._frameWaitingCnt === undefined) {
        trans._frameWaitingCnt = 0;
    }

    function getTransitionOpts(i) {
        if(Array.isArray(transitionOpts)) {
            if(i &gt;= transitionOpts.length) {
                return transitionOpts[0];
            } else {
                return transitionOpts[i];
            }
        } else {
            return transitionOpts;
        }
    }

    function getFrameOpts(i) {
        if(Array.isArray(frameOpts)) {
            if(i &gt;= frameOpts.length) {
                return frameOpts[0];
            } else {
                return frameOpts[i];
            }
        } else {
            return frameOpts;
        }
    }

    // Execute a callback after the wrapper function has been called n times.
    // This is used to defer the resolution until a transition has resovled *and*
    // the frame has completed. If it's not done this way, then we get a race
    // condition in which the animation might resolve before a transition is complete
    // or vice versa.
    function callbackOnNthTime(cb, n) {
        var cnt = 0;
        return function() {
            if(cb &amp;&amp; ++cnt === n) {
                return cb();
            }
        };
    }

    return new Promise(function(resolve, reject) {
        function discardExistingFrames() {
            if(trans._frameQueue.length === 0) {
                return;
            }

            while(trans._frameQueue.length) {
                var next = trans._frameQueue.pop();
                if(next.onInterrupt) {
                    next.onInterrupt();
                }
            }

            gd.emit('plotly_animationinterrupted', []);
        }

        function queueFrames(frameList) {
            if(frameList.length === 0) return;

            for(var i = 0; i &lt; frameList.length; i++) {
                var computedFrame;

                if(frameList[i].type === 'byname') {
                    // If it's a named frame, compute it:
                    computedFrame = Plots.computeFrame(gd, frameList[i].name);
                } else {
                    // Otherwise we must have been given a simple object, so treat
                    // the input itself as the computed frame.
                    computedFrame = frameList[i].data;
                }

                var frameOpts = getFrameOpts(i);
                var transitionOpts = getTransitionOpts(i);

                // It doesn't make much sense for the transition duration to be greater than
                // the frame duration, so limit it:
                transitionOpts.duration = Math.min(transitionOpts.duration, frameOpts.duration);

                var nextFrame = {
                    frame: computedFrame,
                    name: frameList[i].name,
                    frameOpts: frameOpts,
                    transitionOpts: transitionOpts,
                };
                if(i === frameList.length - 1) {
                    // The last fr ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plotly.deleteFrames" id="apidoc.element.plotly.js.plotly.deleteFrames">
        function <span class="apidocSignatureSpan">plotly.js.plotly.</span>deleteFrames
        <span class="apidocSignatureSpan">(gd, frameList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteFrames = function (gd, frameList) {
    gd = helpers.getGraphDiv(gd);

    if(!Lib.isPlotDiv(gd)) {
        throw new Error('This element is not a Plotly plot: ' + gd);
    }

    var i, idx;
    var _frames = gd._transitionData._frames;
    var ops = [];
    var revops = [];

    if(!frameList) {
        frameList = [];
        for(i = 0; i &lt; _frames.length; i++) {
            frameList.push(i);
        }
    }

    frameList = frameList.slice(0);
    frameList.sort();

    for(i = frameList.length - 1; i &gt;= 0; i--) {
        idx = frameList[i];
        ops.push({type: 'delete', index: idx});
        revops.unshift({type: 'insert', index: idx, value: _frames[idx]});
    }

    var undoFunc = Plots.modifyFrames,
        redoFunc = Plots.modifyFrames,
        undoArgs = [gd, revops],
        redoArgs = [gd, ops];

    if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);

    return Plots.modifyFrames(gd, ops);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plotly.deleteTraces" id="apidoc.element.plotly.js.plotly.deleteTraces">
        function <span class="apidocSignatureSpan">plotly.js.plotly.</span>deleteTraces
        <span class="apidocSignatureSpan">(gd, indices)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteTraces(gd, indices) {
    gd = helpers.getGraphDiv(gd);

    var traces = [],
        undoFunc = Plotly.addTraces,
        redoFunc = deleteTraces,
        undoArgs = [gd, traces, indices],
        redoArgs = [gd, indices],
        i,
        deletedTrace;

    // make sure indices are defined
    if(typeof indices === 'undefined') {
        throw new Error('indices must be an integer or array of integers.');
    } else if(!Array.isArray(indices)) {
        indices = [indices];
    }
    assertIndexArray(gd, indices, 'indices');

    // convert negative indices to positive indices
    indices = positivifyIndices(indices, gd.data.length - 1);

    // we want descending here so that splicing later doesn't affect indexing
    indices.sort(Lib.sorterDes);
    for(i = 0; i &lt; indices.length; i += 1) {
        deletedTrace = gd.data.splice(indices[i], 1)[0];
        traces.push(deletedTrace);
    }

    var promise = Plotly.redraw(gd);
    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);

    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plotly.extendTraces" id="apidoc.element.plotly.js.plotly.extendTraces">
        function <span class="apidocSignatureSpan">plotly.js.plotly.</span>extendTraces
        <span class="apidocSignatureSpan">(gd, update, indices, maxPoints)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extendTraces(gd, update, indices, maxPoints) {
    gd = helpers.getGraphDiv(gd);

    var undo = spliceTraces(gd, update, indices, maxPoints,

<span class="apidocCodeCommentSpan">                           /*
                            * The Lengthen operation extends trace from end with insert
                            */
</span>                            function(target, insert) {
                                return target.concat(insert);
                            },

                            /*
                             * Window the trace keeping maxPoints, counting back from the end
                             */
                            function(target, maxPoints) {
                                return target.splice(0, target.length - maxPoints);
                            });

    var promise = Plotly.redraw(gd);

    var undoArgs = [gd, undo.update, indices, undo.maxPoints];
    Queue.add(gd, Plotly.prependTraces, undoArgs, extendTraces, arguments);

    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plotly.moveTraces" id="apidoc.element.plotly.js.plotly.moveTraces">
        function <span class="apidocSignatureSpan">plotly.js.plotly.</span>moveTraces
        <span class="apidocSignatureSpan">(gd, currentIndices, newIndices)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function moveTraces(gd, currentIndices, newIndices) {
    gd = helpers.getGraphDiv(gd);

    var newData = [],
        movingTraceMap = [],
        undoFunc = moveTraces,
        redoFunc = moveTraces,
        undoArgs = [gd, newIndices, currentIndices],
        redoArgs = [gd, currentIndices, newIndices],
        i;

    // to reduce complexity here, check args elsewhere
    // this throws errors where appropriate
    checkMoveTracesArgs(gd, currentIndices, newIndices);

    // make sure currentIndices is an array
    currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices];

    // if undefined, define newIndices to point to the end of gd.data array
    if(typeof newIndices === 'undefined') {
        newIndices = [];
        for(i = 0; i &lt; currentIndices.length; i++) {
            newIndices.push(-currentIndices.length + i);
        }
    }

    // make sure newIndices is an array if it's user-defined
    newIndices = Array.isArray(newIndices) ? newIndices : [newIndices];

    // convert negative indices to positive indices (they're the same length)
    currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);
    newIndices = positivifyIndices(newIndices, gd.data.length - 1);

    // at this point, we've coerced the index arrays into predictable forms

    // get the traces that aren't being moved around
    for(i = 0; i &lt; gd.data.length; i++) {

        // if index isn't in currentIndices, include it in ignored!
        if(currentIndices.indexOf(i) === -1) {
            newData.push(gd.data[i]);
        }
    }

    // get a mapping of indices to moving traces
    for(i = 0; i &lt; currentIndices.length; i++) {
        movingTraceMap.push({newIndex: newIndices[i], trace: gd.data[currentIndices[i]]});
    }

    // reorder this mapping by newIndex, ascending
    movingTraceMap.sort(function(a, b) {
        return a.newIndex - b.newIndex;
    });

    // now, add the moving traces back in, in order!
    for(i = 0; i &lt; movingTraceMap.length; i += 1) {
        newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);
    }

    gd.data = newData;

    var promise = Plotly.redraw(gd);
    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);

    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
       throw error;
   }

   // if we're here, the user has defined specific places to place the new traces
   // this requires some extra work that moveTraces will do
   Queue.startSequence(gd);
   Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
   promise = Plotly.<span class="apidocCodeKeywordSpan">moveTraces</span>(gd, currentIndices, newIndices);
   Queue.stopSequence(gd);
   return promise;
};

/**
* Delete traces at `indices` from gd.data array.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plotly.newPlot" id="apidoc.element.plotly.js.plotly.newPlot">
        function <span class="apidocSignatureSpan">plotly.js.plotly.</span>newPlot
        <span class="apidocSignatureSpan">(gd, data, layout, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newPlot = function (gd, data, layout, config) {
    gd = helpers.getGraphDiv(gd);

    // remove gl contexts
    Plots.cleanPlot([], {}, gd._fullData || {}, gd._fullLayout || {});

    Plots.purge(gd);
    return Plotly.plot(gd, data, layout, config);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plotly.plot" id="apidoc.element.plotly.js.plotly.plot">
        function <span class="apidocSignatureSpan">plotly.js.plotly.</span>plot
        <span class="apidocSignatureSpan">(gd, data, layout, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">plot = function (gd, data, layout, config) {
    var frames;

    gd = helpers.getGraphDiv(gd);

    // Events.init is idempotent and bails early if gd has already been init'd
    Events.init(gd);

    if(Lib.isPlainObject(data)) {
        var obj = data;
        data = obj.data;
        layout = obj.layout;
        config = obj.config;
        frames = obj.frames;
    }

    var okToPlot = Events.triggerHandler(gd, 'plotly_beforeplot', [data, layout, config]);
    if(okToPlot === false) return Promise.reject();

    // if there's no data or layout, and this isn't yet a plotly plot
    // container, log a warning to help plotly.js users debug
    if(!data &amp;&amp; !layout &amp;&amp; !Lib.isPlotDiv(gd)) {
        Lib.warn('Calling Plotly.plot as if redrawing ' +
            'but this container doesn\'t yet have a plot.', gd);
    }

    function addFrames() {
        if(frames) {
            return Plotly.addFrames(gd, frames);
        }
    }

    // transfer configuration options to gd until we move over to
    // a more OO like model
    setPlotContext(gd, config);

    if(!layout) layout = {};

    // hook class for plots main container (in case of plotly.js
    // this won't be #embedded-graph or .js-tab-contents)
    d3.select(gd).classed('js-plotly-plot', true);

    // off-screen getBoundingClientRect testing space,
    // in #js-plotly-tester (and stored as gd._tester)
    // so we can share cached text across tabs
    Drawing.makeTester(gd);

    // collect promises for any async actions during plotting
    // any part of the plotting code can push to gd._promises, then
    // before we move to the next step, we check that they're all
    // complete, and empty out the promise list again.
    gd._promises = [];

    var graphWasEmpty = ((gd.data || []).length === 0 &amp;&amp; Array.isArray(data));

    // if there is already data on the graph, append the new data
    // if you only want to redraw, pass a non-array for data
    if(Array.isArray(data)) {
        helpers.cleanData(data, gd.data);

        if(graphWasEmpty) gd.data = data;
        else gd.data.push.apply(gd.data, data);

        // for routines outside graph_obj that want a clean tab
        // (rather than appending to an existing one) gd.empty
        // is used to determine whether to make a new tab
        gd.empty = false;
    }

    if(!gd.layout || graphWasEmpty) gd.layout = helpers.cleanLayout(layout);

    // if the user is trying to drag the axes, allow new data and layout
    // to come in but don't allow a replot.
    if(gd._dragging &amp;&amp; !gd._transitioning) {
        // signal to drag handler that after everything else is done
        // we need to replot, because something has changed
        gd._replotPending = true;
        return Promise.reject();
    } else {
        // we're going ahead with a replot now
        gd._replotPending = false;
    }

    Plots.supplyDefaults(gd);

    var fullLayout = gd._fullLayout;

    // Polar plots
    if(data &amp;&amp; data[0] &amp;&amp; data[0].r) return plotPolar(gd, data, layout);

    // so we don't try to re-call Plotly.plot from inside
    // legend and colorbar, if margins changed
    fullLayout._replotting = true;

    // make or remake the framework if we need to
    if(graphWasEmpty) makePlotFramework(gd);

    // polar need a different framework
    if(gd.framework !== makePlotFramework) {
        gd.framework = makePlotFramework;
        makePlotFramework(gd);
    }

    // save initial show spikes once per graph
    if(graphWasEmpty) Plotly.Axes.saveShowSpikeInitial(gd);

    // prepare the data and find the autorange

    // generate calcdata, if we need to
    // to force redoing calcdata, just delete it before calling Plotly.plot
    var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;
    if(recalc) Plots.doCalcdata(gd);

    // in case it has changed, attach fullData traces to calcdata
    for(var i = 0; i &lt; gd.calcdata.length; i++) {
        gd.calcdata[i][0].trace = gd._fullData[i];
    }

<span class="apidocCodeCommentSpan">    /*
     * start async-friendly code - now we're actually drawing things
     */
</span>
    var oldmargins = ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        fullLayout._infolayer.selectAll('.cb' + uid).remove();
    }
}

// loop over the base plot modules present on graph
var basePlotModules = fullLayout._basePlotModules;
for(i = 0; i &lt; basePlotModules.length; i++) {
    basePlotModules[i].<span class="apidocCodeKeywordSpan">plot</span>(gd);
}

// keep reference to shape layers in subplots
var layerSubplot = fullLayout._paper.selectAll('.layer-subplot');
fullLayout._shapeSubplotLayers = layerSubplot.selectAll('.shapelayer');

// styling separate from drawing
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plotly.prependTraces" id="apidoc.element.plotly.js.plotly.prependTraces">
        function <span class="apidocSignatureSpan">plotly.js.plotly.</span>prependTraces
        <span class="apidocSignatureSpan">(gd, update, indices, maxPoints)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prependTraces(gd, update, indices, maxPoints) {
    gd = helpers.getGraphDiv(gd);

    var undo = spliceTraces(gd, update, indices, maxPoints,

<span class="apidocCodeCommentSpan">                           /*
                            * The Lengthen operation extends trace by appending insert to start
                            */
</span>                            function(target, insert) {
                                return insert.concat(target);
                            },

                            /*
                             * Window the trace keeping maxPoints, counting forward from the start
                             */
                            function(target, maxPoints) {
                                return target.splice(maxPoints, target.length);
                            });

    var promise = Plotly.redraw(gd);

    var undoArgs = [gd, undo.update, indices, undo.maxPoints];
    Queue.add(gd, Plotly.extendTraces, undoArgs, prependTraces, arguments);

    return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plotly.purge" id="apidoc.element.plotly.js.plotly.purge">
        function <span class="apidocSignatureSpan">plotly.js.plotly.</span>purge
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function purge(gd) {
    gd = helpers.getGraphDiv(gd);

    var fullLayout = gd._fullLayout || {},
        fullData = gd._fullData || [];

    // remove gl contexts
    Plots.cleanPlot([], {}, fullData, fullLayout);

    // purge properties
    Plots.purge(gd);

    // purge event emitter methods
    Events.purge(gd);

    // remove plot container
    if(fullLayout._container) fullLayout._container.remove();

    delete gd._context;
    delete gd._replotPending;
    delete gd._mouseDownTime;
    delete gd._legendMouseDownTime;
    delete gd._hmpixcount;
    delete gd._hmlumcount;

    return gd;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
Plotly.newPlot = function(gd, data, layout, config) {
   gd = helpers.getGraphDiv(gd);

   // remove gl contexts
   Plots.cleanPlot([], {}, gd._fullData || {}, gd._fullLayout || {});

   Plots.<span class="apidocCodeKeywordSpan">purge</span>(gd);
   return Plotly.plot(gd, data, layout, config);
};

/**
* Wrap negative indicies to their positive counterparts.
*
* @param {Number[]} indices An array of indices
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plotly.redraw" id="apidoc.element.plotly.js.plotly.redraw">
        function <span class="apidocSignatureSpan">plotly.js.plotly.</span>redraw
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redraw = function (gd) {
    gd = helpers.getGraphDiv(gd);

    if(!Lib.isPlotDiv(gd)) {
        throw new Error('This element is not a Plotly plot: ' + gd);
    }

    helpers.cleanData(gd.data, gd.data);
    helpers.cleanLayout(gd.layout);

    gd.calcdata = undefined;
    return Plotly.plot(gd).then(function() {
        gd.emit('plotly_redraw');
        return gd;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                            /*
                             * Window the trace keeping maxPoints, counting back from the end
                             */
                            function(target, maxPoints) {
                                return target.splice(0, target.length - maxPoints);
                            });

    var promise = Plotly.<span class="apidocCodeKeywordSpan">redraw</span>(gd);

    var undoArgs = [gd, undo.update, indices, undo.maxPoints];
    Queue.add(gd, Plotly.prependTraces, undoArgs, extendTraces, arguments);

    return promise;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plotly.relayout" id="apidoc.element.plotly.js.plotly.relayout">
        function <span class="apidocSignatureSpan">plotly.js.plotly.</span>relayout
        <span class="apidocSignatureSpan">(gd, astr, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function relayout(gd, astr, val) {
    gd = helpers.getGraphDiv(gd);
    helpers.clearPromiseQueue(gd);

    if(gd.framework &amp;&amp; gd.framework.isPolar) {
        return Promise.resolve(gd);
    }

    var aobj = {};
    if(typeof astr === 'string') {
        aobj[astr] = val;
    } else if(Lib.isPlainObject(astr)) {
        aobj = Lib.extendFlat({}, astr);
    } else {
        Lib.warn('Relayout fail.', astr, val);
        return Promise.reject();
    }

    if(Object.keys(aobj).length) gd.changed = true;

    var specs = _relayout(gd, aobj),
        flags = specs.flags;

    // clear calcdata if required
    if(flags.docalc) gd.calcdata = undefined;

    // fill in redraw sequence

    // even if we don't have anything left in aobj,
    // something may have happened within relayout that we
    // need to wait for
    var seq = [Plots.previousPromises];

    if(flags.layoutReplot) {
        seq.push(subroutines.layoutReplot);
    }
    else if(Object.keys(aobj).length) {
        Plots.supplyDefaults(gd);

        if(flags.dolegend) seq.push(subroutines.doLegend);
        if(flags.dolayoutstyle) seq.push(subroutines.layoutStyles);
        if(flags.doticks) seq.push(subroutines.doTicksRelayout);
        if(flags.domodebar) seq.push(subroutines.doModeBar);
        if(flags.docamera) seq.push(subroutines.doCamera);
    }

    seq.push(Plots.rehover);

    Queue.add(gd,
        relayout, [gd, specs.undoit],
        relayout, [gd, specs.redoit]
    );

    var plotDone = Lib.syncOrAsync(seq, gd);
    if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);

    return plotDone.then(function() {
        gd.emit('plotly_relayout', specs.eventData);
        return gd;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

            // autosizing doesn't count as a change that needs saving
            var oldchanged = gd.changed;

            // nor should it be included in the undo queue
            gd.autoplay = true;

            Plotly.<span class="apidocCodeKeywordSpan">relayout</span>(gd, { autosize: true }).then(function() {
                gd.changed = oldchanged;
                resolve(gd);
            });
        }, 100);
    });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plotly.restyle" id="apidoc.element.plotly.js.plotly.restyle">
        function <span class="apidocSignatureSpan">plotly.js.plotly.</span>restyle
        <span class="apidocSignatureSpan">(gd, astr, val, traces)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function restyle(gd, astr, val, traces) {
    gd = helpers.getGraphDiv(gd);
    helpers.clearPromiseQueue(gd);

    var aobj = {};
    if(typeof astr === 'string') aobj[astr] = val;
    else if(Lib.isPlainObject(astr)) {
        // the 3-arg form
        aobj = Lib.extendFlat({}, astr);
        if(traces === undefined) traces = val;
    }
    else {
        Lib.warn('Restyle fail.', astr, val, traces);
        return Promise.reject();
    }

    if(Object.keys(aobj).length) gd.changed = true;

    var specs = _restyle(gd, aobj, traces),
        flags = specs.flags;

    // clear calcdata if required
    if(flags.clearCalc) gd.calcdata = undefined;

    // fill in redraw sequence
    var seq = [];

    if(flags.fullReplot) {
        seq.push(Plotly.plot);
    } else {
        seq.push(Plots.previousPromises);

        Plots.supplyDefaults(gd);

        if(flags.dostyle) seq.push(subroutines.doTraceStyle);
        if(flags.docolorbars) seq.push(subroutines.doColorBars);
    }

    seq.push(Plots.rehover);

    Queue.add(gd,
        restyle, [gd, specs.undoit, specs.traces],
        restyle, [gd, specs.redoit, specs.traces]
    );

    var plotDone = Lib.syncOrAsync(seq, gd);
    if(!plotDone || !plotDone.then) plotDone = Promise.resolve();

    return plotDone.then(function() {
        gd.emit('plotly_restyle', specs.eventData);
        return gd;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plotly.update" id="apidoc.element.plotly.js.plotly.update">
        function <span class="apidocSignatureSpan">plotly.js.plotly.</span>update
        <span class="apidocSignatureSpan">(gd, traceUpdate, layoutUpdate, traces)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function update(gd, traceUpdate, layoutUpdate, traces) {
    gd = helpers.getGraphDiv(gd);
    helpers.clearPromiseQueue(gd);

    if(gd.framework &amp;&amp; gd.framework.isPolar) {
        return Promise.resolve(gd);
    }

    if(!Lib.isPlainObject(traceUpdate)) traceUpdate = {};
    if(!Lib.isPlainObject(layoutUpdate)) layoutUpdate = {};

    if(Object.keys(traceUpdate).length) gd.changed = true;
    if(Object.keys(layoutUpdate).length) gd.changed = true;

    var restyleSpecs = _restyle(gd, Lib.extendFlat({}, traceUpdate), traces),
        restyleFlags = restyleSpecs.flags;

    var relayoutSpecs = _relayout(gd, Lib.extendFlat({}, layoutUpdate)),
        relayoutFlags = relayoutSpecs.flags;

    // clear calcdata if required
    if(restyleFlags.clearCalc || relayoutFlags.docalc) gd.calcdata = undefined;

    // fill in redraw sequence
    var seq = [];

    if(restyleFlags.fullReplot &amp;&amp; relayoutFlags.layoutReplot) {
        var data = gd.data,
            layout = gd.layout;

        // clear existing data/layout on gd
        // so that Plotly.plot doesn't try to extend them
        gd.data = undefined;
        gd.layout = undefined;

        seq.push(function() { return Plotly.plot(gd, data, layout); });
    }
    else if(restyleFlags.fullReplot) {
        seq.push(Plotly.plot);
    }
    else if(relayoutFlags.layoutReplot) {
        seq.push(subroutines.layoutReplot);
    }
    else {
        seq.push(Plots.previousPromises);
        Plots.supplyDefaults(gd);

        if(restyleFlags.dostyle) seq.push(subroutines.doTraceStyle);
        if(restyleFlags.docolorbars) seq.push(subroutines.doColorBars);
        if(relayoutFlags.dolegend) seq.push(subroutines.doLegend);
        if(relayoutFlags.dolayoutstyle) seq.push(subroutines.layoutStyles);
        if(relayoutFlags.doticks) seq.push(subroutines.doTicksRelayout);
        if(relayoutFlags.domodebar) seq.push(subroutines.doModeBar);
        if(relayoutFlags.doCamera) seq.push(subroutines.doCamera);
    }

    seq.push(Plots.rehover);

    Queue.add(gd,
        update, [gd, restyleSpecs.undoit, relayoutSpecs.undoit, restyleSpecs.traces],
        update, [gd, restyleSpecs.redoit, relayoutSpecs.redoit, restyleSpecs.traces]
    );

    var plotDone = Lib.syncOrAsync(seq, gd);
    if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);

    return plotDone.then(function() {
        gd.emit('plotly_update', {
            data: restyleSpecs.eventData,
            layout: relayoutSpecs.eventData
        });

        return gd;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var pkg = require('../../package.json');


module.exports = function updateVersion(pathToFile) {
    fs.readFile(pathToFile, 'utf-8', function(err, code) {
        var out = falafel(code, function(node) {
            if(isVersionNode(node)) node.<span class="apidocCodeKeywordSpan">update</span>('\'' + pkg.version + &amp;#
x27;\'');
        });

        fs.writeFile(pathToFile, out, function(err) {
            if(err) throw err;
        });
    });
};
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.plots" id="apidoc.module.plotly.js.plots">module plotly.js.plots</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.plots._hasPlotType" id="apidoc.element.plotly.js.plots._hasPlotType">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>_hasPlotType
        <span class="apidocSignatureSpan">(category)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_hasPlotType = function (category) {
    var basePlotModules = this._basePlotModules || [];

    for(var i = 0; i &lt; basePlotModules.length; i++) {
        var _module = basePlotModules[i];

        if(_module.name === category) return true;
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.addLinks" id="apidoc.element.plotly.js.plots.addLinks">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>addLinks
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addLinks = function (gd) {
    // Do not do anything if showLink and showSources are not set to true in config
    if(!gd._context.showLink &amp;&amp; !gd._context.showSources) return;

    var fullLayout = gd._fullLayout;

    var linkContainer = fullLayout._paper
        .selectAll('text.js-plot-link-container').data([0]);

    linkContainer.enter().append('text')
        .classed('js-plot-link-container', true)
        .style({
            'font-family': '"Open Sans", Arial, sans-serif',
            'font-size': '12px',
            'fill': Color.defaultLine,
            'pointer-events': 'all'
        })
        .each(function() {
            var links = d3.select(this);
            links.append('tspan').classed('js-link-to-tool', true);
            links.append('tspan').classed('js-link-spacer', true);
            links.append('tspan').classed('js-sourcelinks', true);
        });

    // The text node inside svg
    var text = linkContainer.node(),
        attrs = {
            y: fullLayout._paper.attr('height') - 9
        };

    // If text's width is bigger than the layout
    // Check that text is a child node or document.body
    // because otherwise IE/Edge might throw an exception
    // when calling getComputedTextLength().
    // Apparently offsetParent is null for invisibles.
    if(document.body.contains(text) &amp;&amp; text.getComputedTextLength() &gt;= (fullLayout.width - 20)) {
        // Align the text at the left
        attrs['text-anchor'] = 'start';
        attrs.x = 5;
    }
    else {
        // Align the text at the right
        attrs['text-anchor'] = 'end';
        attrs.x = fullLayout._paper.attr('width') - 7;
    }

    linkContainer.attr(attrs);

    var toolspan = linkContainer.select('.js-link-to-tool'),
        spacespan = linkContainer.select('.js-link-spacer'),
        sourcespan = linkContainer.select('.js-sourcelinks');

    if(gd._context.showSources) gd._context.showSources(gd);

    // 'view in plotly' link for embedded plots
    if(gd._context.showLink) positionPlayWithData(gd, toolspan);

    // separator if we have both sources and tool link
    spacespan.text((toolspan.text() &amp;&amp; sourcespan.text()) ? ' - ' : '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    Plots.style(gd);

    // show annotations and shapes
    Registry.getComponentMethod('shapes', 'draw')(gd);
    Registry.getComponentMethod('annotations', 'draw')(gd);

    // source links
    Plots.<span class="apidocCodeKeywordSpan">addLinks</span>(gd);

    // Mark the first render as complete
    fullLayout._replotting = false;

    return Plots.previousPromises(gd);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.autoMargin" id="apidoc.element.plotly.js.plots.autoMargin">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>autoMargin
        <span class="apidocSignatureSpan">(gd, id, o)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">autoMargin = function (gd, id, o) {
    var fullLayout = gd._fullLayout;

    if(!fullLayout._pushmargin) fullLayout._pushmargin = {};

    if(fullLayout.margin.autoexpand !== false) {
        if(!o) delete fullLayout._pushmargin[id];
        else {
            var pad = o.pad === undefined ? 12 : o.pad;

            // if the item is too big, just give it enough automargin to
            // make sure you can still grab it and bring it back
            if(o.l + o.r &gt; fullLayout.width * 0.5) o.l = o.r = 0;
            if(o.b + o.t &gt; fullLayout.height * 0.5) o.b = o.t = 0;

            fullLayout._pushmargin[id] = {
                l: {val: o.x, size: o.l + pad},
                r: {val: o.x, size: o.r + pad},
                b: {val: o.y, size: o.b + pad},
                t: {val: o.y, size: o.t + pad}
            };
        }

        if(!fullLayout._replotting) plots.doAutoMargin(gd);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    Registry.getComponentMethod('sliders', 'draw')(gd);
    Registry.getComponentMethod('updatemenus', 'draw')(gd);

    for(i = 0; i &lt; calcdata.length; i++) {
        cd = calcdata[i];
        trace = cd[0].trace;
        if(trace.visible !== true || !trace._module.colorbar) {
            Plots.<span class="apidocCodeKeywordSpan">autoMargin</span>(gd, 'cb' + trace.uid);
        }
        else trace._module.colorbar(gd, cd);
    }

    Plots.doAutoMargin(gd);
    return Plots.previousPromises(gd);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.cleanPlot" id="apidoc.element.plotly.js.plots.cleanPlot">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>cleanPlot
        <span class="apidocSignatureSpan">(newFullData, newFullLayout, oldFullData, oldFullLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanPlot = function (newFullData, newFullLayout, oldFullData, oldFullLayout) {
    var i, j;

    var basePlotModules = oldFullLayout._basePlotModules || [];
    for(i = 0; i &lt; basePlotModules.length; i++) {
        var _module = basePlotModules[i];

        if(_module.clean) {
            _module.clean(newFullData, newFullLayout, oldFullData, oldFullLayout);
        }
    }

    var hasPaper = !!oldFullLayout._paper;
    var hasInfoLayer = !!oldFullLayout._infolayer;

    oldLoop:
    for(i = 0; i &lt; oldFullData.length; i++) {
        var oldTrace = oldFullData[i],
            oldUid = oldTrace.uid;

        for(j = 0; j &lt; newFullData.length; j++) {
            var newTrace = newFullData[j];

            if(oldUid === newTrace.uid) continue oldLoop;
        }

        var query = (
            '.hm' + oldUid +
            ',.contour' + oldUid +
            ',.carpet' + oldUid +
            ',#clip' + oldUid +
            ',.trace' + oldUid
        );

        // clean old heatmap, contour traces and clip paths
        // that rely on uid identifiers
        if(hasPaper) {
            oldFullLayout._paper.selectAll(query).remove();
        }

        // clean old colorbars and range slider plot
        if(hasInfoLayer) {
            oldFullLayout._infolayer.selectAll('.cb' + oldUid).remove();

            oldFullLayout._infolayer.selectAll('g.rangeslider-container')
                .selectAll(query).remove();
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {Object} layout
* @param {Object} config
*/
Plotly.newPlot = function(gd, data, layout, config) {
   gd = helpers.getGraphDiv(gd);

   // remove gl contexts
   Plots.<span class="apidocCodeKeywordSpan">cleanPlot</span>([], {}, gd._fullData || {}, gd._fullLayout || {});

   Plots.purge(gd);
   return Plotly.plot(gd, data, layout, config);
};

/**
* Wrap negative indicies to their positive counterparts.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.computeAPICommandBindings" id="apidoc.element.plotly.js.plots.computeAPICommandBindings">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>computeAPICommandBindings
        <span class="apidocSignatureSpan">(gd, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">computeAPICommandBindings = function (gd, method, args) {
    var bindings;

    if(!Array.isArray(args)) args = [];

    switch(method) {
        case 'restyle':
            bindings = computeDataBindings(gd, args);
            break;
        case 'relayout':
            bindings = computeLayoutBindings(gd, args);
            break;
        case 'update':
            bindings = computeDataBindings(gd, [args[0], args[2]])
                .concat(computeLayoutBindings(gd, [args[1]]));
            break;
        case 'animate':
            bindings = computeAnimateBindings(gd, args);
            break;
        default:
            // This is the case where intelligent logic about what affects
            // this command is not implemented. It causes no ill effects.
            // For example, addFrames simply won't bind to a control component.
            bindings = [];
    }
    return bindings;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if(!Array.isArray(args)) args = [];

// If any command has no method, refuse to bind:
if(!method) {
    return false;
}
var bindings = exports.<span class="apidocCodeKeywordSpan">computeAPICommandBindings</span>(gd, method, args);

// Right now, handle one and *only* one property being set:
if(bindings.length !== 1) {
    return false;
}

if(!refBinding) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.computeFrame" id="apidoc.element.plotly.js.plots.computeFrame">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>computeFrame
        <span class="apidocSignatureSpan">(gd, frameName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">computeFrame = function (gd, frameName) {
    var frameLookup = gd._transitionData._frameHash;
    var i, traceIndices, traceIndex, destIndex;

    // Null or undefined will fail on .toString(). We'll allow numbers since we
    // make it clear frames must be given string names, but we'll allow numbers
    // here since they're otherwise fine for looking up frames as long as they're
    // properly cast to strings. We really just want to ensure here that this
    // 1) doesn't fail, and
    // 2) doens't give an incorrect answer (which String(frameName) would)
    if(!frameName) {
        throw new Error('computeFrame must be given a string frame name');
    }

    var framePtr = frameLookup[frameName.toString()];

    // Return false if the name is invalid:
    if(!framePtr) {
        return false;
    }

    var frameStack = [framePtr];
    var frameNameStack = [framePtr.name];

    // Follow frame pointers:
    while(framePtr.baseframe &amp;&amp; (framePtr = frameLookup[framePtr.baseframe.toString()])) {
        // Avoid infinite loops:
        if(frameNameStack.indexOf(framePtr.name) !== -1) break;

        frameStack.push(framePtr);
        frameNameStack.push(framePtr.name);
    }

    // A new object for the merged result:
    var result = {};

    // Merge, starting with the last and ending with the desired frame:
    while((framePtr = frameStack.pop())) {
        if(framePtr.layout) {
            result.layout = plots.extendLayout(result.layout, framePtr.layout);
        }

        if(framePtr.data) {
            if(!result.data) {
                result.data = [];
            }
            traceIndices = framePtr.traces;

            if(!traceIndices) {
                // If not defined, assume serial order starting at zero
                traceIndices = [];
                for(i = 0; i &lt; framePtr.data.length; i++) {
                    traceIndices[i] = i;
                }
            }

            if(!result.traces) {
                result.traces = [];
            }

            for(i = 0; i &lt; framePtr.data.length; i++) {
                // Loop through this frames data, find out where it should go,
                // and merge it!
                traceIndex = traceIndices[i];
                if(traceIndex === undefined || traceIndex === null) {
                    continue;
                }

                destIndex = result.traces.indexOf(traceIndex);
                if(destIndex === -1) {
                    destIndex = result.data.length;
                    result.traces[destIndex] = traceIndex;
                }

                result.data[destIndex] = plots.extendTrace(result.data[destIndex], framePtr.data[i]);
            }
        }
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if(frameList.length === 0) return;

            for(var i = 0; i &lt; frameList.length; i++) {
var computedFrame;

if(frameList[i].type === 'byname') {
    // If it's a named frame, compute it:
    computedFrame = Plots.<span class="apidocCodeKeywordSpan">computeFrame</span>(gd, frameList[i].name);
} else {
    // Otherwise we must have been given a simple object, so treat
    // the input itself as the computed frame.
    computedFrame = frameList[i].data;
}

var frameOpts = getFrameOpts(i);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.createTransitionData" id="apidoc.element.plotly.js.plots.createTransitionData">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>createTransitionData
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createTransitionData = function (gd) {
    // Set up the default keyframe if it doesn't exist:
    if(!gd._transitionData) {
        gd._transitionData = {};
    }

    if(!gd._transitionData._frames) {
        gd._transitionData._frames = [];
    }

    if(!gd._transitionData._frameHash) {
        gd._transitionData._frameHash = {};
    }

    if(!gd._transitionData._counter) {
        gd._transitionData._counter = 0;
    }

    if(!gd._transitionData._interruptCallbacks) {
        gd._transitionData._interruptCallbacks = [];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var oldFullData = gd._fullData || [],
newFullData = gd._fullData = [],
newData = gd.data || [];

    var i;

    // Create all the storage space for frames, but only if doesn't already exist
    if(!gd._transitionData) plots.<span class="apidocCodeKeywordSpan">createTransitionData</span>(gd);

    // first fill in what we can of layout without looking at data
    // because fullData needs a few things from layout

    if(oldFullLayout._initialAutoSizeIsDone) {

// coerce the updated layout while preserving width and height
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.doAutoMargin" id="apidoc.element.plotly.js.plots.doAutoMargin">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>doAutoMargin
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doAutoMargin = function (gd) {
    var fullLayout = gd._fullLayout;
    if(!fullLayout._size) fullLayout._size = {};
    if(!fullLayout._pushmargin) fullLayout._pushmargin = {};

    var gs = fullLayout._size,
        oldmargins = JSON.stringify(gs);

    // adjust margins for outside components
    // fullLayout.margin is the requested margin,
    // fullLayout._size has margins and plotsize after adjustment
    var ml = Math.max(fullLayout.margin.l || 0, 0),
        mr = Math.max(fullLayout.margin.r || 0, 0),
        mt = Math.max(fullLayout.margin.t || 0, 0),
        mb = Math.max(fullLayout.margin.b || 0, 0),
        pm = fullLayout._pushmargin;

    if(fullLayout.margin.autoexpand !== false) {

        // fill in the requested margins
        pm.base = {
            l: {val: 0, size: ml},
            r: {val: 1, size: mr},
            t: {val: 1, size: mt},
            b: {val: 0, size: mb}
        };

        // now cycle through all the combinations of l and r
        // (and t and b) to find the required margins

        var pmKeys = Object.keys(pm);

        for(var i = 0; i &lt; pmKeys.length; i++) {
            var k1 = pmKeys[i];

            var pushleft = pm[k1].l || {},
                pushbottom = pm[k1].b || {},
                fl = pushleft.val,
                pl = pushleft.size,
                fb = pushbottom.val,
                pb = pushbottom.size;

            for(var j = 0; j &lt; pmKeys.length; j++) {
                var k2 = pmKeys[j];

                if(isNumeric(pl) &amp;&amp; pm[k2].r) {
                    var fr = pm[k2].r.val,
                        pr = pm[k2].r.size;

                    if(fr &gt; fl) {
                        var newl = (pl * fr +
                                (pr - fullLayout.width) * fl) / (fr - fl),
                            newr = (pr * (1 - fl) +
                                (pl - fullLayout.width) * (1 - fr)) / (fr - fl);
                        if(newl &gt;= 0 &amp;&amp; newr &gt;= 0 &amp;&amp; newl + newr &gt; ml + mr) {
                            ml = newl;
                            mr = newr;
                        }
                    }
                }

                if(isNumeric(pb) &amp;&amp; pm[k2].t) {
                    var ft = pm[k2].t.val,
                        pt = pm[k2].t.size;

                    if(ft &gt; fb) {
                        var newb = (pb * ft +
                                (pt - fullLayout.height) * fb) / (ft - fb),
                            newt = (pt * (1 - fb) +
                                (pb - fullLayout.height) * (1 - ft)) / (ft - fb);
                        if(newb &gt;= 0 &amp;&amp; newt &gt;= 0 &amp;&amp; newb + newt &gt; mb + mt) {
                            mb = newb;
                            mt = newt;
                        }
                    }
                }
            }
        }
    }

    gs.l = Math.round(ml);
    gs.r = Math.round(mr);
    gs.t = Math.round(mt);
    gs.b = Math.round(mb);
    gs.p = Math.round(fullLayout.margin.pad);
    gs.w = Math.round(fullLayout.width) - gs.l - gs.r;
    gs.h = Math.round(fullLayout.height) - gs.t - gs.b;

    // if things changed and we're not already redrawing, trigger a redraw
    if(!fullLayout._replotting &amp;&amp; oldmargins !== '{}' &amp;&amp;
            oldmargins !== JSON.stringify(fullLayout._size)) {
        return Plotly.plot(gd);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        trace = cd[0].trace;
        if(trace.visible !== true || !trace._module.colorbar) {
            Plots.autoMargin(gd, 'cb' + trace.uid);
        }
        else trace._module.colorbar(gd, cd);
    }

    Plots.<span class="apidocCodeKeywordSpan">doAutoMargin</span>(gd);
    return Plots.previousPromises(gd);
}

// in case the margins changed, draw margin pushers again
function marginPushersAgain() {
    var seq = JSON.stringify(fullLayout._size) === oldmargins ?
        [] :
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.doCalcdata" id="apidoc.element.plotly.js.plots.doCalcdata">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>doCalcdata
        <span class="apidocSignatureSpan">(gd, traces)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doCalcdata = function (gd, traces) {
    var axList = Plotly.Axes.list(gd),
        fullData = gd._fullData,
        fullLayout = gd._fullLayout;

    var trace, _module, i, j;

    var hasCategoryAxis = false;

    // XXX: Is this correct? Needs a closer look so that *some* traces can be recomputed without
    // *all* needing doCalcdata:
    var calcdata = new Array(fullData.length);
    var oldCalcdata = (gd.calcdata || []).slice(0);
    gd.calcdata = calcdata;

    // extra helper variables
    // firstscatter: fill-to-next on the first trace goes to zero
    gd.firstscatter = true;

    // how many box plots do we have (in case they're grouped)
    gd.numboxes = 0;

    // for calculating avg luminosity of heatmaps
    gd._hmpixcount = 0;
    gd._hmlumcount = 0;

    // for sharing colors across pies (and for legend)
    fullLayout._piecolormap = {};
    fullLayout._piedefaultcolorcount = 0;

    // initialize the category list, if there is one, so we start over
    // to be filled in later by ax.d2c
    for(i = 0; i &lt; axList.length; i++) {
        axList[i]._categories = axList[i]._initialCategories.slice();

        // Build the lookup map for initialized categories
        axList[i]._categoriesMap = {};
        for(j = 0; j &lt; axList[i]._categories.length; j++) {
            axList[i]._categoriesMap[axList[i]._categories[j]] = j;
        }

        if(axList[i].type === 'category') hasCategoryAxis = true;
    }

    // If traces were specified and this trace was not included,
    // then transfer it over from the old calcdata:
    for(i = 0; i &lt; fullData.length; i++) {
        if(Array.isArray(traces) &amp;&amp; traces.indexOf(i) === -1) {
            calcdata[i] = oldCalcdata[i];
            continue;
        }
    }

    var hasCalcTransform = false;

    // transform loop
    for(i = 0; i &lt; fullData.length; i++) {
        trace = fullData[i];

        if(trace.visible === true &amp;&amp; trace.transforms) {
            _module = trace._module;

            // we need one round of trace module calc before
            // the calc transform to 'fill in' the categories list
            // used for example in the data-to-coordinate method
            if(_module &amp;&amp; _module.calc) _module.calc(gd, trace);

            for(j = 0; j &lt; trace.transforms.length; j++) {
                var transform = trace.transforms[j];

                _module = transformsRegistry[transform.type];
                if(_module &amp;&amp; _module.calcTransform) {
                    hasCalcTransform = true;
                    _module.calcTransform(gd, trace, transform);
                }
            }
        }
    }

    // clear stuff that should recomputed in 'regular' loop
    if(hasCalcTransform) {
        for(i = 0; i &lt; axList.length; i++) {
            axList[i]._min = [];
            axList[i]._max = [];
            axList[i]._categories = [];
            // Reset the look up map
            axList[i]._categoriesMap = {};
        }
    }

    // 'regular' loop
    for(i = 0; i &lt; fullData.length; i++) {
        var cd = [];

        trace = fullData[i];

        if(trace.visible === true) {
            _module = trace._module;
            if(_module &amp;&amp; _module.calc) cd = _module.calc(gd, trace);
        }

        // Make sure there is a first point.
        //
        // This ensures there is a calcdata item for every trace,
        // even if cartesian logic doesn't handle it (for things like legends).
        if(!Array.isArray(cd) || !cd[0]) {
            cd = [{x: BADNUM, y: BADNUM}];
        }

        // add the trace-wide properties to the first point,
        // per point properties to every point
        // t is the holder for trace-wide properties
        if(!cd[0].t) cd[0].t = {};
        cd[0].trace = trace;

        calcdata[i] = cd;
    }

    // To handle the case of components using category names as coordinates, we
    // need to re-supply defaults for these objects now, after calc has
    // finished populating the category mappings
    // Any component that uses `Axes.coercePosition` falls into this category
    if(hasCategoryAxis) {
        var dataRe ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(graphWasEmpty) Plotly.Axes.saveShowSpikeInitial(gd);

// prepare the data and find the autorange

// generate calcdata, if we need to
// to force redoing calcdata, just delete it before calling Plotly.plot
var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;
if(recalc) Plots.<span class="apidocCodeKeywordSpan">doCalcdata</span>(gd);

// in case it has changed, attach fullData traces to calcdata
for(var i = 0; i &lt; gd.calcdata.length; i++) {
    gd.calcdata[i][0].trace = gd._fullData[i];
}

/*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.executeAPICommand" id="apidoc.element.plotly.js.plots.executeAPICommand">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>executeAPICommand
        <span class="apidocSignatureSpan">(gd, method, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">executeAPICommand = function (gd, method, args) {
    var apiMethod = Plotly[method];

    var allArgs = [gd];

    if(!Array.isArray(args)) args = [];

    for(var i = 0; i &lt; args.length; i++) {
        allArgs.push(args[i]);
    }

    return apiMethod.apply(null, allArgs).catch(function(err) {
        Lib.warn('API call to Plotly.' + method + ' rejected.', err);
        return Promise.reject(err);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.extendLayout" id="apidoc.element.plotly.js.plots.extendLayout">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>extendLayout
        <span class="apidocSignatureSpan">(destLayout, srcLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendLayout = function (destLayout, srcLayout) {
    return plots.extendObjectWithContainers(destLayout, srcLayout, plots.layoutArrayContainers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    // A new object for the merged result:
    var result = {};

    // Merge, starting with the last and ending with the desired frame:
    while((framePtr = frameStack.pop())) {
if(framePtr.layout) {
    result.layout = plots.<span class="apidocCodeKeywordSpan">extendLayout</span>(result.layout, framePtr.layout);
}

if(framePtr.data) {
    if(!result.data) {
        result.data = [];
    }
    traceIndices = framePtr.traces;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.extendObjectWithContainers" id="apidoc.element.plotly.js.plots.extendObjectWithContainers">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>extendObjectWithContainers
        <span class="apidocSignatureSpan">(dest, src, containerPaths)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendObjectWithContainers = function (dest, src, containerPaths) {
    var containerProp, containerVal, i, j, srcProp, destProp, srcContainer, destContainer;
    var copy = Lib.extendDeepNoArrays({}, src || {});
    var expandedObj = Lib.expandObjectPaths(copy);
    var containerObj = {};

    // Step through and extract any container properties. Otherwise extendDeepNoArrays
    // will clobber any existing properties with an empty array and then supplyDefaults
    // will reset everything to defaults.
    if(containerPaths &amp;&amp; containerPaths.length) {
        for(i = 0; i &lt; containerPaths.length; i++) {
            containerProp = Lib.nestedProperty(expandedObj, containerPaths[i]);
            containerVal = containerProp.get();

            if(containerVal === undefined) {
                Lib.nestedProperty(containerObj, containerPaths[i]).set(null);
            }
            else {
                containerProp.set(null);
                Lib.nestedProperty(containerObj, containerPaths[i]).set(containerVal);
            }
        }
    }

    dest = Lib.extendDeepNoArrays(dest || {}, expandedObj);

    if(containerPaths &amp;&amp; containerPaths.length) {
        for(i = 0; i &lt; containerPaths.length; i++) {
            srcProp = Lib.nestedProperty(containerObj, containerPaths[i]);
            srcContainer = srcProp.get();

            if(!srcContainer) continue;

            destProp = Lib.nestedProperty(dest, containerPaths[i]);
            destContainer = destProp.get();

            if(!Array.isArray(destContainer)) {
                destContainer = [];
                destProp.set(destContainer);
            }

            for(j = 0; j &lt; srcContainer.length; j++) {
                var srcObj = srcContainer[j];

                if(srcObj === null) destContainer[j] = null;
                else {
                    destContainer[j] = plots.extendObjectWithContainers(destContainer[j], srcObj);
                }
            }

            destProp.set(destContainer);
        }
    }

    return dest;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }

        for(j = 0; j &lt; srcContainer.length; j++) {
            var srcObj = srcContainer[j];

            if(srcObj === null) destContainer[j] = null;
            else {
                destContainer[j] = plots.<span class="apidocCodeKeywordSpan">extendObjectWithContainers</span>(destContainer[j],
srcObj);
            }
        }

        destProp.set(destContainer);
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.extendTrace" id="apidoc.element.plotly.js.plots.extendTrace">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>extendTrace
        <span class="apidocSignatureSpan">(destTrace, srcTrace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extendTrace = function (destTrace, srcTrace) {
    return plots.extendObjectWithContainers(destTrace, srcTrace, plots.dataArrayContainers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

                destIndex = result.traces.indexOf(traceIndex);
                if(destIndex === -1) {
                    destIndex = result.data.length;
                    result.traces[destIndex] = traceIndex;
                }

                result.data[destIndex] = plots.<span class="apidocCodeKeywordSpan">extendTrace</span>(result.data[destIndex], framePtr
.data[i]);
            }
        }
    }

    return result;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.findSubplotIds" id="apidoc.element.plotly.js.plots.findSubplotIds">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>findSubplotIds
        <span class="apidocSignatureSpan">(data, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findSubplotIds(data, type) {
    var subplotIds = [];

    if(!plots.subplotsRegistry[type]) return subplotIds;

    var attr = plots.subplotsRegistry[type].attr;

    for(var i = 0; i &lt; data.length; i++) {
        var trace = data[i];

        if(plots.traceIs(trace, type) &amp;&amp; subplotIds.indexOf(trace[attr]) === -1) {
            subplotIds.push(trace[attr]);
        }
    }

    return subplotIds;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
module.exports = function handleSubplotDefaults(layoutIn, layoutOut, fullData, opts) {
var subplotType = opts.type,
    subplotAttributes = opts.attributes,
    handleDefaults = opts.handleDefaults,
    partition = opts.partition || 'x';

var ids = Plots.<span class="apidocCodeKeywordSpan">findSubplotIds</span>(fullData, subplotType),
    idsLength = ids.length;

var subplotLayoutIn, subplotLayoutOut;

function coerce(attr, dflt) {
    return Lib.coerce(subplotLayoutIn, subplotLayoutOut, subplotAttributes, attr, dflt);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.generalUpdatePerTraceModule" id="apidoc.element.plotly.js.plots.generalUpdatePerTraceModule">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>generalUpdatePerTraceModule
        <span class="apidocSignatureSpan">(subplot, subplotCalcData, subplotLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generalUpdatePerTraceModule = function (subplot, subplotCalcData, subplotLayout) {
    var traceHashOld = subplot.traceHash,
        traceHash = {},
        i;

    function filterVisible(calcDataIn) {
        var calcDataOut = [];

        for(var i = 0; i &lt; calcDataIn.length; i++) {
            var calcTrace = calcDataIn[i],
                trace = calcTrace[0].trace;

            if(trace.visible === true) calcDataOut.push(calcTrace);
        }

        return calcDataOut;
    }

    // build up moduleName -&gt; calcData hash
    for(i = 0; i &lt; subplotCalcData.length; i++) {
        var calcTraces = subplotCalcData[i],
            trace = calcTraces[0].trace;

        // skip over visible === false traces
        // as they don't have `_module` ref
        if(trace.visible) {
            traceHash[trace.type] = traceHash[trace.type] || [];
            traceHash[trace.type].push(calcTraces);
        }
    }

    var moduleNamesOld = Object.keys(traceHashOld);
    var moduleNames = Object.keys(traceHash);

    // when a trace gets deleted, make sure that its module's
    // plot method is called so that it is properly
    // removed from the DOM.
    for(i = 0; i &lt; moduleNamesOld.length; i++) {
        var moduleName = moduleNamesOld[i];

        if(moduleNames.indexOf(moduleName) === -1) {
            var fakeCalcTrace = traceHashOld[moduleName][0],
                fakeTrace = fakeCalcTrace[0].trace;

            fakeTrace.visible = false;
            traceHash[moduleName] = [fakeCalcTrace];
        }
    }

    // update list of module names to include 'fake' traces added above
    moduleNames = Object.keys(traceHash);

    // call module plot method
    for(i = 0; i &lt; moduleNames.length; i++) {
        var moduleCalcData = traceHash[moduleNames[i]],
            _module = moduleCalcData[0][0].trace._module;

        _module.plot(subplot, filterVisible(moduleCalcData), subplotLayout);
    }

    // update moduleName -&gt; calcData hash
    subplot.traceHash = traceHash;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// TODO handle topojson-is-loading case
// to avoid making multiple request while streaming
};

proto.onceTopojsonIsLoaded = function(geoCalcData, geoLayout) {
this.drawLayout(geoLayout);

Plots.<span class="apidocCodeKeywordSpan">generalUpdatePerTraceModule</span>(this, geoCalcData, geoLayout);

this.render();
};

proto.makeProjection = function(geoLayout) {
var projLayout = geoLayout.projection,
    projType = projLayout.type,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.getComponentMethod" id="apidoc.element.plotly.js.plots.getComponentMethod">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>getComponentMethod
        <span class="apidocSignatureSpan">(name, method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComponentMethod = function (name, method) {
    var _module = exports.componentsRegistry[name];

    if(!_module) return noop;
    return _module[method] || noop;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * dateTick0: get the canonical tick for this calendar
 *
 * bool sunday is for week ticks, shift it to a Sunday.
 */
exports.dateTick0 = function(calendar, sunday) {
    if(isWorldCalendar(calendar)) {
        return sunday ?
            Registry.<span class="apidocCodeKeywordSpan">getComponentMethod</span>('calendars', 'CANONICAL_SUNDAY
')[calendar] :
            Registry.getComponentMethod('calendars', 'CANONICAL_TICK')[calendar];
    }
    else {
        return sunday ? '2000-01-02' : '2000-01-01';
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.getModule" id="apidoc.element.plotly.js.plots.getModule">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>getModule
        <span class="apidocSignatureSpan">(trace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getModule = function (trace) {
    if(trace.r !== undefined) {
        Loggers.warn('Tried to put a polar trace ' +
            'on an incompatible graph of cartesian ' +
            'data. Ignoring this dataset.', trace
        );
        return false;
    }

    var _module = exports.modules[getTraceType(trace)];
    if(!_module) return false;
    return _module._module;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var attr = subplotsRegistry[subplotType].attr;

if(attr) coerceSubplotAttr(subplotType, attr);
    }

    if(visible) {
var _module = plots.<span class="apidocCodeKeywordSpan">getModule</span>(traceOut);
traceOut._module = _module;

// gets overwritten in pie, geo and ternary modules
coerce('hoverinfo', (layout._dataLength === 1) ? 'x+y+z+text' : undefined);

if(plots.traceIs(traceOut, 'showLegend')) {
    coerce('showlegend');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.getSubplotCalcData" id="apidoc.element.plotly.js.plots.getSubplotCalcData">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>getSubplotCalcData
        <span class="apidocSignatureSpan">(calcData, type, subplotId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSubplotCalcData = function (calcData, type, subplotId) {
    if(!plots.subplotsRegistry[type]) return [];

    var attr = plots.subplotsRegistry[type].attr;
    var subplotCalcData = [];

    for(var i = 0; i &lt; calcData.length; i++) {
        var calcTrace = calcData[i],
            trace = calcTrace[0].trace;

        if(trace[attr] === subplotId) subplotCalcData.push(calcTrace);
    }

    return subplotCalcData;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var c = require('./constants');

exports.name = 'parcoords';

exports.attr = 'type';

exports.plot = function(gd) {
var calcData = Plots.<span class="apidocCodeKeywordSpan">getSubplotCalcData</span>(gd.calcdata, 'parcoords', 'parcoords
');
if(calcData.length) parcoordsPlot(gd, calcData);
};

exports.clean = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {
var hadParcoords = (oldFullLayout._has &amp;&amp; oldFullLayout._has('parcoords'));
var hasParcoords = (newFullLayout._has &amp;&amp; newFullLayout._has('parcoords'));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.getSubplotData" id="apidoc.element.plotly.js.plots.getSubplotData">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>getSubplotData
        <span class="apidocSignatureSpan">(data, type, subplotId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSubplotData(data, type, subplotId) {
    if(!plots.subplotsRegistry[type]) return [];

    var attr = plots.subplotsRegistry[type].attr,
        subplotData = [],
        trace;

    for(var i = 0; i &lt; data.length; i++) {
        trace = data[i];

        if(type === 'gl2d' &amp;&amp; plots.traceIs(trace, 'gl2d')) {
            var spmatch = Plotly.Axes.subplotMatch,
                subplotX = 'x' + subplotId.match(spmatch)[1],
                subplotY = 'y' + subplotId.match(spmatch)[2];

            if(trace[attr[0]] === subplotX &amp;&amp; trace[attr[1]] === subplotY) {
                subplotData.push(trace);
            }
        }
        else {
            if(trace[attr] === subplotId) subplotData.push(trace);
        }
    }

    return subplotData;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.getSubplotIds" id="apidoc.element.plotly.js.plots.getSubplotIds">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>getSubplotIds
        <span class="apidocSignatureSpan">(layout, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getSubplotIds(layout, type) {
    var _module = plots.subplotsRegistry[type];

    if(!_module) return [];

    // layout must be 'fullLayout' here
    if(type === 'cartesian' &amp;&amp; (!layout._has || !layout._has('cartesian'))) return [];
    if(type === 'gl2d' &amp;&amp; (!layout._has || !layout._has('gl2d'))) return [];
    if(type === 'cartesian' || type === 'gl2d') {
        return Object.keys(layout._plots || {});
    }

    var idRegex = _module.idRegex,
        layoutKeys = Object.keys(layout),
        subplotIds = [];

    for(var i = 0; i &lt; layoutKeys.length; i++) {
        var layoutKey = layoutKeys[i];

        if(idRegex.test(layoutKey)) subplotIds.push(layoutKey);
    }

    // order the ids
    var idLen = _module.idRoot.length;
    subplotIds.sort(function(a, b) {
        var aNum = +(a.substr(idLen) || 1),
            bNum = +(b.substr(idLen) || 1);
        return aNum - bNum;
    });

    return subplotIds;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(!layout.scene) layout.scene = layout.scene1;
delete layout.scene1;
    }

    /*
     * Clean up Scene layouts
     */
    var sceneIds = Plots.<span class="apidocCodeKeywordSpan">getSubplotIds</span>(layout, 'gl3d');
    for(i = 0; i &lt; sceneIds.length; i++) {
var scene = layout[sceneIds[i]];

// clean old Camera coords
var cameraposition = scene.cameraposition;
if(Array.isArray(cameraposition) &amp;&amp; cameraposition[0].length === 4) {
    var rotation = cameraposition[0],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.graphJson" id="apidoc.element.plotly.js.plots.graphJson">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>graphJson
        <span class="apidocSignatureSpan">(gd, dataonly, mode, output, useDefaults)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphJson = function (gd, dataonly, mode, output, useDefaults) {
    // if the defaults aren't supplied yet, we need to do that...
    if((useDefaults &amp;&amp; dataonly &amp;&amp; !gd._fullData) ||
            (useDefaults &amp;&amp; !dataonly &amp;&amp; !gd._fullLayout)) {
        plots.supplyDefaults(gd);
    }

    var data = (useDefaults) ? gd._fullData : gd.data,
        layout = (useDefaults) ? gd._fullLayout : gd.layout,
        frames = (gd._transitionData || {})._frames;

    function stripObj(d) {
        if(typeof d === 'function') {
            return null;
        }
        if(Lib.isPlainObject(d)) {
            var o = {}, v, src;
            for(v in d) {
                // remove private elements and functions
                // _ is for private, [ is a mistake ie [object Object]
                if(typeof d[v] === 'function' ||
                        ['_', '['].indexOf(v.charAt(0)) !== -1) {
                    continue;
                }

                // look for src/data matches and remove the appropriate one
                if(mode === 'keepdata') {
                    // keepdata: remove all ...src tags
                    if(v.substr(v.length - 3) === 'src') {
                        continue;
                    }
                }
                else if(mode === 'keepstream') {
                    // keep sourced data if it's being streamed.
                    // similar to keepref, but if the 'stream' object exists
                    // in a trace, we will keep the data array.
                    src = d[v + 'src'];
                    if(typeof src === 'string' &amp;&amp; src.indexOf(':') &gt; 0) {
                        if(!Lib.isPlainObject(d.stream)) {
                            continue;
                        }
                    }
                }
                else if(mode !== 'keepall') {
                    // keepref: remove sourced data but only
                    // if the source tag is well-formed
                    src = d[v + 'src'];
                    if(typeof src === 'string' &amp;&amp; src.indexOf(':') &gt; 0) {
                        continue;
                    }
                }

                // OK, we're including this... recurse into it
                o[v] = stripObj(d[v]);
            }
            return o;
        }

        if(Array.isArray(d)) {
            return d.map(stripObj);
        }

        // convert native dates to date strings...
        // mostly for external users exporting to plotly
        if(Lib.isJSDate(d)) return Lib.ms2DateTimeLocal(+d);

        return d;
    }

    var obj = {
        data: (data || []).map(function(v) {
            var d = stripObj(v);
            // fit has some little arrays in it that don't contain data,
            // just fit params and meta
            if(dataonly) { delete d.fit; }
            return d;
        })
    };
    if(!dataonly) { obj.layout = stripObj(layout); }

    if(gd.framework &amp;&amp; gd.framework.isPolar) obj = gd.framework.getConfig();

    if(frames) obj.frames = stripObj(frames);

    return (output === 'object') ? obj : JSON.stringify(obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var hiddenformInput = hiddenform
        .append('input')
        .attr({
            type: 'text',
            name: 'data'
        });

    hiddenformInput.node().value = plots.<span class="apidocCodeKeywordSpan">graphJson</span>(gd, false, 'keepdata');
    hiddenform.node().submit();
    hiddenformDiv.remove();

    gd.emit('plotly_afterexport');
    return false;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.hasSimpleAPICommandBindings" id="apidoc.element.plotly.js.plots.hasSimpleAPICommandBindings">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>hasSimpleAPICommandBindings
        <span class="apidocSignatureSpan">(gd, commandList, bindingsByValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasSimpleAPICommandBindings = function (gd, commandList, bindingsByValue) {
    var i;
    var n = commandList.length;

    var refBinding;

    for(i = 0; i &lt; n; i++) {
        var binding;
        var command = commandList[i];
        var method = command.method;
        var args = command.args;

        if(!Array.isArray(args)) args = [];

        // If any command has no method, refuse to bind:
        if(!method) {
            return false;
        }
        var bindings = exports.computeAPICommandBindings(gd, method, args);

        // Right now, handle one and *only* one property being set:
        if(bindings.length !== 1) {
            return false;
        }

        if(!refBinding) {
            refBinding = bindings[0];
            if(Array.isArray(refBinding.traces)) {
                refBinding.traces.sort();
            }
        } else {
            binding = bindings[0];
            if(binding.type !== refBinding.type) {
                return false;
            }
            if(binding.prop !== refBinding.prop) {
                return false;
            }
            if(Array.isArray(refBinding.traces)) {
                if(Array.isArray(binding.traces)) {
                    binding.traces.sort();
                    for(var j = 0; j &lt; refBinding.traces.length; j++) {
                        if(refBinding.traces[j] !== binding.traces[j]) {
                            return false;
                        }
                    }
                } else {
                    return false;
                }
            } else {
                if(binding.prop !== refBinding.prop) {
                    return false;
                }
            }
        }

        binding = bindings[0];
        var value = binding.value;
        if(Array.isArray(value)) {
            if(value.length === 1) {
                value = value[0];
            } else {
                return false;
            }
        }
        if(bindingsByValue) {
            bindingsByValue[value] = i;
        }
    }

    return refBinding;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(!ret.cache) {
    ret.cache = {};
}

// Either create or just recompute this:
ret.lookupTable = {};

var binding = exports.<span class="apidocCodeKeywordSpan">hasSimpleAPICommandBindings</span>(gd, commandList, ret.lookupTable);

if(container &amp;&amp; container._commandObserver) {
    if(!binding) {
        // If container exists and there are no longer any bindings,
        // remove existing:
        if(container._commandObserver.remove) {
            container._commandObserver.remove();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.linkSubplots" id="apidoc.element.plotly.js.plots.linkSubplots">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>linkSubplots
        <span class="apidocSignatureSpan">(newFullData, newFullLayout, oldFullData, oldFullLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">linkSubplots = function (newFullData, newFullLayout, oldFullData, oldFullLayout) {
    var oldSubplots = oldFullLayout._plots || {},
        newSubplots = newFullLayout._plots = {};

    var mockGd = {
        _fullData: newFullData,
        _fullLayout: newFullLayout
    };

    var ids = Plotly.Axes.getSubplots(mockGd);

    for(var i = 0; i &lt; ids.length; i++) {
        var id = ids[i],
            oldSubplot = oldSubplots[id],
            plotinfo;

        if(oldSubplot) {
            plotinfo = newSubplots[id] = oldSubplot;

            if(plotinfo._scene2d) {
                plotinfo._scene2d.updateRefs(newFullLayout);
            }
        }
        else {
            plotinfo = newSubplots[id] = {};
            plotinfo.id = id;
        }

        plotinfo.xaxis = Plotly.Axes.getFromId(mockGd, id, 'x');
        plotinfo.yaxis = Plotly.Axes.getFromId(mockGd, id, 'y');
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
newFullLayout._hasTernary = newFullLayout._has('ternary');
newFullLayout._hasPie = newFullLayout._has('pie');

// clean subplots and other artifacts from previous plot calls
plots.cleanPlot(newFullData, newFullLayout, oldFullData, oldFullLayout);

// relink / initialize subplot axis objects
plots.<span class="apidocCodeKeywordSpan">linkSubplots</span>(newFullData, newFullLayout, oldFullData, oldFullLayout);

// relink functions and _ attributes to promote consistency between plots
relinkPrivateKeys(newFullLayout, oldFullLayout);

// TODO may return a promise
plots.doAutoMargin(gd);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.manageCommandObserver" id="apidoc.element.plotly.js.plots.manageCommandObserver">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>manageCommandObserver
        <span class="apidocSignatureSpan">(gd, container, commandList, onchange)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">manageCommandObserver = function (gd, container, commandList, onchange) {
    var ret = {};
    var enabled = true;

    if(container &amp;&amp; container._commandObserver) {
        ret = container._commandObserver;
    }

    if(!ret.cache) {
        ret.cache = {};
    }

    // Either create or just recompute this:
    ret.lookupTable = {};

    var binding = exports.hasSimpleAPICommandBindings(gd, commandList, ret.lookupTable);

    if(container &amp;&amp; container._commandObserver) {
        if(!binding) {
            // If container exists and there are no longer any bindings,
            // remove existing:
            if(container._commandObserver.remove) {
                container._commandObserver.remove();
                container._commandObserver = null;
                return ret;
            }
        } else {
            // If container exists and there *are* bindings, then the lookup
            // table should have been updated and check is already attached,
            // so there's nothing to be done:
            return ret;


        }
    }

    // Determine whether there's anything to do for this binding:

    if(binding) {
        // Build the cache:
        bindingValueHasChanged(gd, binding, ret.cache);

        ret.check = function check() {
            if(!enabled) return;

            var update = bindingValueHasChanged(gd, binding, ret.cache);

            if(update.changed &amp;&amp; onchange) {
                // Disable checks for the duration of this command in order to avoid
                // infinite loops:
                if(ret.lookupTable[update.value] !== undefined) {
                    ret.disable();
                    Promise.resolve(onchange({
                        value: update.value,
                        type: binding.type,
                        prop: binding.prop,
                        traces: binding.traces,
                        index: ret.lookupTable[update.value]
                    })).then(ret.enable, ret.enable);
                }
            }

            return update.changed;
        };

        var checkEvents = [
            'plotly_relayout',
            'plotly_redraw',
            'plotly_restyle',
            'plotly_update',
            'plotly_animatingframe',
            'plotly_afterplot'
        ];

        for(var i = 0; i &lt; checkEvents.length; i++) {
            gd._internalOn(checkEvents[i], ret.check);
        }

        ret.remove = function() {
            for(var i = 0; i &lt; checkEvents.length; i++) {
                gd._removeInternalListener(checkEvents[i], ret.check);
            }
        };
    } else {
        // TODO: It'd be really neat to actually give a *reason* for this, but at least a warning
        // is a start
        Lib.warn('Unable to automatically bind plot updates to API command');

        ret.lookupTable = {};
        ret.remove = function() {};
    }

    ret.disable = function disable() {
        enabled = false;
    };

    ret.enable = function enable() {
        enabled = true;
    };

    if(container) {
        container._commandObserver = ret;
    }

    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.modifyFrames" id="apidoc.element.plotly.js.plots.modifyFrames">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>modifyFrames
        <span class="apidocSignatureSpan">(gd, operations)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">modifyFrames = function (gd, operations) {
    var i, op, frame;
    var _frames = gd._transitionData._frames;
    var _hash = gd._transitionData._frameHash;

    for(i = 0; i &lt; operations.length; i++) {
        op = operations[i];

        switch(op.type) {
            // No reason this couldn't exist, but is currently unused/untested:
<span class="apidocCodeCommentSpan">            /* case 'rename':
                frame = _frames[op.index];
                delete _hash[frame.name];
                _hash[op.name] = frame;
                frame.name = op.name;
                break;*/
</span>            case 'replace':
                frame = op.value;
                var oldName = (_frames[op.index] || {}).name;
                var newName = frame.name;
                _frames[op.index] = _hash[newName] = frame;

                if(newName !== oldName) {
                    // If name has changed in addition to replacement, then update
                    // the lookup table:
                    delete _hash[oldName];
                    _hash[newName] = frame;
                }

                break;
            case 'insert':
                frame = op.value;
                _hash[frame.name] = frame;
                _frames.splice(op.index, 0, frame);
                break;
            case 'delete':
                frame = _frames[op.index];
                delete _hash[frame.name];
                _frames.splice(op.index, 1);
                break;
        }
    }

    return Promise.resolve();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   var undoFunc = Plots.modifyFrames,
       redoFunc = Plots.modifyFrames,
       undoArgs = [gd, revops],
       redoArgs = [gd, ops];

   if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);

   return Plots.<span class="apidocCodeKeywordSpan">modifyFrames</span>(gd, ops);
};

/**
* Delete frame
*
* @param {string id or DOM element} gd
*      the id or DOM element of the graph container div
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.plotAutoSize" id="apidoc.element.plotly.js.plots.plotAutoSize">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>plotAutoSize
        <span class="apidocSignatureSpan">(gd, layout, fullLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function plotAutoSize(gd, layout, fullLayout) {
    var context = gd._context || {},
        frameMargins = context.frameMargins,
        newWidth,
        newHeight;

    var isPlotDiv = Lib.isPlotDiv(gd);

    if(isPlotDiv) gd.emit('plotly_autosize');

    // embedded in an iframe - just take the full iframe size
    // if we get to this point, with no aspect ratio restrictions
    if(context.fillFrame) {
        newWidth = window.innerWidth;
        newHeight = window.innerHeight;

        // somehow we get a few extra px height sometimes...
        // just hide it
        document.body.style.overflow = 'hidden';
    }
    else if(isNumeric(frameMargins) &amp;&amp; frameMargins &gt; 0) {
        var reservedMargins = calculateReservedMargins(gd._boundingBoxMargins),
            reservedWidth = reservedMargins.left + reservedMargins.right,
            reservedHeight = reservedMargins.bottom + reservedMargins.top,
            factor = 1 - 2 * frameMargins;

        var gdBB = fullLayout._container &amp;&amp; fullLayout._container.node ?
            fullLayout._container.node().getBoundingClientRect() : {
                width: fullLayout.width,
                height: fullLayout.height
            };

        newWidth = Math.round(factor * (gdBB.width - reservedWidth));
        newHeight = Math.round(factor * (gdBB.height - reservedHeight));
    }
    else {
        // plotly.js - let the developers do what they want, either
        // provide height and width for the container div,
        // specify size in layout, or take the defaults,
        // but don't enforce any ratio restrictions
        var computedStyle = isPlotDiv ? window.getComputedStyle(gd) : {};

        newWidth = parseFloat(computedStyle.width) || fullLayout.width;
        newHeight = parseFloat(computedStyle.height) || fullLayout.height;
    }

    var minWidth = plots.layoutAttributes.width.min,
        minHeight = plots.layoutAttributes.height.min;
    if(newWidth &lt; minWidth) newWidth = minWidth;
    if(newHeight &lt; minHeight) newHeight = minHeight;

    var widthHasChanged = !layout.width &amp;&amp;
            (Math.abs(fullLayout.width - newWidth) &gt; 1),
        heightHasChanged = !layout.height &amp;&amp;
            (Math.abs(fullLayout.height - newHeight) &gt; 1);

    if(heightHasChanged || widthHasChanged) {
        if(widthHasChanged) fullLayout.width = newWidth;
        if(heightHasChanged) fullLayout.height = newHeight;
    }

    // cache initial autosize value, used in relayout when
    // width or height values are set to null
    if(!gd._initialAutoSize) {
        gd._initialAutoSize = { width: newWidth, height: newHeight };
    }

    plots.sanitizeMargins(fullLayout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
}

var oldWidth = fullLayout.width,
    oldHeight = fullLayout.height;

// calculate autosizing
if(gd.layout.autosize) Plots.<span class="apidocCodeKeywordSpan">plotAutoSize</span>(gd, gd.layout, fullLayout);

// avoid unnecessary redraws
var hasSizechanged = aobj.height || aobj.width ||
    (fullLayout.width !== oldWidth) ||
    (fullLayout.height !== oldHeight);

if(hasSizechanged) flags.docalc = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.previousPromises" id="apidoc.element.plotly.js.plots.previousPromises">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>previousPromises
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">previousPromises = function (gd) {
    if((gd._promises || []).length) {
        return Promise.all(gd._promises)
            .then(function() { gd._promises = []; });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if(trace.visible !== true || !trace._module.colorbar) {
            Plots.autoMargin(gd, 'cb' + trace.uid);
        }
        else trace._module.colorbar(gd, cd);
    }

    Plots.doAutoMargin(gd);
    return Plots.<span class="apidocCodeKeywordSpan">previousPromises</span>(gd);
}

// in case the margins changed, draw margin pushers again
function marginPushersAgain() {
    var seq = JSON.stringify(fullLayout._size) === oldmargins ?
        [] :
        [marginPushers, subroutines.layoutStyles];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.purge" id="apidoc.element.plotly.js.plots.purge">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>purge
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">purge = function (gd) {

    // note: we DO NOT remove _context because it doesn't change when we insert
    // a new plot, and may have been set outside of our scope.

    var fullLayout = gd._fullLayout || {};
    if(fullLayout._glcontainer !== undefined) fullLayout._glcontainer.remove();
    if(fullLayout._geocontainer !== undefined) fullLayout._geocontainer.remove();

    // remove modebar
    if(fullLayout._modeBar) fullLayout._modeBar.destroy();

    if(gd._transitionData) {
        // Ensure any dangling callbacks are simply dropped if the plot is purged.
        // This is more or less only actually important for testing.
        if(gd._transitionData._interruptCallbacks) {
            gd._transitionData._interruptCallbacks.length = 0;
        }

        if(gd._transitionData._animationRaf) {
            window.cancelAnimationFrame(gd._transitionData._animationRaf);
        }
    }

    // data and layout
    delete gd.data;
    delete gd.layout;
    delete gd._fullData;
    delete gd._fullLayout;
    delete gd.calcdata;
    delete gd.framework;
    delete gd.empty;

    delete gd.fid;

    delete gd.undoqueue; // action queue
    delete gd.undonum;
    delete gd.autoplay; // are we doing an action that doesn't go in undo queue?
    delete gd.changed;

    // these get recreated on Plotly.plot anyway, but just to be safe
    // (and to have a record of them...)
    delete gd._tester;
    delete gd._testref;
    delete gd._promises;
    delete gd._redrawTimer;
    delete gd.firstscatter;
    delete gd.hmlumcount;
    delete gd.hmpixcount;
    delete gd.numboxes;
    delete gd._hoverTimer;
    delete gd._lastHoverTime;
    delete gd._transitionData;
    delete gd._transitioning;
    delete gd._initialAutoSize;

    // remove all event listeners
    if(gd.removeAllListeners) gd.removeAllListeners();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/
Plotly.newPlot = function(gd, data, layout, config) {
   gd = helpers.getGraphDiv(gd);

   // remove gl contexts
   Plots.cleanPlot([], {}, gd._fullData || {}, gd._fullLayout || {});

   Plots.<span class="apidocCodeKeywordSpan">purge</span>(gd);
   return Plotly.plot(gd, data, layout, config);
};

/**
* Wrap negative indicies to their positive counterparts.
*
* @param {Number[]} indices An array of indices
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.recomputeFrameHash" id="apidoc.element.plotly.js.plots.recomputeFrameHash">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>recomputeFrameHash
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">recomputeFrameHash = function (gd) {
    var hash = gd._transitionData._frameHash = {};
    var frames = gd._transitionData._frames;
    for(var i = 0; i &lt; frames.length; i++) {
        var frame = frames[i];
        if(frame &amp;&amp; frame.name) {
            hash[frame.name] = frame;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.redrawText" id="apidoc.element.plotly.js.plots.redrawText">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>redrawText
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">redrawText = function (gd) {

    // do not work if polar is present
    if((gd.data &amp;&amp; gd.data[0] &amp;&amp; gd.data[0].r)) return;

    return new Promise(function(resolve) {
        setTimeout(function() {
            Registry.getComponentMethod('annotations', 'draw')(gd);
            Registry.getComponentMethod('legend', 'draw')(gd);

            (gd.calcdata || []).forEach(function(d) {
                if(d[0] &amp;&amp; d[0].t &amp;&amp; d[0].t.cb) d[0].t.cb();
            });

            resolve(plots.previousPromises(gd));
        }, 300);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.register" id="apidoc.element.plotly.js.plots.register">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>register
        <span class="apidocSignatureSpan">(_module, thisType, categoriesIn, meta)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">register = function (_module, thisType, categoriesIn, meta) {
    if(exports.modules[thisType]) {
        Loggers.log('Type ' + thisType + ' already registered');
        return;
    }

    var categoryObj = {};
    for(var i = 0; i &lt; categoriesIn.length; i++) {
        categoryObj[categoriesIn[i]] = true;
        exports.allCategories[categoriesIn[i]] = true;
    }

    exports.modules[thisType] = {
        _module: _module,
        categories: categoryObj
    };

    if(meta &amp;&amp; Object.keys(meta).length) {
        exports.modules[thisType].meta = meta;
    }

    exports.allTypes.push(thisType);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
If you would like to manually pick which plotly.js modules to include, you can create a *custom* bundle by using `plotly.js/lib/
core`, and loading only the trace types that you need (e.g. `pie` or `choropleth`). The recommended way to do this is by creating
 a *bundling file*:

```javascript
// in custom-plotly.js
var Plotly = require('plotly.js/lib/core');

// Load in the trace types for pie, and choropleth
Plotly.<span class="apidocCodeKeywordSpan">register</span>([
    require('plotly.js/lib/pie'),
    require('plotly.js/lib/choropleth')
]);

module.exports = Plotly;
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.registerComponent" id="apidoc.element.plotly.js.plots.registerComponent">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>registerComponent
        <span class="apidocSignatureSpan">(_module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerComponent = function (_module) {
    var name = _module.name;

    exports.componentsRegistry[name] = _module;

    if(_module.layoutAttributes) {
        if(_module.layoutAttributes._isLinkedToArray) {
            pushUnique(exports.layoutArrayContainers, name);
        }
        findArrayRegexps(_module);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function registerComponentModule(newModule) {
    if(typeof newModule.name !== 'string') {
        throw new Error('Component module *name* must be a string.');
    }

    Registry.<span class="apidocCodeKeywordSpan">registerComponent</span>(newModule);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.registerSubplot" id="apidoc.element.plotly.js.plots.registerSubplot">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>registerSubplot
        <span class="apidocSignatureSpan">(_module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerSubplot = function (_module) {
    var plotType = _module.name;

    if(exports.subplotsRegistry[plotType]) {
        Loggers.log('Plot type ' + plotType + ' already registered.');
        return;
    }

    // relayout array handling will look for component module methods with this
    // name and won't find them because this is a subplot module... but that
    // should be fine, it will just fall back on redrawing the plot.
    findArrayRegexps(_module);

    // not sure what's best for the 'cartesian' type at this point
    exports.subplotsRegistry[plotType] = _module;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
};

function registerTraceModule(newModule) {
Registry.register(newModule, newModule.name, newModule.categories, newModule.meta);

if(!Registry.subplotsRegistry[newModule.basePlotModule.name]) {
    Registry.<span class="apidocCodeKeywordSpan">registerSubplot</span>(newModule.basePlotModule);
}
}

function registerTransformModule(newModule) {
if(typeof newModule.name !== 'string') {
    throw new Error('Transform module *name* must be a string.');
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.rehover" id="apidoc.element.plotly.js.plots.rehover">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>rehover
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rehover = function (gd) {
    if(gd._fullLayout._rehover) {
        gd._fullLayout._rehover();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.resize" id="apidoc.element.plotly.js.plots.resize">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>resize
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resize = function (gd) {
    return new Promise(function(resolve, reject) {

        if(!gd || d3.select(gd).style('display') === 'none') {
            reject(new Error('Resize must be passed a plot div element.'));
        }

        if(gd._redrawTimer) clearTimeout(gd._redrawTimer);

        gd._redrawTimer = setTimeout(function() {
            // return if there is nothing to resize
            if(gd.layout.width &amp;&amp; gd.layout.height) {
                resolve(gd);
                return;
            }

            delete gd.layout.width;
            delete gd.layout.height;

            // autosizing doesn't count as a change that needs saving
            var oldchanged = gd.changed;

            // nor should it be included in the undo queue
            gd.autoplay = true;

            Plotly.relayout(gd, { autosize: true }).then(function() {
                gd.changed = oldchanged;
                resolve(gd);
            });
        }, 100);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.sanitizeMargins" id="apidoc.element.plotly.js.plots.sanitizeMargins">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>sanitizeMargins
        <span class="apidocSignatureSpan">(fullLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitizeMargins = function (fullLayout) {
    // polar doesn't do margins...
    if(!fullLayout || !fullLayout.margin) return;

    var width = fullLayout.width,
        height = fullLayout.height,
        margin = fullLayout.margin,
        plotWidth = width - (margin.l + margin.r),
        plotHeight = height - (margin.t + margin.b),
        correction;

    // if margin.l + margin.r = 0 then plotWidth &gt; 0
    // as width &gt;= 10 by supplyDefaults
    // similarly for margin.t + margin.b

    if(plotWidth &lt; 0) {
        correction = (width - 1) / (margin.l + margin.r);
        margin.l = Math.floor(correction * margin.l);
        margin.r = Math.floor(correction * margin.r);
    }

    if(plotHeight &lt; 0) {
        correction = (height - 1) / (margin.t + margin.b);
        margin.t = Math.floor(correction * margin.t);
        margin.b = Math.floor(correction * margin.b);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    var missingWidthOrHeight = (!newLayout.width || !newLayout.height),
        autosize = newFullLayout.autosize,
        autosizable = gd._context &amp;&amp; gd._context.autosizable,
        initialAutoSize = missingWidthOrHeight &amp;&amp; (autosize || autosizable);

    if(initialAutoSize) plots.plotAutoSize(gd, newLayout, newFullLayout);
    else if(missingWidthOrHeight) plots.<span class="apidocCodeKeywordSpan">sanitizeMargins</span>(gd);

    // for backwards-compatibility with Plotly v1.x.x
    if(!autosize &amp;&amp; missingWidthOrHeight) {
        newLayout.width = newFullLayout.width;
        newLayout.height = newFullLayout.height;
    }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.sendDataToCloud" id="apidoc.element.plotly.js.plots.sendDataToCloud">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>sendDataToCloud
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sendDataToCloud = function (gd) {
    gd.emit('plotly_beforeexport');

    var baseUrl = (window.PLOTLYENV &amp;&amp; window.PLOTLYENV.BASE_URL) || 'https://plot.ly';

    var hiddenformDiv = d3.select(gd)
        .append('div')
        .attr('id', 'hiddenform')
        .style('display', 'none');

    var hiddenform = hiddenformDiv
        .append('form')
        .attr({
            action: baseUrl + '/external',
            method: 'post',
            target: '_blank'
        });

    var hiddenformInput = hiddenform
        .append('input')
        .attr({
            type: 'text',
            name: 'data'
        });

    hiddenformInput.node().value = plots.graphJson(gd, false, 'keepdata');
    hiddenform.node().submit();
    hiddenformDiv.remove();

    gd.emit('plotly_afterexport');
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        'class': 'link--impt link--embedview',
        'font-weight': 'bold'
    })
    .text(gd._context.linkText + ' ' + String.fromCharCode(187));

if(gd._context.sendData) {
    link.on('click', function() {
        plots.<span class="apidocCodeKeywordSpan">sendDataToCloud</span>(gd);
    });
}
else {
    var path = window.location.pathname.split('/');
    var query = window.location.search;
    link.attr({
        'xlink:xlink:show': 'new',
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.style" id="apidoc.element.plotly.js.plots.style">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>style
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">style = function (gd) {
    var _modules = gd._fullLayout._modules;

    for(var i = 0; i &lt; _modules.length; i++) {
        var _module = _modules[i];

        if(_module.style) _module.style(gd);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    .classed('plotly-notifier', true);

var notes = notifierContainer.selectAll('.notifier-note').data(NOTEDATA);

function killNote(transition) {
    transition
        .duration(700)
        .<span class="apidocCodeKeywordSpan">style</span>('opacity', 0)
        .each('end', function(thisText) {
            var thisIndex = NOTEDATA.indexOf(thisText);
            if(thisIndex !== -1) NOTEDATA.splice(thisIndex, 1);
            d3.select(this).remove();
        });
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.supplyAnimationDefaults" id="apidoc.element.plotly.js.plots.supplyAnimationDefaults">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyAnimationDefaults
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">supplyAnimationDefaults = function (opts) {
    opts = opts || {};
    var i;
    var optsOut = {};

    function coerce(attr, dflt) {
        return Lib.coerce(opts || {}, optsOut, animationAttrs, attr, dflt);
    }

    coerce('mode');
    coerce('direction');
    coerce('fromcurrent');

    if(Array.isArray(opts.frame)) {
        optsOut.frame = [];
        for(i = 0; i &lt; opts.frame.length; i++) {
            optsOut.frame[i] = plots.supplyAnimationFrameDefaults(opts.frame[i] || {});
        }
    } else {
        optsOut.frame = plots.supplyAnimationFrameDefaults(opts.frame || {});
    }

    if(Array.isArray(opts.transition)) {
        optsOut.transition = [];
        for(i = 0; i &lt; opts.transition.length; i++) {
            optsOut.transition[i] = plots.supplyAnimationTransitionDefaults(opts.transition[i] || {});
        }
    } else {
        optsOut.transition = plots.supplyAnimationTransitionDefaults(opts.transition || {});
    }

    return optsOut;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// This is the queue of frames that will be animated as soon as possible. They
// are popped immediately upon the *start* of a transition:
if(!trans._frameQueue) {
    trans._frameQueue = [];
}

animationOpts = Plots.<span class="apidocCodeKeywordSpan">supplyAnimationDefaults</span>(animationOpts);
var transitionOpts = animationOpts.transition;
var frameOpts = animationOpts.frame;

// Since frames are popped immediately, an empty queue only means all frames have
// *started* to transition, not that the animation is complete. To solve that,
// track a separate counter that increments at the same time as frames are added
// to the queue, but decrements only when the transition is complete.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.supplyAnimationFrameDefaults" id="apidoc.element.plotly.js.plots.supplyAnimationFrameDefaults">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyAnimationFrameDefaults
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">supplyAnimationFrameDefaults = function (opts) {
    var optsOut = {};

    function coerce(attr, dflt) {
        return Lib.coerce(opts || {}, optsOut, animationAttrs.frame, attr, dflt);
    }

    coerce('duration');
    coerce('redraw');

    return optsOut;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
coerce('mode');
coerce('direction');
coerce('fromcurrent');

if(Array.isArray(opts.frame)) {
    optsOut.frame = [];
    for(i = 0; i &lt; opts.frame.length; i++) {
        optsOut.frame[i] = plots.<span class="apidocCodeKeywordSpan">supplyAnimationFrameDefaults</span>(opts.frame[i] || {});
    }
} else {
    optsOut.frame = plots.supplyAnimationFrameDefaults(opts.frame || {});
}

if(Array.isArray(opts.transition)) {
    optsOut.transition = [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.supplyAnimationTransitionDefaults" id="apidoc.element.plotly.js.plots.supplyAnimationTransitionDefaults">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyAnimationTransitionDefaults
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">supplyAnimationTransitionDefaults = function (opts) {
    var optsOut = {};

    function coerce(attr, dflt) {
        return Lib.coerce(opts || {}, optsOut, animationAttrs.transition, attr, dflt);
    }

    coerce('duration');
    coerce('easing');

    return optsOut;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
        optsOut.frame = plots.supplyAnimationFrameDefaults(opts.frame || {});
    }

    if(Array.isArray(opts.transition)) {
        optsOut.transition = [];
        for(i = 0; i &lt; opts.transition.length; i++) {
            optsOut.transition[i] = plots.<span class="apidocCodeKeywordSpan">supplyAnimationTransitionDefaults</span>(opts.transition
[i] || {});
        }
    } else {
        optsOut.transition = plots.supplyAnimationTransitionDefaults(opts.transition || {});
    }

    return optsOut;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.supplyDataDefaults" id="apidoc.element.plotly.js.plots.supplyDataDefaults">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyDataDefaults
        <span class="apidocSignatureSpan">(dataIn, dataOut, layout, fullLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">supplyDataDefaults = function (dataIn, dataOut, layout, fullLayout) {
    var i, fullTrace, trace;
    var modules = fullLayout._modules = [],
        basePlotModules = fullLayout._basePlotModules = [],
        cnt = 0;

    fullLayout._transformModules = [];

    function pushModule(fullTrace) {
        dataOut.push(fullTrace);

        var _module = fullTrace._module;
        if(!_module) return;

        Lib.pushUnique(modules, _module);
        Lib.pushUnique(basePlotModules, fullTrace._module.basePlotModule);

        cnt++;
    }

    var carpetIndex = {};
    var carpetDependents = [];

    for(i = 0; i &lt; dataIn.length; i++) {
        trace = dataIn[i];
        fullTrace = plots.supplyTraceDefaults(trace, cnt, fullLayout, i);

        fullTrace.index = i;
        fullTrace._input = trace;
        fullTrace._expandedIndex = cnt;

        if(fullTrace.transforms &amp;&amp; fullTrace.transforms.length) {
            var expandedTraces = applyTransforms(fullTrace, dataOut, layout, fullLayout);

            for(var j = 0; j &lt; expandedTraces.length; j++) {
                var expandedTrace = expandedTraces[j],
                    fullExpandedTrace = plots.supplyTraceDefaults(expandedTrace, cnt, fullLayout, i);

                // mutate uid here using parent uid and expanded index
                // to promote consistency between update calls
                expandedTrace.uid = fullExpandedTrace.uid = fullTrace.uid + j;

                // add info about parent data trace
                fullExpandedTrace.index = i;
                fullExpandedTrace._input = trace;
                fullExpandedTrace._fullInput = fullTrace;

                // add info about the expanded data
                fullExpandedTrace._expandedIndex = cnt;
                fullExpandedTrace._expandedInput = expandedTrace;

                pushModule(fullExpandedTrace);
            }
        }
        else {

            // add identify refs for consistency with transformed traces
            fullTrace._fullInput = fullTrace;
            fullTrace._expandedInput = fullTrace;

            pushModule(fullTrace);
        }

        if(Registry.traceIs(fullTrace, 'carpetAxis')) {
            carpetIndex[fullTrace.carpet] = fullTrace;
        }

        if(Registry.traceIs(fullTrace, 'carpetDependent')) {
            carpetDependents.push(i);
        }
    }

    for(i = 0; i &lt; carpetDependents.length; i++) {
        fullTrace = dataOut[carpetDependents[i]];

        if(!fullTrace.visible) continue;

        var carpetAxis = carpetIndex[fullTrace.carpet];
        fullTrace._carpet = carpetAxis;

        if(!carpetAxis || !carpetAxis.visible) {
            fullTrace.visible = false;
            continue;
        }

        fullTrace.xaxis = carpetAxis.xaxis;
        fullTrace.yaxis = carpetAxis.yaxis;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
newFullLayout._initialAutoSizeIsDone = true;

// keep track of how many traces are inputted
newFullLayout._dataLength = newData.length;

// then do the data
newFullLayout._globalTransforms = (gd._context || {}).globalTransforms;
plots.<span class="apidocCodeKeywordSpan">supplyDataDefaults</span>(newData, newFullData, newLayout, newFullLayout);

// attach helper method to check whether a plot type is present on graph
newFullLayout._has = plots._hasPlotType.bind(newFullLayout);

// special cases that introduce interactions between traces
var _modules = newFullLayout._modules;
for(i = 0; i &lt; _modules.length; i++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.supplyDefaults" id="apidoc.element.plotly.js.plots.supplyDefaults">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyDefaults
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">supplyDefaults = function (gd) {
    var oldFullLayout = gd._fullLayout || {},
        newFullLayout = gd._fullLayout = {},
        newLayout = gd.layout || {};

    var oldFullData = gd._fullData || [],
        newFullData = gd._fullData = [],
        newData = gd.data || [];

    var i;

    // Create all the storage space for frames, but only if doesn't already exist
    if(!gd._transitionData) plots.createTransitionData(gd);

    // first fill in what we can of layout without looking at data
    // because fullData needs a few things from layout

    if(oldFullLayout._initialAutoSizeIsDone) {

        // coerce the updated layout while preserving width and height
        var oldWidth = oldFullLayout.width,
            oldHeight = oldFullLayout.height;

        plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout);

        if(!newLayout.width) newFullLayout.width = oldWidth;
        if(!newLayout.height) newFullLayout.height = oldHeight;
    }
    else {

        // coerce the updated layout and autosize if needed
        plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout);

        var missingWidthOrHeight = (!newLayout.width || !newLayout.height),
            autosize = newFullLayout.autosize,
            autosizable = gd._context &amp;&amp; gd._context.autosizable,
            initialAutoSize = missingWidthOrHeight &amp;&amp; (autosize || autosizable);

        if(initialAutoSize) plots.plotAutoSize(gd, newLayout, newFullLayout);
        else if(missingWidthOrHeight) plots.sanitizeMargins(gd);

        // for backwards-compatibility with Plotly v1.x.x
        if(!autosize &amp;&amp; missingWidthOrHeight) {
            newLayout.width = newFullLayout.width;
            newLayout.height = newFullLayout.height;
        }
    }

    newFullLayout._initialAutoSizeIsDone = true;

    // keep track of how many traces are inputted
    newFullLayout._dataLength = newData.length;

    // then do the data
    newFullLayout._globalTransforms = (gd._context || {}).globalTransforms;
    plots.supplyDataDefaults(newData, newFullData, newLayout, newFullLayout);

    // attach helper method to check whether a plot type is present on graph
    newFullLayout._has = plots._hasPlotType.bind(newFullLayout);

    // special cases that introduce interactions between traces
    var _modules = newFullLayout._modules;
    for(i = 0; i &lt; _modules.length; i++) {
        var _module = _modules[i];
        if(_module.cleanData) _module.cleanData(newFullData);
    }

    if(oldFullData.length === newData.length) {
        for(i = 0; i &lt; newFullData.length; i++) {
            relinkPrivateKeys(newFullData[i], oldFullData[i]);
        }
    }

    // finally, fill in the pieces of layout that may need to look at data
    plots.supplyLayoutModuleDefaults(newLayout, newFullLayout, newFullData, gd._transitionData);

    // TODO remove in v2.0.0
    // add has-plot-type refs to fullLayout for backward compatibility
    newFullLayout._hasCartesian = newFullLayout._has('cartesian');
    newFullLayout._hasGeo = newFullLayout._has('geo');
    newFullLayout._hasGL3D = newFullLayout._has('gl3d');
    newFullLayout._hasGL2D = newFullLayout._has('gl2d');
    newFullLayout._hasTernary = newFullLayout._has('ternary');
    newFullLayout._hasPie = newFullLayout._has('pie');

    // clean subplots and other artifacts from previous plot calls
    plots.cleanPlot(newFullData, newFullLayout, oldFullData, oldFullLayout);

    // relink / initialize subplot axis objects
    plots.linkSubplots(newFullData, newFullLayout, oldFullData, oldFullLayout);

    // relink functions and _ attributes to promote consistency between plots
    relinkPrivateKeys(newFullLayout, oldFullLayout);

    // TODO may return a promise
    plots.doAutoMargin(gd);

    // set scale after auto margin routine
    var axList = Plotly.Axes.list(gd);
    for(i = 0; i &lt; axList.length; i++) {
        var ax = axList[i];
        ax.setScale();
    }

    // update object references in calcdata
    if((gd.calcdata || []).length === newFullData.length) {
        for(i = 0; i &lt; newFullData.length; i++) {
            var trace = newFu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    gd._replotPending = true;
    return Promise.reject();
} else {
    // we're going ahead with a replot now
    gd._replotPending = false;
}

Plots.<span class="apidocCodeKeywordSpan">supplyDefaults</span>(gd);

var fullLayout = gd._fullLayout;

// Polar plots
if(data &amp;&amp; data[0] &amp;&amp; data[0].r) return plotPolar(gd, data, layout);

// so we don't try to re-call Plotly.plot from inside
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.supplyFrameDefaults" id="apidoc.element.plotly.js.plots.supplyFrameDefaults">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyFrameDefaults
        <span class="apidocSignatureSpan">(frameIn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">supplyFrameDefaults = function (frameIn) {
    var frameOut = {};

    function coerce(attr, dflt) {
        return Lib.coerce(frameIn, frameOut, frameAttrs, attr, dflt);
    }

    coerce('group');
    coerce('name');
    coerce('traces');
    coerce('baseframe');
    coerce('data');
    coerce('layout');

    return frameOut;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            Lib.warn('addFrames: This API call has yielded too many warnings. ' +
                'For the rest of this call, further warnings about numeric frame ' +
                'names will be suppressed.');
        }
    }

    insertions.push({
        frame: Plots.<span class="apidocCodeKeywordSpan">supplyFrameDefaults</span>(frameList[i]),
        index: (indices &amp;&amp; indices[i] !== undefined &amp;&amp; indices[i] !== null) ? indices[i] : bigIndex + i
    });
}

// Sort this, taking note that undefined insertions end up at the end:
insertions.sort(function(a, b) {
    if(a.index &gt; b.index) return -1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.supplyLayoutGlobalDefaults" id="apidoc.element.plotly.js.plots.supplyLayoutGlobalDefaults">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyLayoutGlobalDefaults
        <span class="apidocSignatureSpan">(layoutIn, layoutOut)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">supplyLayoutGlobalDefaults = function (layoutIn, layoutOut) {
    function coerce(attr, dflt) {
        return Lib.coerce(layoutIn, layoutOut, plots.layoutAttributes, attr, dflt);
    }

    var globalFont = Lib.coerceFont(coerce, 'font');

    coerce('title');

    Lib.coerceFont(coerce, 'titlefont', {
        family: globalFont.family,
        size: Math.round(globalFont.size * 1.4),
        color: globalFont.color
    });

    // Make sure that autosize is defaulted to *true*
    // on layouts with no set width and height for backward compatibly,
    // in particular https://plot.ly/javascript/responsive-fluid-layout/
    //
    // Before https://github.com/plotly/plotly.js/pull/635 ,
    // layouts with no set width and height were set temporary set to 'initial'
    // to pass through the autosize routine
    //
    // This behavior is subject to change in v2.
    coerce('autosize', !(layoutIn.width &amp;&amp; layoutIn.height));

    coerce('width');
    coerce('height');
    coerce('margin.l');
    coerce('margin.r');
    coerce('margin.t');
    coerce('margin.b');
    coerce('margin.pad');
    coerce('margin.autoexpand');

    if(layoutIn.width &amp;&amp; layoutIn.height) plots.sanitizeMargins(layoutOut);

    coerce('paper_bgcolor');

    coerce('separators');
    coerce('hidesources');
    coerce('smith');

    var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleDefaults');
    handleCalendarDefaults(layoutIn, layoutOut, 'calendar');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if(oldFullLayout._initialAutoSizeIsDone) {

// coerce the updated layout while preserving width and height
var oldWidth = oldFullLayout.width,
    oldHeight = oldFullLayout.height;

plots.<span class="apidocCodeKeywordSpan">supplyLayoutGlobalDefaults</span>(newLayout, newFullLayout);

if(!newLayout.width) newFullLayout.width = oldWidth;
if(!newLayout.height) newFullLayout.height = oldHeight;
    }
    else {

// coerce the updated layout and autosize if needed
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.supplyLayoutModuleDefaults" id="apidoc.element.plotly.js.plots.supplyLayoutModuleDefaults">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyLayoutModuleDefaults
        <span class="apidocSignatureSpan">(layoutIn, layoutOut, fullData, transitionData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">supplyLayoutModuleDefaults = function (layoutIn, layoutOut, fullData, transitionData) {
    var i, _module;

    // can't be be part of basePlotModules loop
    // in order to handle the orphan axes case
    Plotly.Axes.supplyLayoutDefaults(layoutIn, layoutOut, fullData);

    // base plot module layout defaults
    var basePlotModules = layoutOut._basePlotModules;
    for(i = 0; i &lt; basePlotModules.length; i++) {
        _module = basePlotModules[i];

        // done above already
        if(_module.name === 'cartesian') continue;

        // e.g. gl2d does not have a layout-defaults step
        if(_module.supplyLayoutDefaults) {
            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
        }
    }

    // trace module layout defaults
    var modules = layoutOut._modules;
    for(i = 0; i &lt; modules.length; i++) {
        _module = modules[i];

        if(_module.supplyLayoutDefaults) {
            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
        }
    }

    // transform module layout defaults
    var transformModules = layoutOut._transformModules;
    for(i = 0; i &lt; transformModules.length; i++) {
        _module = transformModules[i];

        if(_module.supplyLayoutDefaults) {
            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData, transitionData);
        }
    }

    // should FX be a component?
    Plotly.Fx.supplyLayoutDefaults(layoutIn, layoutOut, fullData);

    var components = Object.keys(Registry.componentsRegistry);
    for(i = 0; i &lt; components.length; i++) {
        _module = Registry.componentsRegistry[components[i]];

        if(_module.supplyLayoutDefaults) {
            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(oldFullData.length === newData.length) {
    for(i = 0; i &lt; newFullData.length; i++) {
        relinkPrivateKeys(newFullData[i], oldFullData[i]);
    }
}

// finally, fill in the pieces of layout that may need to look at data
plots.<span class="apidocCodeKeywordSpan">supplyLayoutModuleDefaults</span>(newLayout, newFullLayout, newFullData, gd._transitionData
);

// TODO remove in v2.0.0
// add has-plot-type refs to fullLayout for backward compatibility
newFullLayout._hasCartesian = newFullLayout._has('cartesian');
newFullLayout._hasGeo = newFullLayout._has('geo');
newFullLayout._hasGL3D = newFullLayout._has('gl3d');
newFullLayout._hasGL2D = newFullLayout._has('gl2d');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.supplyTraceDefaults" id="apidoc.element.plotly.js.plots.supplyTraceDefaults">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyTraceDefaults
        <span class="apidocSignatureSpan">(traceIn, traceOutIndex, layout, traceInIndex)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">supplyTraceDefaults = function (traceIn, traceOutIndex, layout, traceInIndex) {
    var traceOut = {},
        defaultColor = Color.defaults[traceOutIndex % Color.defaults.length];

    function coerce(attr, dflt) {
        return Lib.coerce(traceIn, traceOut, plots.attributes, attr, dflt);
    }

    function coerceSubplotAttr(subplotType, subplotAttr) {
        if(!plots.traceIs(traceOut, subplotType)) return;

        return Lib.coerce(traceIn, traceOut,
            plots.subplotsRegistry[subplotType].attributes, subplotAttr);
    }

    var visible = coerce('visible');

    coerce('type');
    coerce('uid');
    coerce('name', 'trace ' + traceInIndex);

    // coerce subplot attributes of all registered subplot types
    var subplotTypes = Object.keys(subplotsRegistry);
    for(var i = 0; i &lt; subplotTypes.length; i++) {
        var subplotType = subplotTypes[i];

        // done below (only when visible is true)
        // TODO unified this pattern
        if(['cartesian', 'gl2d'].indexOf(subplotType) !== -1) continue;

        var attr = subplotsRegistry[subplotType].attr;

        if(attr) coerceSubplotAttr(subplotType, attr);
    }

    if(visible) {
        var _module = plots.getModule(traceOut);
        traceOut._module = _module;

        // gets overwritten in pie, geo and ternary modules
        coerce('hoverinfo', (layout._dataLength === 1) ? 'x+y+z+text' : undefined);

        if(plots.traceIs(traceOut, 'showLegend')) {
            coerce('showlegend');
            coerce('legendgroup');
        }

        // TODO add per-base-plot-module trace defaults step

        if(_module) _module.supplyDefaults(traceIn, traceOut, defaultColor, layout);

        if(!plots.traceIs(traceOut, 'noOpacity')) coerce('opacity');

        coerceSubplotAttr('cartesian', 'xaxis');
        coerceSubplotAttr('cartesian', 'yaxis');

        coerceSubplotAttr('gl2d', 'xaxis');
        coerceSubplotAttr('gl2d', 'yaxis');

        if(plots.traceIs(traceOut, 'notLegendIsolatable')) {
            // This clears out the legendonly state for traces like carpet that
            // cannot be isolated in the legend
            traceOut.visible = !!traceOut.visible;
        }

        plots.supplyTransformDefaults(traceIn, traceOut, layout);
    }

    return traceOut;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    var carpetIndex = {};
    var carpetDependents = [];

    for(i = 0; i &lt; dataIn.length; i++) {
trace = dataIn[i];
fullTrace = plots.<span class="apidocCodeKeywordSpan">supplyTraceDefaults</span>(trace, cnt, fullLayout, i);

fullTrace.index = i;
fullTrace._input = trace;
fullTrace._expandedIndex = cnt;

if(fullTrace.transforms &amp;&amp; fullTrace.transforms.length) {
    var expandedTraces = applyTransforms(fullTrace, dataOut, layout, fullLayout);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.supplyTransformDefaults" id="apidoc.element.plotly.js.plots.supplyTransformDefaults">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>supplyTransformDefaults
        <span class="apidocSignatureSpan">(traceIn, traceOut, layout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">supplyTransformDefaults = function (traceIn, traceOut, layout) {
    var globalTransforms = layout._globalTransforms || [];
    var transformModules = layout._transformModules || [];

    if(!Array.isArray(traceIn.transforms) &amp;&amp; globalTransforms.length === 0) return;

    var containerIn = traceIn.transforms || [],
        transformList = globalTransforms.concat(containerIn),
        containerOut = traceOut.transforms = [];

    for(var i = 0; i &lt; transformList.length; i++) {
        var transformIn = transformList[i],
            type = transformIn.type,
            _module = transformsRegistry[type],
            transformOut;

        if(!_module) Lib.warn('Unrecognized transform type ' + type + '.');

        if(_module &amp;&amp; _module.supplyDefaults) {
            transformOut = _module.supplyDefaults(transformIn, traceOut, layout, traceIn);
            transformOut.type = type;
            transformOut._module = _module;

            Lib.pushUnique(transformModules, _module);
        }
        else {
            transformOut = Lib.extendFlat({}, transformIn);
        }

        containerOut.push(transformOut);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if(plots.traceIs(traceOut, 'notLegendIsolatable')) {
        // This clears out the legendonly state for traces like carpet that
        // cannot be isolated in the legend
        traceOut.visible = !!traceOut.visible;
    }

    plots.<span class="apidocCodeKeywordSpan">supplyTransformDefaults</span>(traceIn, traceOut, layout);
}

return traceOut;
};

plots.supplyTransformDefaults = function(traceIn, traceOut, layout) {
var globalTransforms = layout._globalTransforms || [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.traceIs" id="apidoc.element.plotly.js.plots.traceIs">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>traceIs
        <span class="apidocSignatureSpan">(traceType, category)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traceIs = function (traceType, category) {
    traceType = getTraceType(traceType);

    // old plot.ly workspace hack, nothing to see here
    if(traceType === 'various') return false;

    var _module = exports.modules[traceType];

    if(!_module) {
        if(traceType &amp;&amp; traceType !== 'area') {
            Loggers.log('Unrecognized trace type ' + traceType + '.');
        }

        _module = exports.modules[basePlotAttributes.type.dflt];
    }

    return !!_module.categories[category];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    delete trace.xbins;
}

// error_y.opacity is obsolete - merge into color
if(trace.error_y &amp;&amp; 'opacity' in trace.error_y) {
    var dc = Color.defaults,
        yeColor = trace.error_y.color ||
        (Registry.<span class="apidocCodeKeywordSpan">traceIs</span>(trace, 'bar') ? Color.defaultLine : dc[tracei % dc
.length]);
    trace.error_y.color = Color.addOpacity(
        Color.rgb(yeColor),
        Color.opacity(yeColor) * trace.error_y.opacity);
    delete trace.error_y.opacity;
}

// convert bardir to orientation, and put the data into
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.plots.transition" id="apidoc.element.plotly.js.plots.transition">
        function <span class="apidocSignatureSpan">plotly.js.plots.</span>transition
        <span class="apidocSignatureSpan">(gd, data, layout, traces, frameOpts, transitionOpts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">transition = function (gd, data, layout, traces, frameOpts, transitionOpts) {
    var i, traceIdx;

    var dataLength = Array.isArray(data) ? data.length : 0;
    var traceIndices = traces.slice(0, dataLength);

    var transitionedTraces = [];

    function prepareTransitions() {
        var i;

        for(i = 0; i &lt; traceIndices.length; i++) {
            var traceIdx = traceIndices[i];
            var trace = gd._fullData[traceIdx];
            var module = trace._module;

            // There's nothing to do if this module is not defined:
            if(!module) continue;

            // Don't register the trace as transitioned if it doens't know what to do.
            // If it *is* registered, it will receive a callback that it's responsible
            // for calling in order to register the transition as having completed.
            if(module.animatable) {
                transitionedTraces.push(traceIdx);
            }

            gd.data[traceIndices[i]] = plots.extendTrace(gd.data[traceIndices[i]], data[i]);
        }

        // Follow the same procedure. Clone it so we don't mangle the input, then
        // expand any object paths so we can merge deep into gd.layout:
        var layoutUpdate = Lib.expandObjectPaths(Lib.extendDeepNoArrays({}, layout));

        // Before merging though, we need to modify the incoming layout. We only
        // know how to *transition* layout ranges, so it's imperative that a new
        // range not be sent to the layout before the transition has started. So
        // we must remove the things we can transition:
        var axisAttrRe = /^[xy]axis[0-9]*$/;
        for(var attr in layoutUpdate) {
            if(!axisAttrRe.test(attr)) continue;
            delete layoutUpdate[attr].range;
        }

        plots.extendLayout(gd.layout, layoutUpdate);

        // Supply defaults after applying the incoming properties. Note that any attempt
        // to simplify this step and reduce the amount of work resulted in the reconstruction
        // of essentially the whole supplyDefaults step, so that it seems sensible to just use
        // supplyDefaults even though it's heavier than would otherwise be desired for
        // transitions:
        plots.supplyDefaults(gd);

        plots.doCalcdata(gd);

        ErrorBars.calc(gd);

        return Promise.resolve();
    }

    function executeCallbacks(list) {
        var p = Promise.resolve();
        if(!list) return p;
        while(list.length) {
            p = p.then((list.shift()));
        }
        return p;
    }

    function flushCallbacks(list) {
        if(!list) return;
        while(list.length) {
            list.shift();
        }
    }

    var aborted = false;

    function executeTransitions() {

        gd.emit('plotly_transitioning', []);

        return new Promise(function(resolve) {
            // This flag is used to disabled things like autorange:
            gd._transitioning = true;

            // When instantaneous updates are coming through quickly, it's too much to simply disable
            // all interaction, so store this flag so we can disambiguate whether mouse interactions
            // should be fully disabled or not:
            if(transitionOpts.duration &gt; 0) {
                gd._transitioningWithDuration = true;
            }


            // If another transition is triggered, this callback will be executed simply because it's
            // in the interruptCallbacks queue. If this transition completes, it will instead flush
            // that queue and forget about this callback.
            gd._transitionData._interruptCallbacks.push(function() {
                aborted = true;
            });

            if(frameOpts.redraw) {
                gd._transitionData._interruptCallbacks.push(function() {
                    return Plotly.redraw(gd);
                });
            }

            // Emit this and make sure it happens last:
            gd._transitionData._interruptCallbacks.push(function() {
                gd.emit('plotly_transitioninterrupted', []);
            }); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        .each(function(thisText) {
var note = d3.select(this);

note.append('button')
    .classed('notifier-close', true)
    .html('&amp;times;')
    .on('click', function() {
        note.<span class="apidocCodeKeywordSpan">transition</span>().call(killNote);
    });

var p = note.append('p');
var lines = thisText.split(/&lt;br\s*\/?&gt;/g);
for(var i = 0; i &lt; lines.length; i++) {
    if(i) p.append('br');
    p.append('span').text(lines[i]);
...</pre></li>
    </ul>




























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.polygon" id="apidoc.module.plotly.js.polygon">module plotly.js.polygon</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.polygon.filter" id="apidoc.element.plotly.js.polygon.filter">
        function <span class="apidocSignatureSpan">plotly.js.polygon.</span>filter
        <span class="apidocSignatureSpan">(pts, tolerance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filter(pts, tolerance) {
    var ptsFiltered = [pts[0]],
        doneRawIndex = 0,
        doneFilteredIndex = 0;

    function addPt(pt) {
        pts.push(pt);
        var prevFilterLen = ptsFiltered.length,
            iLast = doneRawIndex;
        ptsFiltered.splice(doneFilteredIndex + 1);

        for(var i = iLast + 1; i &lt; pts.length; i++) {
            if(i === pts.length - 1 || isBent(pts, iLast, i + 1, tolerance)) {
                ptsFiltered.push(pts[i]);
                if(ptsFiltered.length &lt; prevFilterLen - 2) {
                    doneRawIndex = i;
                    doneFilteredIndex = ptsFiltered.length - 1;
                }
                iLast = i;
            }
        }
    }

    if(pts.length &gt; 1) {
        var lastPt = pts.pop();
        addPt(lastPt);
    }

    return {
        addPt: addPt,
        raw: pts,
        filtered: ptsFiltered
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Make a few changes to the data right away
// before it gets used for anything
exports.cleanData = function(data, existingData) {

    // Enforce unique IDs
    var suids = [], // seen uids --- so we can weed out incoming repeats
uids = data.concat(Array.isArray(existingData) ? existingData : [])
       .<span class="apidocCodeKeywordSpan">filter</span>(function(trace) { return 'uid' in trace; })
       .map(function(trace) { return trace.uid; });

    for(var tracei = 0; tracei &lt; data.length; tracei++) {
var trace = data[tracei];
var i;

// assign uids to each trace and detect collisions.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.polygon.isSegmentBent" id="apidoc.element.plotly.js.polygon.isSegmentBent">
        function <span class="apidocSignatureSpan">plotly.js.polygon.</span>isSegmentBent
        <span class="apidocSignatureSpan">(pts, start, end, tolerance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isBent(pts, start, end, tolerance) {
    var startPt = pts[start],
        segment = [pts[end][0] - startPt[0], pts[end][1] - startPt[1]],
        segmentSquared = dot(segment, segment),
        segmentLen = Math.sqrt(segmentSquared),
        unitPerp = [-segment[1] / segmentLen, segment[0] / segmentLen],
        i,
        part,
        partParallel;

    for(i = start + 1; i &lt; end; i++) {
        part = [pts[i][0] - startPt[0], pts[i][1] - startPt[1]];
        partParallel = dot(part, segment);

        if(partParallel &lt; 0 || partParallel &gt; segmentSquared ||
            Math.abs(dot(part, unitPerp)) &gt; tolerance) return true;
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.polygon.tester" id="apidoc.element.plotly.js.polygon.tester">
        function <span class="apidocSignatureSpan">plotly.js.polygon.</span>tester
        <span class="apidocSignatureSpan">(ptsIn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tester(ptsIn) {
    var pts = ptsIn.slice(),
        xmin = pts[0][0],
        xmax = xmin,
        ymin = pts[0][1],
        ymax = ymin;

    pts.push(pts[0]);
    for(var i = 1; i &lt; pts.length; i++) {
        xmin = Math.min(xmin, pts[i][0]);
        xmax = Math.max(xmax, pts[i][0]);
        ymin = Math.min(ymin, pts[i][1]);
        ymax = Math.max(ymax, pts[i][1]);
    }

    // do we have a rectangle? Handle this here, so we can use the same
    // tester for the rectangular case without sacrificing speed

    var isRect = false,
        rectFirstEdgeTest;

    if(pts.length === 5) {
        if(pts[0][0] === pts[1][0]) { // vert, horz, vert, horz
            if(pts[2][0] === pts[3][0] &amp;&amp;
                    pts[0][1] === pts[3][1] &amp;&amp;
                    pts[1][1] === pts[2][1]) {
                isRect = true;
                rectFirstEdgeTest = function(pt) { return pt[0] === pts[0][0]; };
            }
        }
        else if(pts[0][1] === pts[1][1]) { // horz, vert, horz, vert
            if(pts[2][1] === pts[3][1] &amp;&amp;
                    pts[0][0] === pts[3][0] &amp;&amp;
                    pts[1][0] === pts[2][0]) {
                isRect = true;
                rectFirstEdgeTest = function(pt) { return pt[1] === pts[0][1]; };
            }
        }
    }

    function rectContains(pt, omitFirstEdge) {
        var x = pt[0],
            y = pt[1];

        if(x &lt; xmin || x &gt; xmax || y &lt; ymin || y &gt; ymax) {
            // pt is outside the bounding box of polygon
            return false;
        }
        if(omitFirstEdge &amp;&amp; rectFirstEdgeTest(pt)) return false;

        return true;
    }

    function contains(pt, omitFirstEdge) {
        var x = pt[0],
            y = pt[1];

        if(x &lt; xmin || x &gt; xmax || y &lt; ymin || y &gt; ymax) {
            // pt is outside the bounding box of polygon
            return false;
        }

        var imax = pts.length,
            x1 = pts[0][0],
            y1 = pts[0][1],
            crossings = 0,
            i,
            x0,
            y0,
            xmini,
            ycross;

        for(i = 1; i &lt; imax; i++) {
            // find all crossings of a vertical line upward from pt with
            // polygon segments
            // crossings exactly at xmax don't count, unless the point is
            // exactly on the segment, then it counts as inside.
            x0 = x1;
            y0 = y1;
            x1 = pts[i][0];
            y1 = pts[i][1];
            xmini = Math.min(x0, x1);

            // outside the bounding box of this segment, it's only a crossing
            // if it's below the box.
            if(x &lt; xmini || x &gt; Math.max(x0, x1) || y &gt; Math.max(y0, y1)) {
                continue;
            }
            else if(y &lt; Math.min(y0, y1)) {
                // don't count the left-most point of the segment as a crossing
                // because we don't want to double-count adjacent crossings
                // UNLESS the polygon turns past vertical at exactly this x
                // Note that this is repeated below, but we can't factor it out
                // because
                if(x !== xmini) crossings++;
            }
            // inside the bounding box, check the actual line intercept
            else {
                // vertical segment - we know already that the point is exactly
                // on the segment, so mark the crossing as exactly at the point.
                if(x1 === x0) ycross = y;
                // any other angle
                else ycross = y0 + (x - x0) * (y1 - y0) / (x1 - x0);

                // exactly on the edge: counts as inside the polygon, unless it's the
                // first edge and we're omitting it.
                if(y === ycross) {
                    if(i === 1 &amp;&amp; omitFirstEdge) return false;
                    return true;
                }

                if(y &lt;= ycross &amp;&amp; x !== xmini) crossings++;
            }
        }

        // if we've gotten this far, odd crossings means inside, even is outside
        return crossings % 2 === 1;
    }

    return {
        xmin: xmin, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.queue" id="apidoc.module.plotly.js.queue">module plotly.js.queue</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.queue.add" id="apidoc.element.plotly.js.queue.add">
        function <span class="apidocSignatureSpan">plotly.js.queue.</span>add
        <span class="apidocSignatureSpan">(gd, undoFunc, undoArgs, redoFunc, redoArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (gd, undoFunc, undoArgs, redoFunc, redoArgs) {
    var queueObj,
        queueIndex;

    // make sure we have the queue and our position in it
    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};
    queueIndex = gd.undoQueue.index;

    // if we're already playing an undo or redo, or if this is an auto operation
    // (like pane resize... any others?) then we don't save this to the undo queue
    if(gd.autoplay) {
        if(!gd.undoQueue.inSequence) gd.autoplay = false;
        return;
    }

    // if we're not in a sequence or are just starting, we need a new queue item
    if(!gd.undoQueue.sequence || gd.undoQueue.beginSequence) {
        queueObj = {undo: {calls: [], args: []}, redo: {calls: [], args: []}};
        gd.undoQueue.queue.splice(queueIndex, gd.undoQueue.queue.length - queueIndex, queueObj);
        gd.undoQueue.index += 1;
    } else {
        queueObj = gd.undoQueue.queue[queueIndex - 1];
    }
    gd.undoQueue.beginSequence = false;

    // we unshift to handle calls for undo in a forward for loop later
    if(queueObj) {
        queueObj.undo.calls.unshift(undoFunc);
        queueObj.undo.args.unshift(undoArgs);
        queueObj.redo.calls.push(redoFunc);
        queueObj.redo.args.push(redoArgs);
    }

    if(gd.undoQueue.queue.length &gt; config.queueLength) {
        gd.undoQueue.queue.shift();
        gd.undoQueue.index--;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    if(calendar) {
try {
    var dateJD = Math.round(ms / ONEDAY) + EPOCHJD,
        calInstance = Registry.getComponentMethod('calendars', 'getCal')(calendar),
        cDate = calInstance.fromJD(dateJD);

    if(dMonth % 12) calInstance.<span class="apidocCodeKeywordSpan">add</span>(cDate, dMonth, 'm');
    else calInstance.add(cDate, dMonth / 12, 'y');

    return (cDate.toJD() - EPOCHJD) * ONEDAY + timeMs;
}
catch(e) {
    logError('invalid ms ' + ms + ' in calendar ' + calendar);
    // then keep going in gregorian even though the result will be 'Invalid'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.queue.plotDo" id="apidoc.element.plotly.js.queue.plotDo">
        function <span class="apidocSignatureSpan">plotly.js.queue.</span>plotDo
        <span class="apidocSignatureSpan">(gd, func, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">plotDo = function (gd, func, args) {
    gd.autoplay = true;

    // this *won't* copy gd and it preserves `undefined` properties!
    args = copyArgArray(gd, args);

    // call the supplied function
    func.apply(null, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   // get the queueObj for instructions on how to undo
   queueObj = gd.undoQueue.queue[gd.undoQueue.index];

   // this sequence keeps things from adding to the queue during undo/redo
   gd.undoQueue.inSequence = true;
   for(i = 0; i &lt; queueObj.undo.calls.length; i++) {
       queue.<span class="apidocCodeKeywordSpan">plotDo</span>(gd, queueObj.undo.calls[i], queueObj.undo.args[i]);
   }
   gd.undoQueue.inSequence = false;
   gd.autoplay = false;
};

/**
* Redo the current object in the undo, then move forward in the queue.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.queue.redo" id="apidoc.element.plotly.js.queue.redo">
        function <span class="apidocSignatureSpan">plotly.js.queue.</span>redo
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function redo(gd) {
    var queueObj, i;

    if(gd.framework &amp;&amp; gd.framework.isPolar) {
        gd.framework.redo();
        return;
    }
    if(gd.undoQueue === undefined ||
            isNaN(gd.undoQueue.index) ||
            gd.undoQueue.index &gt;= gd.undoQueue.queue.length) {
        return;
    }

    // get the queueObj for instructions on how to undo
    queueObj = gd.undoQueue.queue[gd.undoQueue.index];

    // this sequence keeps things from adding to the queue during undo/redo
    gd.undoQueue.inSequence = true;
    for(i = 0; i &lt; queueObj.redo.calls.length; i++) {
        queue.plotDo(gd, queueObj.redo.calls[i], queueObj.redo.args[i]);
    }
    gd.undoQueue.inSequence = false;
    gd.autoplay = false;

    // index is pointing to the thing we just redid, move it
    gd.undoQueue.index++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param gd
 */
queue.redo = function redo(gd) {
var queueObj, i;

if(gd.framework &amp;&amp; gd.framework.isPolar) {
    gd.framework.<span class="apidocCodeKeywordSpan">redo</span>();
    return;
}
if(gd.undoQueue === undefined ||
        isNaN(gd.undoQueue.index) ||
        gd.undoQueue.index &gt;= gd.undoQueue.queue.length) {
    return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.queue.startSequence" id="apidoc.element.plotly.js.queue.startSequence">
        function <span class="apidocSignatureSpan">plotly.js.queue.</span>startSequence
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startSequence = function (gd) {
    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};
    gd.undoQueue.sequence = true;
    gd.undoQueue.beginSequence = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        // something went wrong, reset gd to be safe and rethrow error
        gd.data.splice(gd.data.length - traces.length, traces.length);
        throw error;
    }

    // if we're here, the user has defined specific places to place the new traces
    // this requires some extra work that moveTraces will do
    Queue.<span class="apidocCodeKeywordSpan">startSequence</span>(gd);
    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
    promise = Plotly.moveTraces(gd, currentIndices, newIndices);
    Queue.stopSequence(gd);
    return promise;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.queue.stopSequence" id="apidoc.element.plotly.js.queue.stopSequence">
        function <span class="apidocSignatureSpan">plotly.js.queue.</span>stopSequence
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stopSequence = function (gd) {
    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};
    gd.undoQueue.sequence = false;
    gd.undoQueue.beginSequence = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   }

   // if we're here, the user has defined specific places to place the new traces
   // this requires some extra work that moveTraces will do
   Queue.startSequence(gd);
   Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);
   promise = Plotly.moveTraces(gd, currentIndices, newIndices);
   Queue.<span class="apidocCodeKeywordSpan">stopSequence</span>(gd);
   return promise;
};

/**
* Delete traces at `indices` from gd.data array.
*
* @param {Object|HTMLDivElement} gd The graph div
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.queue.undo" id="apidoc.element.plotly.js.queue.undo">
        function <span class="apidocSignatureSpan">plotly.js.queue.</span>undo
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function undo(gd) {
    var queueObj, i;

    if(gd.framework &amp;&amp; gd.framework.isPolar) {
        gd.framework.undo();
        return;
    }
    if(gd.undoQueue === undefined ||
            isNaN(gd.undoQueue.index) ||
            gd.undoQueue.index &lt;= 0) {
        return;
    }

    // index is pointing to next *forward* queueObj, point to the one we're undoing
    gd.undoQueue.index--;

    // get the queueObj for instructions on how to undo
    queueObj = gd.undoQueue.queue[gd.undoQueue.index];

    // this sequence keeps things from adding to the queue during undo/redo
    gd.undoQueue.inSequence = true;
    for(i = 0; i &lt; queueObj.undo.calls.length; i++) {
        queue.plotDo(gd, queueObj.undo.calls[i], queueObj.undo.args[i]);
    }
    gd.undoQueue.inSequence = false;
    gd.autoplay = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @param gd
 */
queue.undo = function undo(gd) {
var queueObj, i;

if(gd.framework &amp;&amp; gd.framework.isPolar) {
    gd.framework.<span class="apidocCodeKeywordSpan">undo</span>();
    return;
}
if(gd.undoQueue === undefined ||
        isNaN(gd.undoQueue.index) ||
        gd.undoQueue.index &lt;= 0) {
    return;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.registry" id="apidoc.module.plotly.js.registry">module plotly.js.registry</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.registry.getComponentMethod" id="apidoc.element.plotly.js.registry.getComponentMethod">
        function <span class="apidocSignatureSpan">plotly.js.registry.</span>getComponentMethod
        <span class="apidocSignatureSpan">(name, method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComponentMethod = function (name, method) {
    var _module = exports.componentsRegistry[name];

    if(!_module) return noop;
    return _module[method] || noop;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * dateTick0: get the canonical tick for this calendar
 *
 * bool sunday is for week ticks, shift it to a Sunday.
 */
exports.dateTick0 = function(calendar, sunday) {
    if(isWorldCalendar(calendar)) {
        return sunday ?
            Registry.<span class="apidocCodeKeywordSpan">getComponentMethod</span>('calendars', 'CANONICAL_SUNDAY
')[calendar] :
            Registry.getComponentMethod('calendars', 'CANONICAL_TICK')[calendar];
    }
    else {
        return sunday ? '2000-01-02' : '2000-01-01';
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.registry.getModule" id="apidoc.element.plotly.js.registry.getModule">
        function <span class="apidocSignatureSpan">plotly.js.registry.</span>getModule
        <span class="apidocSignatureSpan">(trace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getModule = function (trace) {
    if(trace.r !== undefined) {
        Loggers.warn('Tried to put a polar trace ' +
            'on an incompatible graph of cartesian ' +
            'data. Ignoring this dataset.', trace
        );
        return false;
    }

    var _module = exports.modules[getTraceType(trace)];
    if(!_module) return false;
    return _module._module;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var attr = subplotsRegistry[subplotType].attr;

if(attr) coerceSubplotAttr(subplotType, attr);
    }

    if(visible) {
var _module = plots.<span class="apidocCodeKeywordSpan">getModule</span>(traceOut);
traceOut._module = _module;

// gets overwritten in pie, geo and ternary modules
coerce('hoverinfo', (layout._dataLength === 1) ? 'x+y+z+text' : undefined);

if(plots.traceIs(traceOut, 'showLegend')) {
    coerce('showlegend');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.registry.register" id="apidoc.element.plotly.js.registry.register">
        function <span class="apidocSignatureSpan">plotly.js.registry.</span>register
        <span class="apidocSignatureSpan">(_module, thisType, categoriesIn, meta)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">register = function (_module, thisType, categoriesIn, meta) {
    if(exports.modules[thisType]) {
        Loggers.log('Type ' + thisType + ' already registered');
        return;
    }

    var categoryObj = {};
    for(var i = 0; i &lt; categoriesIn.length; i++) {
        categoryObj[categoriesIn[i]] = true;
        exports.allCategories[categoriesIn[i]] = true;
    }

    exports.modules[thisType] = {
        _module: _module,
        categories: categoryObj
    };

    if(meta &amp;&amp; Object.keys(meta).length) {
        exports.modules[thisType].meta = meta;
    }

    exports.allTypes.push(thisType);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
If you would like to manually pick which plotly.js modules to include, you can create a *custom* bundle by using `plotly.js/lib/
core`, and loading only the trace types that you need (e.g. `pie` or `choropleth`). The recommended way to do this is by creating
 a *bundling file*:

```javascript
// in custom-plotly.js
var Plotly = require('plotly.js/lib/core');

// Load in the trace types for pie, and choropleth
Plotly.<span class="apidocCodeKeywordSpan">register</span>([
    require('plotly.js/lib/pie'),
    require('plotly.js/lib/choropleth')
]);

module.exports = Plotly;
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.registry.registerComponent" id="apidoc.element.plotly.js.registry.registerComponent">
        function <span class="apidocSignatureSpan">plotly.js.registry.</span>registerComponent
        <span class="apidocSignatureSpan">(_module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerComponent = function (_module) {
    var name = _module.name;

    exports.componentsRegistry[name] = _module;

    if(_module.layoutAttributes) {
        if(_module.layoutAttributes._isLinkedToArray) {
            pushUnique(exports.layoutArrayContainers, name);
        }
        findArrayRegexps(_module);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function registerComponentModule(newModule) {
    if(typeof newModule.name !== 'string') {
        throw new Error('Component module *name* must be a string.');
    }

    Registry.<span class="apidocCodeKeywordSpan">registerComponent</span>(newModule);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.registry.registerSubplot" id="apidoc.element.plotly.js.registry.registerSubplot">
        function <span class="apidocSignatureSpan">plotly.js.registry.</span>registerSubplot
        <span class="apidocSignatureSpan">(_module)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerSubplot = function (_module) {
    var plotType = _module.name;

    if(exports.subplotsRegistry[plotType]) {
        Loggers.log('Plot type ' + plotType + ' already registered.');
        return;
    }

    // relayout array handling will look for component module methods with this
    // name and won't find them because this is a subplot module... but that
    // should be fine, it will just fall back on redrawing the plot.
    findArrayRegexps(_module);

    // not sure what's best for the 'cartesian' type at this point
    exports.subplotsRegistry[plotType] = _module;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
};

function registerTraceModule(newModule) {
Registry.register(newModule, newModule.name, newModule.categories, newModule.meta);

if(!Registry.subplotsRegistry[newModule.basePlotModule.name]) {
    Registry.<span class="apidocCodeKeywordSpan">registerSubplot</span>(newModule.basePlotModule);
}
}

function registerTransformModule(newModule) {
if(typeof newModule.name !== 'string') {
    throw new Error('Transform module *name* must be a string.');
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.registry.traceIs" id="apidoc.element.plotly.js.registry.traceIs">
        function <span class="apidocSignatureSpan">plotly.js.registry.</span>traceIs
        <span class="apidocSignatureSpan">(traceType, category)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">traceIs = function (traceType, category) {
    traceType = getTraceType(traceType);

    // old plot.ly workspace hack, nothing to see here
    if(traceType === 'various') return false;

    var _module = exports.modules[traceType];

    if(!_module) {
        if(traceType &amp;&amp; traceType !== 'area') {
            Loggers.log('Unrecognized trace type ' + traceType + '.');
        }

        _module = exports.modules[basePlotAttributes.type.dflt];
    }

    return !!_module.categories[category];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    delete trace.xbins;
}

// error_y.opacity is obsolete - merge into color
if(trace.error_y &amp;&amp; 'opacity' in trace.error_y) {
    var dc = Color.defaults,
        yeColor = trace.error_y.color ||
        (Registry.<span class="apidocCodeKeywordSpan">traceIs</span>(trace, 'bar') ? Color.defaultLine : dc[tracei % dc
.length]);
    trace.error_y.color = Color.addOpacity(
        Color.rgb(yeColor),
        Color.opacity(yeColor) * trace.error_y.opacity);
    delete trace.error_y.opacity;
}

// convert bardir to orientation, and put the data into
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.scrollbox" id="apidoc.module.plotly.js.scrollbox">module plotly.js.scrollbox</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.scrollbox.scrollbox" id="apidoc.element.plotly.js.scrollbox.scrollbox">
        function <span class="apidocSignatureSpan">plotly.js.</span>scrollbox
        <span class="apidocSignatureSpan">(gd, container, id)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ScrollBox(gd, container, id) {
    this.gd = gd;
    this.container = container;
    this.id = id;

    // See ScrollBox.prototype.enable for further definition
    this.position = null;  // scrollbox position
    this.translateX = null;  // scrollbox horizontal translation
    this.translateY = null;  // scrollbox vertical translation
    this.hbar = null;  // horizontal scrollbar D3 selection
    this.vbar = null;  // vertical scrollbar D3 selection

    // &lt;rect&gt; element to capture pointer events
    this.bg = this.container.selectAll('rect.scrollbox-bg').data([0]);

    this.bg.exit()
        .on('.drag', null)
        .on('wheel', null)
        .remove();

    this.bg.enter().append('rect')
        .classed('scrollbox-bg', true)
        .style('pointer-events', 'all')
        .attr({
            opacity: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0
        });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.scrollbox.prototype" id="apidoc.module.plotly.js.scrollbox.prototype">module plotly.js.scrollbox.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.scrollbox.prototype._onBarDrag" id="apidoc.element.plotly.js.scrollbox.prototype._onBarDrag">
        function <span class="apidocSignatureSpan">plotly.js.scrollbox.prototype.</span>_onBarDrag
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onBarDrag() {
    var translateX = this.translateX,
        translateY = this.translateY;

    if(this.hbar) {
        var xMin = translateX + this._hbarXMin,
            xMax = xMin + this._hbarTranslateMax,
            x = Lib.constrain(d3.event.x, xMin, xMax),
            xf = (x - xMin) / (xMax - xMin);

        var translateXMax = this.position.w - this._box.w;

        translateX = xf * translateXMax;
    }

    if(this.vbar) {
        var yMin = translateY + this._vbarYMin,
            yMax = yMin + this._vbarTranslateMax,
            y = Lib.constrain(d3.event.y, yMin, yMax),
            yf = (y - yMin) / (yMax - yMin);

        var translateYMax = this.position.h - this._box.h;

        translateY = yf * translateYMax;
    }

    this.setTranslate(translateX, translateY);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.scrollbox.prototype._onBoxDrag" id="apidoc.element.plotly.js.scrollbox.prototype._onBoxDrag">
        function <span class="apidocSignatureSpan">plotly.js.scrollbox.prototype.</span>_onBoxDrag
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onBarDrag() {
    var translateX = this.translateX,
        translateY = this.translateY;

    if(this.hbar) {
        translateX -= d3.event.dx;
    }

    if(this.vbar) {
        translateY -= d3.event.dy;
    }

    this.setTranslate(translateX, translateY);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.scrollbox.prototype._onBoxWheel" id="apidoc.element.plotly.js.scrollbox.prototype._onBoxWheel">
        function <span class="apidocSignatureSpan">plotly.js.scrollbox.prototype.</span>_onBoxWheel
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function onBarWheel() {
    var translateX = this.translateX,
        translateY = this.translateY;

    if(this.hbar) {
        translateX += d3.event.deltaY;
    }

    if(this.vbar) {
        translateY += d3.event.deltaY;
    }

    this.setTranslate(translateX, translateY);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.scrollbox.prototype.disable" id="apidoc.element.plotly.js.scrollbox.prototype.disable">
        function <span class="apidocSignatureSpan">plotly.js.scrollbox.prototype.</span>disable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disable() {
    if(this.hbar || this.vbar) {
        this.bg.attr({
            width: 0,
            height: 0
        });
        this.container
            .on('wheel', null)
            .on('.drag', null)
            .call(Drawing.setClipUrl, null);
        delete this._clipRect;
    }

    if(this.hbar) {
        this.hbar.on('.drag', null);
        this.hbar.remove();
        delete this.hbar;
        delete this._hbarXMin;
        delete this._hbarTranslateMax;
    }

    if(this.vbar) {
        this.vbar.on('.drag', null);
        this.vbar.remove();
        delete this.vbar;
        delete this._vbarYMin;
        delete this._vbarTranslateMax;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var update = bindingValueHasChanged(gd, binding, ret.cache);

if(update.changed &amp;&amp; onchange) {
    // Disable checks for the duration of this command in order to avoid
    // infinite loops:
    if(ret.lookupTable[update.value] !== undefined) {
        ret.<span class="apidocCodeKeywordSpan">disable</span>();
        Promise.resolve(onchange({
            value: update.value,
            type: binding.type,
            prop: binding.prop,
            traces: binding.traces,
            index: ret.lookupTable[update.value]
        })).then(ret.enable, ret.enable);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.scrollbox.prototype.enable" id="apidoc.element.plotly.js.scrollbox.prototype.enable">
        function <span class="apidocSignatureSpan">plotly.js.scrollbox.prototype.</span>enable
        <span class="apidocSignatureSpan">(position, translateX, translateY)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function enable(position, translateX, translateY) {
    var fullLayout = this.gd._fullLayout,
        fullWidth = fullLayout.width,
        fullHeight = fullLayout.height;

    // compute position of scrollbox
    this.position = position;

    var l = this.position.l,
        w = this.position.w,
        t = this.position.t,
        h = this.position.h,
        direction = this.position.direction,
        isDown = (direction === 'down'),
        isLeft = (direction === 'left'),
        isRight = (direction === 'right'),
        isUp = (direction === 'up'),
        boxW = w,
        boxH = h,
        boxL, boxR,
        boxT, boxB;

    if(!isDown &amp;&amp; !isLeft &amp;&amp; !isRight &amp;&amp; !isUp) {
        this.position.direction = 'down';
        isDown = true;
    }

    var isVertical = isDown || isUp;
    if(isVertical) {
        boxL = l;
        boxR = boxL + boxW;

        if(isDown) {
            // anchor to top side
            boxT = t;
            boxB = Math.min(boxT + boxH, fullHeight);
            boxH = boxB - boxT;
        }
        else {
            // anchor to bottom side
            boxB = t + boxH;
            boxT = Math.max(boxB - boxH, 0);
            boxH = boxB - boxT;
        }
    }
    else {
        boxT = t;
        boxB = boxT + boxH;

        if(isLeft) {
            // anchor to right side
            boxR = l + boxW;
            boxL = Math.max(boxR - boxW, 0);
            boxW = boxR - boxL;
        }
        else {
            // anchor to left side
            boxL = l;
            boxR = Math.min(boxL + boxW, fullWidth);
            boxW = boxR - boxL;
        }
    }

    this._box = {
        l: boxL,
        t: boxT,
        w: boxW,
        h: boxH
    };

    // compute position of horizontal scroll bar
    var needsHorizontalScrollBar = (w &gt; boxW),
        hbarW = ScrollBox.barLength + 2 * ScrollBox.barPad,
        hbarH = ScrollBox.barWidth + 2 * ScrollBox.barPad,
        // draw horizontal scrollbar on the bottom side
        hbarL = l,
        hbarT = t + h;

    if(hbarT + hbarH &gt; fullHeight) hbarT = fullHeight - hbarH;

    var hbar = this.container.selectAll('rect.scrollbar-horizontal').data(
            (needsHorizontalScrollBar) ? [0] : []);

    hbar.exit()
        .on('.drag', null)
        .remove();

    hbar.enter().append('rect')
        .classed('scrollbar-horizontal', true)
        .call(Color.fill, ScrollBox.barColor);

    if(needsHorizontalScrollBar) {
        this.hbar = hbar.attr({
            'rx': ScrollBox.barRadius,
            'ry': ScrollBox.barRadius,
            'x': hbarL,
            'y': hbarT,
            'width': hbarW,
            'height': hbarH
        });

        // hbar center moves between hbarXMin and hbarXMin + hbarTranslateMax
        this._hbarXMin = hbarL + hbarW / 2;
        this._hbarTranslateMax = boxW - hbarW;
    }
    else {
        delete this.hbar;
        delete this._hbarXMin;
        delete this._hbarTranslateMax;
    }

    // compute position of vertical scroll bar
    var needsVerticalScrollBar = (h &gt; boxH),
        vbarW = ScrollBox.barWidth + 2 * ScrollBox.barPad,
        vbarH = ScrollBox.barLength + 2 * ScrollBox.barPad,
        // draw vertical scrollbar on the right side
        vbarL = l + w,
        vbarT = t;

    if(vbarL + vbarW &gt; fullWidth) vbarL = fullWidth - vbarW;

    var vbar = this.container.selectAll('rect.scrollbar-vertical').data(
            (needsVerticalScrollBar) ? [0] : []);

    vbar.exit()
        .on('.drag', null)
        .remove();

    vbar.enter().append('rect')
        .classed('scrollbar-vertical', true)
        .call(Color.fill, ScrollBox.barColor);

    if(needsVerticalScrollBar) {
        this.vbar = vbar.attr({
            'rx': ScrollBox.barRadius,
            'ry': ScrollBox.barRadius,
            'x': vbarL,
            'y': vbarT,
            'width': vbarW,
            'height': vbarH
        });

        // vbar center moves between vbarYMin and vbarYMin + vbarTranslateMax
        this._vbarYMin = vbarT + vbarH / 2;
        this._vbarTranslateMax = boxH - vbarH;
    }
    else {
        d ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    height: 1,
    data: dummyPixel
});
}

function clear(regl, x, y, width, height) {
var gl = regl._gl;
gl.<span class="apidocCodeKeywordSpan">enable</span>(gl.SCISSOR_TEST);
gl.scissor(x, y, width, height);
regl.clear({color: [0, 0, 0, 0], depth: 1}); // clearing is done in scissored panel only
}

function renderBlock(regl, glAes, renderState, blockLineCount, sampleCount, item) {

var rafKey = item.key;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.scrollbox.prototype.setTranslate" id="apidoc.element.plotly.js.scrollbox.prototype.setTranslate">
        function <span class="apidocSignatureSpan">plotly.js.scrollbox.prototype.</span>setTranslate
        <span class="apidocSignatureSpan">(translateX, translateY)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setTranslate(translateX, translateY) {
    // store translateX and translateY (needed by mouse event handlers)
    var translateXMax = this.position.w - this._box.w,
        translateYMax = this.position.h - this._box.h;

    translateX = Lib.constrain(translateX || 0, 0, translateXMax);
    translateY = Lib.constrain(translateY || 0, 0, translateYMax);

    this.translateX = translateX;
    this.translateY = translateY;

    this.container.call(Drawing.setTranslate,
        this._box.l - this.position.l - translateX,
        this._box.t - this.position.t - translateY);

    if(this._clipRect) {
        this._clipRect.attr({
            x: Math.floor(this.position.l + translateX - 0.5),
            y: Math.floor(this.position.t + translateY - 0.5)
        });
    }

    if(this.hbar) {
        var xf = translateX / translateXMax;

        this.hbar.call(Drawing.setTranslate,
            translateX + xf * this._hbarTranslateMax,
            translateY);
    }

    if(this.vbar) {
        var yf = translateY / translateYMax;

        this.vbar.call(Drawing.setTranslate,
            translateX,
            translateY + yf * this._vbarTranslateMax);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
           this.vbar
               .on('.drag', null)
               .call(onBarDrag);
       }
   }

   // set scrollbox translation
   this.<span class="apidocCodeKeywordSpan">setTranslate</span>(translateX, translateY);
};

/**
* If present, remove clip-path and scrollbars
*
* @method
*/
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.search" id="apidoc.module.plotly.js.search">module plotly.js.search</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.search.distinctVals" id="apidoc.element.plotly.js.search.distinctVals">
        function <span class="apidocSignatureSpan">plotly.js.search.</span>distinctVals
        <span class="apidocSignatureSpan">(valsIn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distinctVals = function (valsIn) {
    var vals = valsIn.slice();  // otherwise we sort the original array...
    vals.sort(exports.sorterAsc);

    var l = vals.length - 1,
        minDiff = (vals[l] - vals[0]) || 1,
        errDiff = minDiff / (l || 1) / 10000,
        v2 = [vals[0]];

    for(var i = 0; i &lt; l; i++) {
        // make sure values aren't just off by a rounding error
        if(vals[i + 1] &gt; vals[i] + errDiff) {
            minDiff = Math.min(minDiff, vals[i + 1] - vals[i]);
            v2.push(vals[i + 1]);
        }
    }

    return {vals: v2, minDiff: minDiff};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var size0;
if(nbins) size0 = ((dataMax - dataMin) / nbins);
else {
    // totally auto: scale off std deviation so the highest bin is
    // somewhat taller than the total number of bins, but don't let
    // the size get smaller than the 'nice' rounded down minimum
    // difference between values
    var distinctData = Lib.<span class="apidocCodeKeywordSpan">distinctVals</span>(data),
        msexp = Math.pow(10, Math.floor(
            Math.log(distinctData.minDiff) / Math.LN10)),
        minSize = msexp * Lib.roundUp(
            distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);
    size0 = Math.max(minSize, 2 * Lib.stdev(data) /
        Math.pow(data.length, is2d ? 0.25 : 0.4));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.search.findBin" id="apidoc.element.plotly.js.search.findBin">
        function <span class="apidocSignatureSpan">plotly.js.search.</span>findBin
        <span class="apidocSignatureSpan">(val, bins, linelow)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findBin = function (val, bins, linelow) {
    if(isNumeric(bins.start)) {
        return linelow ?
            Math.ceil((val - bins.start) / bins.size) - 1 :
            Math.floor((val - bins.start) / bins.size);
    }
    else {
        var n1 = 0,
            n2 = bins.length,
            c = 0,
            n,
            test;
        if(bins[bins.length - 1] &gt;= bins[0]) {
            test = linelow ? lessThan : lessOrEqual;
        } else {
            test = linelow ? greaterOrEqual : greaterThan;
        }
        // c is just to avoid infinite loops if there's an error
        while(n1 &lt; n2 &amp;&amp; c++ &lt; 100) {
            n = Math.floor((n1 + n2) / 2);
            if(test(bins[n], val)) n1 = n + 1;
            else n2 = n;
        }
        if(c &gt; 90) loggers.log('Long binary search...');
        return n1 - 1;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    var i1, i2, text;

    if(hasColumnText) text = Lib.init2dArray(col2vals.length, col1vals.length);

    for(i = 0; i &lt; colLen; i++) {
        if(col1[i] !== BADNUM &amp;&amp; col2[i] !== BADNUM) {
i1 = Lib.<span class="apidocCodeKeywordSpan">findBin</span>(col1[i] + col1dv.minDiff / 2, col1vals);
i2 = Lib.findBin(col2[i] + col2dv.minDiff / 2, col2vals);

for(j = 0; j &lt; arrayVarNames.length; j++) {
    arrayVarName = arrayVarNames[j];
    arrayVar = trace[arrayVarName];
    newArray = newArrays[j];
    newArray[i2][i1] = arrayVar[i];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.search.roundUp" id="apidoc.element.plotly.js.search.roundUp">
        function <span class="apidocSignatureSpan">plotly.js.search.</span>roundUp
        <span class="apidocSignatureSpan">(val, arrayIn, reverse)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">roundUp = function (val, arrayIn, reverse) {
    var low = 0,
        high = arrayIn.length - 1,
        mid,
        c = 0,
        dlow = reverse ? 0 : 1,
        dhigh = reverse ? 1 : 0,
        rounded = reverse ? Math.ceil : Math.floor;
    // c is just to avoid infinite loops if there's an error
    while(low &lt; high &amp;&amp; c++ &lt; 100) {
        mid = rounded((low + high) / 2);
        if(arrayIn[mid] &lt;= val) low = mid + dlow;
        else high = mid - dhigh;
    }
    return arrayIn[low];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// totally auto: scale off std deviation so the highest bin is
// somewhat taller than the total number of bins, but don't let
// the size get smaller than the 'nice' rounded down minimum
// difference between values
var distinctData = Lib.distinctVals(data),
    msexp = Math.pow(10, Math.floor(
        Math.log(distinctData.minDiff) / Math.LN10)),
    minSize = msexp * Lib.<span class="apidocCodeKeywordSpan">roundUp</span>(
        distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);
size0 = Math.max(minSize, 2 * Lib.stdev(data) /
    Math.pow(data.length, is2d ? 0.25 : 0.4));

// fallback if ax.d2c output BADNUMs
// e.g. when user try to plot categorical bins
// on a layout.xaxis.type: 'linear'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.search.sorterAsc" id="apidoc.element.plotly.js.search.sorterAsc">
        function <span class="apidocSignatureSpan">plotly.js.search.</span>sorterAsc
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sorterAsc = function (a, b) { return a - b; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.search.sorterDes" id="apidoc.element.plotly.js.search.sorterDes">
        function <span class="apidocSignatureSpan">plotly.js.search.</span>sorterDes
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sorterDes = function (a, b) { return b - a; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.sieve" id="apidoc.module.plotly.js.sieve">module plotly.js.sieve</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.sieve.sieve" id="apidoc.element.plotly.js.sieve.sieve">
        function <span class="apidocSignatureSpan">plotly.js.</span>sieve
        <span class="apidocSignatureSpan">(traces, separateNegativeValues, dontMergeOverlappingData)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Sieve(traces, separateNegativeValues, dontMergeOverlappingData) {
    this.traces = traces;
    this.separateNegativeValues = separateNegativeValues;
    this.dontMergeOverlappingData = dontMergeOverlappingData;

    var positions = [];
    for(var i = 0; i &lt; traces.length; i++) {
        var trace = traces[i];
        for(var j = 0; j &lt; trace.length; j++) {
            var bar = trace[j];
            if(bar.p !== BADNUM) positions.push(bar.p);
        }
    }
    this.positions = positions;

    var dv = Lib.distinctVals(this.positions);
    this.distinctPositions = dv.vals;
    this.minDiff = dv.minDiff;

    this.binWidth = this.minDiff;

    this.bins = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.sieve.prototype" id="apidoc.module.plotly.js.sieve.prototype">module plotly.js.sieve.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.sieve.prototype.get" id="apidoc.element.plotly.js.sieve.prototype.get">
        function <span class="apidocSignatureSpan">plotly.js.sieve.prototype.</span>get
        <span class="apidocSignatureSpan">(position, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function put(position, value) {
    var label = this.getLabel(position, value);
    return this.bins[label] || 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * - min, max: (number, integer only) inclusive bounds on allowed vals
 *      either or both may be omitted
 * - dflt: if attribute is invalid or missing, use this default
 *      if dflt is provided as an argument to lib.coerce it takes precedence
 *      as a convenience, returns the value it finally set
 */
exports.coerce = function(containerIn, containerOut, attributes, attribute, dflt) {
var opts = nestedProperty(attributes, attribute).<span class="apidocCodeKeywordSpan">get</span>(),
    propIn = nestedProperty(containerIn, attribute),
    propOut = nestedProperty(containerOut, attribute),
    v = propIn.get();

if(dflt === undefined) dflt = opts.dflt;

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.sieve.prototype.getLabel" id="apidoc.element.plotly.js.sieve.prototype.getLabel">
        function <span class="apidocSignatureSpan">plotly.js.sieve.prototype.</span>getLabel
        <span class="apidocSignatureSpan">(position, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLabel(position, value) {
    var prefix = (value &lt; 0 &amp;&amp; this.separateNegativeValues) ? 'v' : '^',
        label = (this.dontMergeOverlappingData) ?
            position :
            Math.round(position / this.binWidth);
    return prefix + label;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *
 * @method
 * @param {number} position
 * @param {number} value
 * @returns {number} Previous bin value
 */
Sieve.prototype.put = function put(position, value) {
    var label = this.<span class="apidocCodeKeywordSpan">getLabel</span>(position, value),
        oldValue = this.bins[label] || 0;

    this.bins[label] = oldValue + value;

    return oldValue;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.sieve.prototype.put" id="apidoc.element.plotly.js.sieve.prototype.put">
        function <span class="apidocSignatureSpan">plotly.js.sieve.prototype.</span>put
        <span class="apidocSignatureSpan">(position, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function put(position, value) {
    var label = this.getLabel(position, value),
        oldValue = this.bins[label] || 0;

    this.bins[label] = oldValue + value;

    return oldValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        for(j = 0; j &lt; trace.length; j++) {
bar = trace[j];

if(bar.s === BADNUM) continue;

// stack current bar and get previous sum
var barBase = sieve.<span class="apidocCodeKeywordSpan">put</span>(bar.p, bar.b + bar.s),
    barTop = barBase + bar.b + bar.s;

// store the bar base and top in each calcdata item
bar.b = barBase;
bar[sLetter] = barTop;

if(!barnorm) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.stats" id="apidoc.module.plotly.js.stats">module plotly.js.stats</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.stats.aggNums" id="apidoc.element.plotly.js.stats.aggNums">
        function <span class="apidocSignatureSpan">plotly.js.stats.</span>aggNums
        <span class="apidocSignatureSpan">(f, v, a, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">aggNums = function (f, v, a, len) {
    var i,
        b;
    if(!len) len = a.length;
    if(!isNumeric(v)) v = false;
    if(Array.isArray(a[0])) {
        b = new Array(len);
        for(i = 0; i &lt; len; i++) b[i] = exports.aggNums(f, v, a[i]);
        a = b;
    }

    for(i = 0; i &lt; len; i++) {
        if(!isNumeric(v)) v = a[i];
        else if(isNumeric(a[i])) v = f(+v, +a[i]);
    }
    return v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.aggNums = function(f, v, a, len) {
var i,
    b;
if(!len) len = a.length;
if(!isNumeric(v)) v = false;
if(Array.isArray(a[0])) {
    b = new Array(len);
    for(i = 0; i &lt; len; i++) b[i] = exports.<span class="apidocCodeKeywordSpan">aggNums</span>(f, v, a[i]);
    a = b;
}

for(i = 0; i &lt; len; i++) {
    if(!isNumeric(v)) v = a[i];
    else if(isNumeric(a[i])) v = f(+v, +a[i]);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.stats.interp" id="apidoc.element.plotly.js.stats.interp">
        function <span class="apidocSignatureSpan">plotly.js.stats.</span>interp
        <span class="apidocSignatureSpan">(arr, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interp = function (arr, n) {
    if(!isNumeric(n)) throw 'n should be a finite number';
    n = n * arr.length - 0.5;
    if(n &lt; 0) return arr[0];
    if(n &gt; arr.length - 1) return arr[arr.length - 1];
    var frac = n % 1;
    return frac * arr[Math.ceil(n)] + (1 - frac) * arr[Math.floor(n)];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.stats.len" id="apidoc.element.plotly.js.stats.len">
        function <span class="apidocSignatureSpan">plotly.js.stats.</span>len
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">len = function (data) {
    return exports.aggNums(function(a) { return a + 1; }, 0, data);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * even need to use aggNums instead of .length, to toss out non-numerics
 */
exports.len = function(data) {
return exports.aggNums(function(a) { return a + 1; }, 0, data);
};

exports.mean = function(data, len) {
if(!len) len = exports.<span class="apidocCodeKeywordSpan">len</span>(data);
return exports.aggNums(function(a, b) { return a + b; }, 0, data) / len;
};

exports.variance = function(data, len, mean) {
if(!len) len = exports.len(data);
if(!isNumeric(mean)) mean = exports.mean(data, len);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.stats.mean" id="apidoc.element.plotly.js.stats.mean">
        function <span class="apidocSignatureSpan">plotly.js.stats.</span>mean
        <span class="apidocSignatureSpan">(data, len)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mean = function (data, len) {
    if(!len) len = exports.len(data);
    return exports.aggNums(function(a, b) { return a + b; }, 0, data) / len;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
exports.mean = function(data, len) {
    if(!len) len = exports.len(data);
    return exports.aggNums(function(a, b) { return a + b; }, 0, data) / len;
};

exports.variance = function(data, len, mean) {
    if(!len) len = exports.len(data);
    if(!isNumeric(mean)) mean = exports.<span class="apidocCodeKeywordSpan">mean</span>(data, len);

    return exports.aggNums(function(a, b) {
        return a + Math.pow(b - mean, 2);
    }, 0, data) / len;
};

exports.stdev = function(data, len, mean) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.stats.stdev" id="apidoc.element.plotly.js.stats.stdev">
        function <span class="apidocSignatureSpan">plotly.js.stats.</span>stdev
        <span class="apidocSignatureSpan">(data, len, mean)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stdev = function (data, len, mean) {
    return Math.sqrt(exports.variance(data, len, mean));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // the size get smaller than the 'nice' rounded down minimum
    // difference between values
    var distinctData = Lib.distinctVals(data),
        msexp = Math.pow(10, Math.floor(
            Math.log(distinctData.minDiff) / Math.LN10)),
        minSize = msexp * Lib.roundUp(
            distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);
    size0 = Math.max(minSize, 2 * Lib.<span class="apidocCodeKeywordSpan">stdev</span>(data) /
        Math.pow(data.length, is2d ? 0.25 : 0.4));

    // fallback if ax.d2c output BADNUMs
    // e.g. when user try to plot categorical bins
    // on a layout.xaxis.type: 'linear'
    if(!isNumeric(size0)) size0 = 1;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.stats.variance" id="apidoc.element.plotly.js.stats.variance">
        function <span class="apidocSignatureSpan">plotly.js.stats.</span>variance
        <span class="apidocSignatureSpan">(data, len, mean)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">variance = function (data, len, mean) {
    if(!len) len = exports.len(data);
    if(!isNumeric(mean)) mean = exports.mean(data, len);

    return exports.aggNums(function(a, b) {
        return a + Math.pow(b - mean, 2);
    }, 0, data) / len;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

   return exports.aggNums(function(a, b) {
       return a + Math.pow(b - mean, 2);
   }, 0, data) / len;
};

exports.stdev = function(data, len, mean) {
   return Math.sqrt(exports.<span class="apidocCodeKeywordSpan">variance</span>(data, len, mean));
};

/**
* interp() computes a percentile (quantile) for a given distribution.
* We interpolate the distribution (to compute quantiles, we follow method #10 here:
* http://www.amstat.org/publications/jse/v14n3/langford.html).
* Typically the index or rank (n * arr.length) may be non-integer.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.subroutines" id="apidoc.module.plotly.js.subroutines">module plotly.js.subroutines</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.subroutines.doCamera" id="apidoc.element.plotly.js.subroutines.doCamera">
        function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>doCamera
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doCamera = function (gd) {
    var fullLayout = gd._fullLayout,
        sceneIds = Plots.getSubplotIds(fullLayout, 'gl3d');

    for(var i = 0; i &lt; sceneIds.length; i++) {
        var sceneLayout = fullLayout[sceneIds[i]],
            scene = sceneLayout._scene;

        scene.setCamera(sceneLayout.camera);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.subroutines.doColorBars" id="apidoc.element.plotly.js.subroutines.doColorBars">
        function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>doColorBars
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doColorBars = function (gd) {
    for(var i = 0; i &lt; gd.calcdata.length; i++) {
        var cdi0 = gd.calcdata[i][0];

        if((cdi0.t || {}).cb) {
            var trace = cdi0.trace,
                cb = cdi0.t.cb;

            if(Registry.traceIs(trace, 'contour')) {
                cb.line({
                    width: trace.contours.showlines !== false ?
                        trace.line.width : 0,
                    dash: trace.line.dash,
                    color: trace.contours.coloring === 'line' ?
                        cb._opts.line.color : trace.line.color
                });
            }
            if(Registry.traceIs(trace, 'markerColorscale')) {
                cb.options(trace.marker.colorbar)();
            }
            else cb.options(trace.colorbar)();
        }
    }

    return Plots.previousPromises(gd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.subroutines.doLegend" id="apidoc.element.plotly.js.subroutines.doLegend">
        function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>doLegend
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doLegend = function (gd) {
    Registry.getComponentMethod('legend', 'draw')(gd);
    return Plots.previousPromises(gd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.subroutines.doModeBar" id="apidoc.element.plotly.js.subroutines.doModeBar">
        function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>doModeBar
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doModeBar = function (gd) {
    var fullLayout = gd._fullLayout;
    var subplotIds, i;

    ModeBar.manage(gd);
    Plotly.Fx.init(gd);

    subplotIds = Plots.getSubplotIds(fullLayout, 'gl3d');
    for(i = 0; i &lt; subplotIds.length; i++) {
        var scene = fullLayout[subplotIds[i]]._scene;
        scene.updateFx(fullLayout.dragmode, fullLayout.hovermode);
    }

    // no need to do this for gl2d subplots,
    // Plots.linkSubplots takes care of it all.

    return Plots.previousPromises(gd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.subroutines.doTicksRelayout" id="apidoc.element.plotly.js.subroutines.doTicksRelayout">
        function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>doTicksRelayout
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doTicksRelayout = function (gd) {
    Plotly.Axes.doTicks(gd, 'redraw');
    exports.drawMainTitle(gd);
    return Plots.previousPromises(gd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.subroutines.doTraceStyle" id="apidoc.element.plotly.js.subroutines.doTraceStyle">
        function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>doTraceStyle
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doTraceStyle = function (gd) {
    for(var i = 0; i &lt; gd.calcdata.length; i++) {
        var cdi = gd.calcdata[i],
            _module = ((cdi[0] || {}).trace || {})._module || {},
            arraysToCalcdata = _module.arraysToCalcdata;

        if(arraysToCalcdata) arraysToCalcdata(cdi, cdi[0].trace);
    }

    Plots.style(gd);
    Registry.getComponentMethod('legend', 'draw')(gd);

    return Plots.previousPromises(gd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.subroutines.drawMainTitle" id="apidoc.element.plotly.js.subroutines.drawMainTitle">
        function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>drawMainTitle
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drawMainTitle = function (gd) {
    var fullLayout = gd._fullLayout;

    Titles.draw(gd, 'gtitle', {
        propContainer: fullLayout,
        propName: 'title',
        dfltName: 'Plot',
        attributes: {
            x: fullLayout.width / 2,
            y: fullLayout._size.t / 2,
            'text-anchor': 'middle'
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    // mark free axes as displayed, so we don't draw them again
    if(showfreex) { freefinished.push(xa._id); }
    if(showfreey) { freefinished.push(ya._id); }
});

Plotly.Axes.makeClipPaths(gd);
exports.<span class="apidocCodeKeywordSpan">drawMainTitle</span>(gd);
ModeBar.manage(gd);

return gd._promises.length &amp;&amp; Promise.all(gd._promises);
};

exports.drawMainTitle = function(gd) {
var fullLayout = gd._fullLayout;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.subroutines.layoutReplot" id="apidoc.element.plotly.js.subroutines.layoutReplot">
        function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>layoutReplot
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">layoutReplot = function (gd) {
    var layout = gd.layout;
    gd.layout = undefined;
    return Plotly.plot(gd, '', layout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.subroutines.layoutStyles" id="apidoc.element.plotly.js.subroutines.layoutStyles">
        function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>layoutStyles
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">layoutStyles = function (gd) {
    return Lib.syncOrAsync([Plots.doAutoMargin, exports.lsInner], gd);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.subroutines.lsInner" id="apidoc.element.plotly.js.subroutines.lsInner">
        function <span class="apidocSignatureSpan">plotly.js.subroutines.</span>lsInner
        <span class="apidocSignatureSpan">(gd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lsInner = function (gd) {
    var fullLayout = gd._fullLayout,
        gs = fullLayout._size,
        axList = Plotly.Axes.list(gd),
        i;

    // clear axis line positions, to be set in the subplot loop below
    for(i = 0; i &lt; axList.length; i++) axList[i]._linepositions = {};

    fullLayout._paperdiv
        .style({
            width: fullLayout.width + 'px',
            height: fullLayout.height + 'px'
        })
        .selectAll('.main-svg')
            .call(Drawing.setSize, fullLayout.width, fullLayout.height);

    gd._context.setBackground(gd, fullLayout.paper_bgcolor);

    var subplotSelection = fullLayout._paper.selectAll('g.subplot');

    // figure out which backgrounds we need to draw, and in which layers
    // to put them
    var lowerBackgroundIDs = [];
    var lowerDomains = [];
    subplotSelection.each(function(subplot) {
        var plotinfo = fullLayout._plots[subplot];

        if(plotinfo.mainplot) {
            // mainplot is a reference to the main plot this one is overlaid on
            // so if it exists, this is an overlaid plot and we don't need to
            // give it its own background
            if(plotinfo.bg) {
                plotinfo.bg.remove();
            }
            plotinfo.bg = undefined;
            return;
        }

        var xa = Plotly.Axes.getFromId(gd, subplot, 'x'),
            ya = Plotly.Axes.getFromId(gd, subplot, 'y'),
            xDomain = xa.domain,
            yDomain = ya.domain,
            plotgroupBgData = [];

        if(overlappingDomain(xDomain, yDomain, lowerDomains)) {
            plotgroupBgData = [0];
        }
        else {
            lowerBackgroundIDs.push(subplot);
            lowerDomains.push([xDomain, yDomain]);
        }

        // create the plot group backgrounds now, since
        // they're all independent selections
        var plotgroupBg = plotinfo.plotgroup.selectAll('.bg')
            .data(plotgroupBgData);

        plotgroupBg.enter().append('rect')
            .classed('bg', true);

        plotgroupBg.exit().remove();

        plotgroupBg.each(function() {
            plotinfo.bg = plotgroupBg;
            var pgNode = plotinfo.plotgroup.node();
            pgNode.insertBefore(this, pgNode.childNodes[0]);
        });
    });

    // now create all the lower-layer backgrounds at once now that
    // we have the list of subplots that need them
    var lowerBackgrounds = fullLayout._bgLayer.selectAll('.bg')
        .data(lowerBackgroundIDs);

    lowerBackgrounds.enter().append('rect')
        .classed('bg', true);

    lowerBackgrounds.exit().remove();

    lowerBackgrounds.each(function(subplot) {
        fullLayout._plots[subplot].bg = d3.select(this);
    });

    var freefinished = [];
    subplotSelection.each(function(subplot) {
        var plotinfo = fullLayout._plots[subplot],
            xa = Plotly.Axes.getFromId(gd, subplot, 'x'),
            ya = Plotly.Axes.getFromId(gd, subplot, 'y');

        // reset scale in case the margins have changed
        xa.setScale();
        ya.setScale();

        if(plotinfo.bg) {
            plotinfo.bg
                .call(Drawing.setRect,
                    xa._offset - gs.p, ya._offset - gs.p,
                    xa._length + 2 * gs.p, ya._length + 2 * gs.p)
                .call(Color.fill, fullLayout.plot_bgcolor)
                .style('stroke-width', 0);
        }

        // Clip so that data only shows up on the plot area.
        plotinfo.clipId = 'clip' + fullLayout._uid + subplot + 'plot';

        var plotClip = fullLayout._defs.selectAll('g.clips')
            .selectAll('#' + plotinfo.clipId)
            .data([0]);

        plotClip.enter().append('clipPath')
            .attr({
                'class': 'plotclip',
                'id': plotinfo.clipId
            })
            .append('rect');

        plotClip.selectAll('rect')
            .attr({
                'width': xa._length,
                'height': ya._length
            });


        plotinfo.plot.call(Drawing.setTranslate, xa._offset, ya._offset);
        plotinfo.plot.call(Drawing.setClipUrl, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.subtypes" id="apidoc.module.plotly.js.subtypes">module plotly.js.subtypes</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.subtypes.hasLines" id="apidoc.element.plotly.js.subtypes.hasLines">
        function <span class="apidocSignatureSpan">plotly.js.subtypes.</span>hasLines
        <span class="apidocSignatureSpan">(trace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasLines = function (trace) {
    return trace.visible &amp;&amp; trace.mode &amp;&amp;
        trace.mode.indexOf('lines') !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var hasColorscale = require('../../components/colorscale/has_colorscale');
var calcColorscale = require('../../components/colorscale/calc');

var subTypes = require('./subtypes');


module.exports = function calcMarkerColorscale(trace) {
if(subTypes.<span class="apidocCodeKeywordSpan">hasLines</span>(trace) &amp;&amp; hasColorscale(trace, 'line')) {
    calcColorscale(trace, trace.line.color, 'line', 'c');
}

if(subTypes.hasMarkers(trace)) {
    if(hasColorscale(trace, 'marker')) {
        calcColorscale(trace, trace.marker.color, 'marker', 'c');
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.subtypes.hasMarkers" id="apidoc.element.plotly.js.subtypes.hasMarkers">
        function <span class="apidocSignatureSpan">plotly.js.subtypes.</span>hasMarkers
        <span class="apidocSignatureSpan">(trace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasMarkers = function (trace) {
    return trace.visible &amp;&amp; trace.mode &amp;&amp;
        trace.mode.indexOf('markers') !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var keyFunc;

if(trace.ids) {
    keyFunc = function(d) {return d.id;};
}

var sparse = (
    subTypes.<span class="apidocCodeKeywordSpan">hasMarkers</span>(trace) &amp;&amp;
    trace.marker.maxdisplayed &gt; 0
);

if(!yObj.visible &amp;&amp; !xObj.visible) return;

var errorbars = d3.select(this).selectAll('g.errorbar')
    .data(d, keyFunc);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.subtypes.hasText" id="apidoc.element.plotly.js.subtypes.hasText">
        function <span class="apidocSignatureSpan">plotly.js.subtypes.</span>hasText
        <span class="apidocSignatureSpan">(trace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasText = function (trace) {
    return trace.visible &amp;&amp; trace.mode &amp;&amp;
        trace.mode.indexOf('text') !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(selectable) break;

var trace = fullData[i];

if(!trace._module || !trace._module.selectPoints) continue;

if(trace.type === 'scatter' || trace.type === 'scatterternary') {
    if(scatterSubTypes.hasMarkers(trace) || scatterSubTypes.<span class="apidocCodeKeywordSpan">hasText</span>(trace)) {
        selectable = true;
    }
}
// assume that in general if the trace module has selectPoints,
// then it's selectable. Scatter is an exception to this because it must
// have markers or text, not just be a scatter type.
else selectable = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.subtypes.isBubble" id="apidoc.element.plotly.js.subtypes.isBubble">
        function <span class="apidocSignatureSpan">plotly.js.subtypes.</span>isBubble
        <span class="apidocSignatureSpan">(trace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isBubble = function (trace) {
    return Lib.isPlainObject(trace.marker) &amp;&amp;
        Array.isArray(trace.marker.size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var hasColorscale = require('../../components/colorscale/has_colorscale');
var colorscaleDefaults = require('../../components/colorscale/defaults');

var subTypes = require('./subtypes');


module.exports = function markerDefaults(traceIn, traceOut, defaultColor, layout, coerce, opts) {
var isBubble = subTypes.<span class="apidocCodeKeywordSpan">isBubble</span>(traceIn),
    lineColor = (traceIn.line || {}).color,
    defaultMLC;

// marker.color inherit from line.color (even if line.color is an array)
if(lineColor) defaultColor = lineColor;

coerce('marker.symbol');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.svg_text_utils" id="apidoc.module.plotly.js.svg_text_utils">module plotly.js.svg_text_utils</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.svg_text_utils.convertToTspans" id="apidoc.element.plotly.js.svg_text_utils.convertToTspans">
        function <span class="apidocSignatureSpan">plotly.js.svg_text_utils.</span>convertToTspans
        <span class="apidocSignatureSpan">(_context, _callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">convertToTspans = function (_context, _callback) {
    var str = _context.text();
    var converted = convertToSVG(str);
    var that = _context;

    // Until we get tex integrated more fully (so it can be used along with non-tex)
    // allow some elements to prohibit it by attaching 'data-notex' to the original
    var tex = (!that.attr('data-notex')) &amp;&amp; converted.match(/([^$]*)([$]+[^$]*[$]+)([^$]*)/);
    var result = str;
    var parent = d3.select(that.node().parentNode);
    if(parent.empty()) return;
    var svgClass = (that.attr('class')) ? that.attr('class').split(' ')[0] : 'text';
    svgClass += '-math';
    parent.selectAll('svg.' + svgClass).remove();
    parent.selectAll('g.' + svgClass + '-group').remove();
    _context.style({visibility: null});
    for(var up = _context.node(); up &amp;&amp; up.removeAttribute; up = up.parentNode) {
        up.removeAttribute('data-bb');
    }

    function showText() {
        if(!parent.empty()) {
            svgClass = that.attr('class') + '-math';
            parent.select('svg.' + svgClass).remove();
        }
        _context.text('')
            .style({
                visibility: 'inherit',
                'white-space': 'pre'
            });

        result = _context.appendSVG(converted);

        if(!result) _context.text(str);

        if(_context.select('a').size()) {
            // at least in Chrome, pointer-events does not seem
            // to be honored in children of &lt;text&gt; elements
            // so if we have an anchor, we have to make the
            // whole element respond
            _context.style('pointer-events', 'all');
        }

        if(_callback) _callback.call(that);
    }

    if(tex) {
        var gd = Lib.getPlotDiv(that.node());
        ((gd &amp;&amp; gd._promises) || []).push(new Promise(function(resolve) {
            that.style({visibility: 'hidden'});
            var config = {fontSize: parseInt(that.style('font-size'), 10)};

            texToSVG(tex[2], config, function(_svgEl, _glyphDefs, _svgBBox) {
                parent.selectAll('svg.' + svgClass).remove();
                parent.selectAll('g.' + svgClass + '-group').remove();

                var newSvg = _svgEl &amp;&amp; _svgEl.select('svg');
                if(!newSvg || !newSvg.node()) {
                    showText();
                    resolve();
                    return;
                }

                var mathjaxGroup = parent.append('g')
                    .classed(svgClass + '-group', true)
                    .attr({'pointer-events': 'none'});

                mathjaxGroup.node().appendChild(newSvg.node());

                // stitch the glyph defs
                if(_glyphDefs &amp;&amp; _glyphDefs.node()) {
                    newSvg.node().insertBefore(_glyphDefs.node().cloneNode(true),
                                               newSvg.node().firstChild);
                }

                newSvg.attr({
                    'class': svgClass,
                    height: _svgBBox.height,
                    preserveAspectRatio: 'xMinYMin meet'
                })
                .style({overflow: 'visible', 'pointer-events': 'none'});

                var fill = that.style('fill') || 'black';
                newSvg.select('g').attr({fill: fill, stroke: fill});

                var newSvgW = getSize(newSvg, 'width'),
                    newSvgH = getSize(newSvg, 'height'),
                    newX = +that.attr('x') - newSvgW *
                        {start: 0, middle: 0.5, end: 1}[that.attr('text-anchor') || 'start'],
                    // font baseline is about 1/4 fontSize below centerline
                    textHeight = parseInt(that.style('font-size'), 10) ||
                        getSize(that, 'height'),
                    dy = -textHeight / 4;

                if(svgClass[0] === 'y') {
                    mathjaxGroup.attr({
                        transform: 'rotate(' + [-90, +that.attr('x'), +that.attr('y')] +
                        ') translate(' + [-newSvgW / 2, dy - newSvgH / 2] + ')'
                    });
                    newSvg.attr({x: +that.attr('x'), y: +that.attr(' ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.attr({
    'text-anchor': {
        left: 'start',
        right: 'end'
    }[options.align] || 'middle'
});

svgTextUtils.<span class="apidocCodeKeywordSpan">convertToTspans</span>(s, drawGraphicalElements);
return s;
    }

    function drawGraphicalElements() {

// make sure lines are aligned the way they will be
// at the end, even if their position changes
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.svg_text_utils.html_entity_decode" id="apidoc.element.plotly.js.svg_text_utils.html_entity_decode">
        function <span class="apidocSignatureSpan">plotly.js.svg_text_utils.</span>html_entity_decode
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">html_entity_decode = function (s) {
    var hiddenDiv = d3.select('body').append('div').style({display: 'none'}).html('');
    var replaced = s.replace(/(&amp;[^;]*;)/gi, function(d) {
        if(d === '&amp;lt;') { return '&amp;#60;'; } // special handling for brackets
        if(d === '&amp;rt;') { return '&amp;#62;'; }
        if(d.indexOf('&lt;') !== -1 || d.indexOf('&gt;') !== -1) { return ''; }
        return hiddenDiv.html(d).text(); // everything else, let the browser decode it to unicode
    });
    hiddenDiv.remove();
    return replaced;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    // fix for IE namespacing quirk?
    // http://stackoverflow.com/questions/19610089/unwanted-namespaces-on-svg-markup-when-using-xmlserializer-in-javascript-with
-ie
    svg.node().setAttributeNS(xmlnsNamespaces.xmlns, 'xmlns', xmlnsNamespaces.svg);
    svg.node().setAttributeNS(xmlnsNamespaces.xmlns, 'xmlns:xlink', xmlnsNamespaces.xlink);

    var s = new window.XMLSerializer().serializeToString(svg.node());
    s = svgTextUtils.<span class="apidocCodeKeywordSpan">html_entity_decode</span>(s);
    s = svgTextUtils.xml_entity_encode(s);

    // Fix quotations around font strings
    s = s.replace(/("TOBESTRIPPED)|(TOBESTRIPPED")/g, '\'');

    return s;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.svg_text_utils.makeEditable" id="apidoc.element.plotly.js.svg_text_utils.makeEditable">
        function <span class="apidocSignatureSpan">plotly.js.svg_text_utils.</span>makeEditable
        <span class="apidocSignatureSpan">(context, _delegate, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeEditable = function (context, _delegate, options) {
    if(!options) options = {};
    var that = this;
    var dispatch = d3.dispatch('edit', 'input', 'cancel');
    var textSelection = d3.select(this.node())
        .style({'pointer-events': 'all'});

    var handlerElement = _delegate || textSelection;
    if(_delegate) textSelection.style({'pointer-events': 'none'});

    function handleClick() {
        appendEditable();
        that.style({opacity: 0});
        // also hide any mathjax svg
        var svgClass = handlerElement.attr('class'),
            mathjaxClass;
        if(svgClass) mathjaxClass = '.' + svgClass.split(' ')[0] + '-math-group';
        else mathjaxClass = '[class*=-math-group]';
        if(mathjaxClass) {
            d3.select(that.node().parentNode).select(mathjaxClass).style({opacity: 0});
        }
    }

    function selectElementContents(_el) {
        var el = _el.node();
        var range = document.createRange();
        range.selectNodeContents(el);
        var sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
        el.focus();
    }

    function appendEditable() {
        var gd = Lib.getPlotDiv(that.node()),
            plotDiv = d3.select(gd),
            container = plotDiv.select('.svg-container'),
            div = container.append('div');
        div.classed('plugin-editable editable', true)
            .style({
                position: 'absolute',
                'font-family': that.style('font-family') || 'Arial',
                'font-size': that.style('font-size') || 12,
                color: options.fill || that.style('fill') || 'black',
                opacity: 1,
                'background-color': options.background || 'transparent',
                outline: '#ffffff33 1px solid',
                margin: [-parseFloat(that.style('font-size')) / 8 + 1, 0, 0, -1].join('px ') + 'px',
                padding: '0',
                'box-sizing': 'border-box'
            })
            .attr({contenteditable: true})
            .text(options.text || that.attr('data-unformatted'))
            .call(alignHTMLWith(that, container, options))
            .on('blur', function() {
                gd._editing = false;
                that.text(this.textContent)
                    .style({opacity: 1});
                var svgClass = d3.select(this).attr('class'),
                    mathjaxClass;
                if(svgClass) mathjaxClass = '.' + svgClass.split(' ')[0] + '-math-group';
                else mathjaxClass = '[class*=-math-group]';
                if(mathjaxClass) {
                    d3.select(that.node().parentNode).select(mathjaxClass).style({opacity: 0});
                }
                var text = this.textContent;
                d3.select(this).transition().duration(0).remove();
                d3.select(document).on('mouseup', null);
                dispatch.edit.call(that, text);
            })
            .on('focus', function() {
                var context = this;
                gd._editing = true;
                d3.select(document).on('mouseup', function() {
                    if(d3.event.target === context) return false;
                    if(document.activeElement === div.node()) div.node().blur();
                });
            })
            .on('keyup', function() {
                if(d3.event.which === 27) {
                    gd._editing = false;
                    that.style({opacity: 1});
                    d3.select(this)
                        .style({opacity: 0})
                        .on('blur', function() { return false; })
                        .transition().remove();
                    dispatch.cancel.call(that, this.textContent);
                }
                else {
                    dispatch.input.call(that, this.textContent);
                    d3.select(this).call(alignHTMLWith(that, container, options));
                }
            })
            .on('keydown', function() {
                if(d3.event.which === 13) this.blur();
            })
            .call(selectElementContents); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.svg_text_utils.plainText" id="apidoc.element.plotly.js.svg_text_utils.plainText">
        function <span class="apidocSignatureSpan">plotly.js.svg_text_utils.</span>plainText
        <span class="apidocSignatureSpan">(_str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">plainText = function (_str) {
    // strip out our pseudo-html so we have a readable
    // version to put into text fields
    return (_str || '').replace(STRIP_TAGS, ' ');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    contrastColor = d.borderColor || Color.contrast(traceColor);

// to get custom 'name' labels pass cleanPoint
if(d.nameOverride !== undefined) d.name = d.nameOverride;

if(d.name &amp;&amp; d.zLabelVal === undefined) {
    // strip out our pseudo-html elements from d.name (if it exists at all)
    name = svgTextUtils.<span class="apidocCodeKeywordSpan">plainText</span>(d.name || '');

    if(name.length &gt; 15) name = name.substr(0, 12) + '...';
}

// used by other modules (initially just ternary) that
// manage their own hoverinfo independent of cleanPoint
// the rest of this will still apply, so such modules
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.svg_text_utils.xml_entity_encode" id="apidoc.element.plotly.js.svg_text_utils.xml_entity_encode">
        function <span class="apidocSignatureSpan">plotly.js.svg_text_utils.</span>xml_entity_encode
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">xml_entity_encode = function (str) {
    return str.replace(/&amp;(?!\w+;|\#[0-9]+;| \#x[0-9A-F]+;)/g, '&amp;amp;');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                    style = encodeForHTML(extraStyle) + (style ? ';' + style : '');
                }

                return tspanStart + (style ? ' style="' + style + '"' : '') + '&gt;
;';
            }
        }
        else {
            return exports.<span class="apidocCodeKeywordSpan">xml_entity_encode</span>(d).replace(/&lt;/g, '&amp;lt;'
;);
        }
    });

var indices = [];
for(var index = result.indexOf('&lt;br&gt;'); index &gt; 0; index = result.indexOf('&lt;br&gt;', index
 + 1)) {
    indices.push(index);
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.ternary" id="apidoc.module.plotly.js.ternary">module plotly.js.ternary</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.ternary.ternary" id="apidoc.element.plotly.js.ternary.ternary">
        function <span class="apidocSignatureSpan">plotly.js.</span>ternary
        <span class="apidocSignatureSpan">(options, fullLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Ternary(options, fullLayout) {
    this.id = options.id;
    this.graphDiv = options.graphDiv;
    this.init(fullLayout);
    this.makeFramework();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.ternary.prototype" id="apidoc.module.plotly.js.ternary.prototype">module plotly.js.ternary.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.ternary.prototype.adjustLayout" id="apidoc.element.plotly.js.ternary.prototype.adjustLayout">
        function <span class="apidocSignatureSpan">plotly.js.ternary.prototype.</span>adjustLayout
        <span class="apidocSignatureSpan">(ternaryLayout, graphSize)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">adjustLayout = function (ternaryLayout, graphSize) {
    var _this = this,
        domain = ternaryLayout.domain,
        xDomainCenter = (domain.x[0] + domain.x[1]) / 2,
        yDomainCenter = (domain.y[0] + domain.y[1]) / 2,
        xDomain = domain.x[1] - domain.x[0],
        yDomain = domain.y[1] - domain.y[0],
        wmax = xDomain * graphSize.w,
        hmax = yDomain * graphSize.h,
        sum = ternaryLayout.sum,
        amin = ternaryLayout.aaxis.min,
        bmin = ternaryLayout.baxis.min,
        cmin = ternaryLayout.caxis.min;

    var x0, y0, w, h, xDomainFinal, yDomainFinal;

    if(wmax &gt; w_over_h * hmax) {
        h = hmax;
        w = h * w_over_h;
    }
    else {
        w = wmax;
        h = w / w_over_h;
    }

    xDomainFinal = xDomain * w / wmax;
    yDomainFinal = yDomain * h / hmax;

    x0 = graphSize.l + graphSize.w * xDomainCenter - w / 2;
    y0 = graphSize.t + graphSize.h * (1 - yDomainCenter) - h / 2;

    _this.x0 = x0;
    _this.y0 = y0;
    _this.w = w;
    _this.h = h;
    _this.sum = sum;

    // set up the x and y axis objects we'll use to lay out the points
    _this.xaxis = {
        type: 'linear',
        range: [amin + 2 * cmin - sum, sum - amin - 2 * bmin],
        domain: [
            xDomainCenter - xDomainFinal / 2,
            xDomainCenter + xDomainFinal / 2
        ],
        _id: 'x'
    };
    setConvert(_this.xaxis, _this.graphDiv._fullLayout);
    _this.xaxis.setScale();

    _this.yaxis = {
        type: 'linear',
        range: [amin, sum - bmin - cmin],
        domain: [
            yDomainCenter - yDomainFinal / 2,
            yDomainCenter + yDomainFinal / 2
        ],
        _id: 'y'
    };
    setConvert(_this.yaxis, _this.graphDiv._fullLayout);
    _this.yaxis.setScale();

    // set up the modified axes for tick drawing
    var yDomain0 = _this.yaxis.domain[0];

    // aaxis goes up the left side. Set it up as a y axis, but with
    // fictitious angles and domain, but then rotate and translate
    // it into place at the end
    var aaxis = _this.aaxis = extendFlat({}, ternaryLayout.aaxis, {
        visible: true,
        range: [amin, sum - bmin - cmin],
        side: 'left',
        _counterangle: 30,
        // tickangle = 'auto' means 0 anyway for a y axis, need to coerce to 0 here
        // so we can shift by 30.
        tickangle: (+ternaryLayout.aaxis.tickangle || 0) - 30,
        domain: [yDomain0, yDomain0 + yDomainFinal * w_over_h],
        _axislayer: _this.layers.aaxis,
        _gridlayer: _this.layers.agrid,
        _pos: 0, // _this.xaxis.domain[0] * graphSize.w,
        _id: 'y',
        _length: w,
        _gridpath: 'M0,0l' + h + ',-' + (w / 2)
    });
    setConvert(aaxis, _this.graphDiv._fullLayout);
    aaxis.setScale();

    // baxis goes across the bottom (backward). We can set it up as an x axis
    // without any enclosing transformation.
    var baxis = _this.baxis = extendFlat({}, ternaryLayout.baxis, {
        visible: true,
        range: [sum - amin - cmin, bmin],
        side: 'bottom',
        _counterangle: 30,
        domain: _this.xaxis.domain,
        _axislayer: _this.layers.baxis,
        _gridlayer: _this.layers.bgrid,
        _counteraxis: _this.aaxis,
        _pos: 0, // (1 - yDomain0) * graphSize.h,
        _id: 'x',
        _length: w,
        _gridpath: 'M0,0l-' + (w / 2) + ',-' + h
    });
    setConvert(baxis, _this.graphDiv._fullLayout);
    baxis.setScale();
    aaxis._counteraxis = baxis;

    // caxis goes down the right side. Set it up as a y axis, with
    // post-transformation similar to aaxis
    var caxis = _this.caxis = extendFlat({}, ternaryLayout.caxis, {
        visible: true,
        range: [sum - amin - bmin, cmin],
        side: 'right',
        _counterangle: 30,
        tickangle: (+ternaryLayout.caxis.tickangle || 0) + 30,
        domain: [yDomain0, yDomain0 + yDomainFinal * w_over_h],
        _axislayer: _this.layers.caxis,
        _gridlayer: _this.layers.cgrid,
        _counteraxis: _this.baxis,
        _pos: 0, // _this.xaxis.domain[1] * graphSize.w,
        _id: 'y',
        _length: w,
        _gri ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// TODO don't reset projection on all graph edits
_this.projection = null;

_this.setScale = createGeoScale(geoLayout, graphSize);
_this.makeProjection(geoLayout);
_this.makePath();
_this.<span class="apidocCodeKeywordSpan">adjustLayout</span>(geoLayout, graphSize);

_this.zoom = createGeoZoom(_this, geoLayout);
_this.zoomReset = createGeoZoomReset(_this, geoLayout);
_this.mockAxis = createMockAxis(fullLayout);

_this.framework
    .call(_this.zoom)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.ternary.prototype.drawAxes" id="apidoc.element.plotly.js.ternary.prototype.drawAxes">
        function <span class="apidocSignatureSpan">plotly.js.ternary.prototype.</span>drawAxes
        <span class="apidocSignatureSpan">(doTitles)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">drawAxes = function (doTitles) {
    var _this = this,
        gd = _this.graphDiv,
        titlesuffix = _this.id.substr(7) + 'title',
        aaxis = _this.aaxis,
        baxis = _this.baxis,
        caxis = _this.caxis;
    // 3rd arg true below skips titles, so we can configure them
    // correctly later on.
    Axes.doTicks(gd, aaxis, true);
    Axes.doTicks(gd, baxis, true);
    Axes.doTicks(gd, caxis, true);

    if(doTitles) {
        var apad = Math.max(aaxis.showticklabels ? aaxis.tickfont.size / 2 : 0,
            (caxis.showticklabels ? caxis.tickfont.size * 0.75 : 0) +
            (caxis.ticks === 'outside' ? caxis.ticklen * 0.87 : 0));
        Titles.draw(gd, 'a' + titlesuffix, {
            propContainer: aaxis,
            propName: _this.id + '.aaxis.title',
            dfltName: 'Component A',
            attributes: {
                x: _this.x0 + _this.w / 2,
                y: _this.y0 - aaxis.titlefont.size / 3 - apad,
                'text-anchor': 'middle'
            }
        });

        var bpad = (baxis.showticklabels ? baxis.tickfont.size : 0) +
            (baxis.ticks === 'outside' ? baxis.ticklen : 0) + 3;

        Titles.draw(gd, 'b' + titlesuffix, {
            propContainer: baxis,
            propName: _this.id + '.baxis.title',
            dfltName: 'Component B',
            attributes: {
                x: _this.x0 - bpad,
                y: _this.y0 + _this.h + baxis.titlefont.size * 0.83 + bpad,
                'text-anchor': 'middle'
            }
        });

        Titles.draw(gd, 'c' + titlesuffix, {
            propContainer: caxis,
            propName: _this.id + '.caxis.title',
            dfltName: 'Component C',
            attributes: {
                x: _this.x0 + _this.w + bpad,
                y: _this.y0 + _this.h + caxis.titlefont.size * 0.83 + bpad,
                'text-anchor': 'middle'
            }
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
_this.layers.aaxis.attr('transform', aTransform);
_this.layers.agrid.attr('transform', aTransform);

var cTransform = 'translate(' + (x0 + w / 2) + ',' + y0 + ')rotate(-30)';
_this.layers.caxis.attr('transform', cTransform);
_this.layers.cgrid.attr('transform', cTransform);

_this.<span class="apidocCodeKeywordSpan">drawAxes</span>(true);

// remove crispEdges - all the off-square angles in ternary plots
// make these counterproductive.
_this.plotContainer.selectAll('.crisp').classed('crisp', false);

var axlines = _this.layers.axlines;
axlines.select('.aline')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.ternary.prototype.init" id="apidoc.element.plotly.js.ternary.prototype.init">
        function <span class="apidocSignatureSpan">plotly.js.ternary.prototype.</span>init
        <span class="apidocSignatureSpan">(fullLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (fullLayout) {
    this.container = fullLayout._ternarylayer;
    this.defs = fullLayout._defs;
    this.layoutId = fullLayout._uid;
    this.traceHash = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Plotly.plot = function(gd, data, layout, config) {
var frames;

gd = helpers.getGraphDiv(gd);

// Events.init is idempotent and bails early if gd has already been init'd
Events.<span class="apidocCodeKeywordSpan">init</span>(gd);

if(Lib.isPlainObject(data)) {
    var obj = data;
    data = obj.data;
    layout = obj.layout;
    config = obj.config;
    frames = obj.frames;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.ternary.prototype.initInteractions" id="apidoc.element.plotly.js.ternary.prototype.initInteractions">
        function <span class="apidocSignatureSpan">plotly.js.ternary.prototype.</span>initInteractions
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">initInteractions = function () {
    var _this = this,
        dragger = _this.layers.plotbg.select('path').node(),
        gd = _this.graphDiv,
        zoomContainer = _this.layers.zoom;

    // use plotbg for the main interactions
    var dragOptions = {
        element: dragger,
        gd: gd,
        plotinfo: {plot: zoomContainer},
        doubleclick: doubleClick,
        subplot: _this.id,
        prepFn: function(e, startX, startY) {
            // these aren't available yet when initInteractions
            // is called
            dragOptions.xaxes = [_this.xaxis];
            dragOptions.yaxes = [_this.yaxis];
            var dragModeNow = gd._fullLayout.dragmode;
            if(e.shiftKey) {
                if(dragModeNow === 'pan') dragModeNow = 'zoom';
                else dragModeNow = 'pan';
            }

            if(dragModeNow === 'lasso') dragOptions.minDrag = 1;
            else dragOptions.minDrag = undefined;

            if(dragModeNow === 'zoom') {
                dragOptions.moveFn = zoomMove;
                dragOptions.doneFn = zoomDone;
                zoomPrep(e, startX, startY);
            }
            else if(dragModeNow === 'pan') {
                dragOptions.moveFn = plotDrag;
                dragOptions.doneFn = dragDone;
                panPrep();
                clearSelect();
            }
            else if(dragModeNow === 'select' || dragModeNow === 'lasso') {
                prepSelect(e, startX, startY, dragOptions, dragModeNow);
            }
        }
    };

    var x0, y0, mins0, span0, mins, lum, path0, dimmed, zb, corners;

    function zoomPrep(e, startX, startY) {
        var dragBBox = dragger.getBoundingClientRect();
        x0 = startX - dragBBox.left;
        y0 = startY - dragBBox.top;
        mins0 = {
            a: _this.aaxis.range[0],
            b: _this.baxis.range[1],
            c: _this.caxis.range[1]
        };
        mins = mins0;
        span0 = _this.aaxis.range[1] - mins0.a;
        lum = tinycolor(_this.graphDiv._fullLayout[_this.id].bgcolor).getLuminance();
        path0 = 'M0,' + _this.h + 'L' + (_this.w / 2) + ', 0L' + _this.w + ',' + _this.h + 'Z';
        dimmed = false;

        zb = zoomContainer.append('path')
            .attr('class', 'zoombox')
            .style({
                'fill': lum &gt; 0.2 ? 'rgba(0,0,0,0)' : 'rgba(255,255,255,0)',
                'stroke-width': 0
            })
            .attr('d', path0);

        corners = zoomContainer.append('path')
            .attr('class', 'zoombox-corners')
            .style({
                fill: Color.background,
                stroke: Color.defaultLine,
                'stroke-width': 1,
                opacity: 0
            })
            .attr('d', 'M0,0Z');

        clearSelect();
    }

    function getAFrac(x, y) { return 1 - (y / _this.h); }
    function getBFrac(x, y) { return 1 - ((x + (_this.h - y) / Math.sqrt(3)) / _this.w); }
    function getCFrac(x, y) { return ((x - (_this.h - y) / Math.sqrt(3)) / _this.w); }

    function zoomMove(dx0, dy0) {
        var x1 = x0 + dx0,
            y1 = y0 + dy0,
            afrac = Math.max(0, Math.min(1, getAFrac(x0, y0), getAFrac(x1, y1))),
            bfrac = Math.max(0, Math.min(1, getBFrac(x0, y0), getBFrac(x1, y1))),
            cfrac = Math.max(0, Math.min(1, getCFrac(x0, y0), getCFrac(x1, y1))),
            xLeft = ((afrac / 2) + cfrac) * _this.w,
            xRight = (1 - (afrac / 2) - bfrac) * _this.w,
            xCenter = (xLeft + xRight) / 2,
            xSpan = xRight - xLeft,
            yBottom = (1 - afrac) * _this.h,
            yTop = yBottom - xSpan / w_over_h;

        if(xSpan &lt; constants.MINZOOM) {
            mins = mins0;
            zb.attr('d', path0);
            corners.attr('d', 'M0,0Z');
        }
        else {
            mins = {
                a: mins0.a + afrac * span0,
                b: mins0.b + bfrac * span0,
                c: mins0.c + cfrac * span0
            };
            zb.attr('d', path0 + 'M' + xLeft + ',' + yBottom +
                'H' + xRight + 'L' + xCenter + ',' + yTop + ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    .attr('class', function(d) { return 'grid ' + d; })
    .each(function(d) { _this.layers[d] = d3.select(this); });

_this.plotContainer.selectAll('.backplot,.frontplot,.grids')
    .call(Drawing.setClipUrl, clipId);

if(!_this.graphDiv._context.staticPlot) {
    _this.<span class="apidocCodeKeywordSpan">initInteractions</span>();
}
};

var w_over_h = Math.sqrt(4 / 3);

proto.adjustLayout = function(ternaryLayout, graphSize) {
var _this = this,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.ternary.prototype.makeFramework" id="apidoc.element.plotly.js.ternary.prototype.makeFramework">
        function <span class="apidocSignatureSpan">plotly.js.ternary.prototype.</span>makeFramework
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeFramework = function () {
    var _this = this;

    var defGroup = _this.defs.selectAll('g.clips')
        .data([0]);
    defGroup.enter().append('g')
        .classed('clips', true);

    // clippath for this ternary subplot
    var clipId = 'clip' + _this.layoutId + _this.id;
    _this.clipDef = defGroup.selectAll('#' + clipId)
        .data([0]);
    _this.clipDef.enter().append('clipPath').attr('id', clipId)
        .append('path').attr('d', 'M0,0Z');

    // container for everything in this ternary subplot
    _this.plotContainer = _this.container.selectAll('g.' + _this.id)
        .data([0]);
    _this.plotContainer.enter().append('g')
        .classed(_this.id, true);

    _this.layers = {};

    // inside that container, we have one container for the data, and
    // one each for the three axes around it.
    var plotLayers = [
        'draglayer',
        'plotbg',
        'backplot',
        'grids',
        'frontplot',
        'zoom',
        'aaxis', 'baxis', 'caxis', 'axlines'
    ];
    var toplevel = _this.plotContainer.selectAll('g.toplevel')
        .data(plotLayers);
    toplevel.enter().append('g')
        .attr('class', function(d) { return 'toplevel ' + d; })
        .each(function(d) {
            var s = d3.select(this);
            _this.layers[d] = s;

            // containers for different trace types.
            // NOTE - this is different from cartesian, where all traces
            // are in front of grids. Here I'm putting maps behind the grids
            // so the grids will always be visible if they're requested.
            // Perhaps we want that for cartesian too?
            if(d === 'frontplot') s.append('g').classed('scatterlayer', true);
            else if(d === 'backplot') s.append('g').classed('maplayer', true);
            else if(d === 'plotbg') s.append('path').attr('d', 'M0,0Z');
            else if(d === 'axlines') {
                s.selectAll('path').data(['aline', 'bline', 'cline'])
                    .enter().append('path').each(function(d) {
                        d3.select(this).classed(d, true);
                    });
            }
        });

    var grids = _this.plotContainer.select('.grids').selectAll('g.grid')
        .data(['agrid', 'bgrid', 'cgrid']);
    grids.enter().append('g')
        .attr('class', function(d) { return 'grid ' + d; })
        .each(function(d) { _this.layers[d] = d3.select(this); });

    _this.plotContainer.selectAll('.backplot,.frontplot,.grids')
        .call(Drawing.setClipUrl, clipId);

    if(!_this.graphDiv._context.staticPlot) {
        _this.initInteractions();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.clipAngle = null;
    this.setScale = null;
    this.path = null;

    this.zoom = null;
    this.zoomReset = null;

    this.<span class="apidocCodeKeywordSpan">makeFramework</span>();

    this.traceHash = {};
}

module.exports = Geo;

var proto = Geo.prototype;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.ternary.prototype.plot" id="apidoc.element.plotly.js.ternary.prototype.plot">
        function <span class="apidocSignatureSpan">plotly.js.ternary.prototype.</span>plot
        <span class="apidocSignatureSpan">(ternaryCalcData, fullLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">plot = function (ternaryCalcData, fullLayout) {
    var _this = this,
        ternaryLayout = fullLayout[_this.id],
        graphSize = fullLayout._size;

    _this.adjustLayout(ternaryLayout, graphSize);

    Plots.generalUpdatePerTraceModule(_this, ternaryCalcData, ternaryLayout);

    _this.layers.plotbg.select('path').call(Color.fill, ternaryLayout.bgcolor);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        fullLayout._infolayer.selectAll('.cb' + uid).remove();
    }
}

// loop over the base plot modules present on graph
var basePlotModules = fullLayout._basePlotModules;
for(i = 0; i &lt; basePlotModules.length; i++) {
    basePlotModules[i].<span class="apidocCodeKeywordSpan">plot</span>(gd);
}

// keep reference to shape layers in subplots
var layerSubplot = fullLayout._paper.selectAll('.layer-subplot');
fullLayout._shapeSubplotLayers = layerSubplot.selectAll('.shapelayer');

// styling separate from drawing
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.topojson_utils" id="apidoc.module.plotly.js.topojson_utils">module plotly.js.topojson_utils</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.topojson_utils.getTopojsonFeatures" id="apidoc.element.plotly.js.topojson_utils.getTopojsonFeatures">
        function <span class="apidocSignatureSpan">plotly.js.topojson_utils.</span>getTopojsonFeatures
        <span class="apidocSignatureSpan">(trace, topojson)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTopojsonFeatures = function (trace, topojson) {
    var layer = locationmodeToLayer[trace.locationmode],
        obj = topojson.objects[layer];

    return topojsonFeature(topojson, obj).features;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.topojson_utils.getTopojsonName" id="apidoc.element.plotly.js.topojson_utils.getTopojsonName">
        function <span class="apidocSignatureSpan">plotly.js.topojson_utils.</span>getTopojsonName
        <span class="apidocSignatureSpan">(geoLayout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTopojsonName = function (geoLayout) {
    return [
        geoLayout.scope.replace(/ /g, '-'), '_',
        geoLayout.resolution.toString(), 'm'
    ].join('');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Fx.loneUnhover(fullLayout._toppaper);
    });

    _this.framework.on('click', function() {
Fx.click(_this.graphDiv, d3.event);
    });

    topojsonNameNew = topojsonUtils.<span class="apidocCodeKeywordSpan">getTopojsonName</span>(geoLayout);

    if(_this.topojson === null || topojsonNameNew !== _this.topojsonName) {
_this.topojsonName = topojsonNameNew;

if(PlotlyGeoAssets.topojson[_this.topojsonName] !== undefined) {
    _this.topojson = PlotlyGeoAssets.topojson[_this.topojsonName];
    _this.onceTopojsonIsLoaded(geoCalcData, geoLayout);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.topojson_utils.getTopojsonPath" id="apidoc.element.plotly.js.topojson_utils.getTopojsonPath">
        function <span class="apidocSignatureSpan">plotly.js.topojson_utils.</span>getTopojsonPath
        <span class="apidocSignatureSpan">(topojsonURL, topojsonName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTopojsonPath = function (topojsonURL, topojsonName) {
    return topojsonURL + topojsonName + '.json';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        _this.topojsonName = topojsonNameNew;

        if(PlotlyGeoAssets.topojson[_this.topojsonName] !== undefined) {
_this.topojson = PlotlyGeoAssets.topojson[_this.topojsonName];
_this.onceTopojsonIsLoaded(geoCalcData, geoLayout);
        }
        else {
topojsonPath = topojsonUtils.<span class="apidocCodeKeywordSpan">getTopojsonPath</span>(
    _this.topojsonURL,
    _this.topojsonName
);

promises.push(new Promise(function(resolve, reject) {
    d3.json(topojsonPath, function(error, topojson) {
        if(error) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.transform" id="apidoc.module.plotly.js.transform">module plotly.js.transform</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.transform.transform" id="apidoc.element.plotly.js.transform.transform">
        function <span class="apidocSignatureSpan">plotly.js.</span>transform
        <span class="apidocSignatureSpan">(dataIn, state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transform(dataIn, state) {
    var dataOut = [];

    for(var i = 0; i &lt; dataIn.length; i++) {
        var traceIn = dataIn[i];

        if(traceIn.type !== 'candlestick') {
            dataOut.push(traceIn);
            continue;
        }

        dataOut.push(
            makeTrace(traceIn, state, 'increasing'),
            makeTrace(traceIn, state, 'decreasing')
        );
    }

    helpers.addRangeSlider(dataOut, state.layout);

    return dataOut;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
dataOut = [fullTrace];

    for(var i = 0; i &lt; container.length; i++) {
var transform = container[i],
    _module = transformsRegistry[transform.type];

if(_module &amp;&amp; _module.transform) {
    dataOut = _module.<span class="apidocCodeKeywordSpan">transform</span>(dataOut, {
        transform: transform,
        fullTrace: fullTrace,
        fullData: fullData,
        layout: layout,
        fullLayout: fullLayout,
        transformIndex: i
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.transform.calcTransform" id="apidoc.element.plotly.js.transform.calcTransform">
        function <span class="apidocSignatureSpan">plotly.js.transform.</span>calcTransform
        <span class="apidocSignatureSpan">(gd, trace, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function calcTransform(gd, trace, opts) {
    var direction = opts.direction,
        filterFn = helpers.getFilterFn(direction);

    var open = trace.open,
        high = trace.high,
        low = trace.low,
        close = trace.close;

    var len = open.length,
        x = [],
        y = [];

    var appendX = trace._fullInput.x ?
        function(i) {
            var v = trace.x[i];
            x.push(v, v, v, v, v, v);
        } :
        function(i) {
            x.push(i, i, i, i, i, i);
        };

    var appendY = function(o, h, l, c) {
        y.push(l, o, c, c, c, h);
    };

    for(var i = 0; i &lt; len; i++) {
        if(filterFn(open[i], close[i])) {
            appendX(i);
            appendY(open[i], high[i], low[i], close[i]);
        }
    }

    trace.x = x;
    trace.y = y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        for(j = 0; j &lt; trace.transforms.length; j++) {
            var transform = trace.transforms[j];

            _module = transformsRegistry[transform.type];
            if(_module &amp;&amp; _module.calcTransform) {
                hasCalcTransform = true;
                _module.<span class="apidocCodeKeywordSpan">calcTransform</span>(gd, trace, transform);
            }
        }
    }
}

// clear stuff that should recomputed in 'regular' loop
if(hasCalcTransform) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.transform.supplyDefaults" id="apidoc.element.plotly.js.transform.supplyDefaults">
        function <span class="apidocSignatureSpan">plotly.js.transform.</span>supplyDefaults
        <span class="apidocSignatureSpan">(transformIn, traceOut, layout, traceIn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">supplyDefaults = function (transformIn, traceOut, layout, traceIn) {
    helpers.clearEphemeralTransformOpts(traceIn);
    helpers.copyOHLC(transformIn, traceOut);

    return transformIn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    gd._replotPending = true;
    return Promise.reject();
} else {
    // we're going ahead with a replot now
    gd._replotPending = false;
}

Plots.<span class="apidocCodeKeywordSpan">supplyDefaults</span>(gd);

var fullLayout = gd._fullLayout;

// Polar plots
if(data &amp;&amp; data[0] &amp;&amp; data[0].r) return plotPolar(gd, data, layout);

// so we don't try to re-call Plotly.plot from inside
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.plotly.js.unhover" id="apidoc.module.plotly.js.unhover">module plotly.js.unhover</a></h1>


    <h2>
        <a href="#apidoc.element.plotly.js.unhover.raw" id="apidoc.element.plotly.js.unhover.raw">
        function <span class="apidocSignatureSpan">plotly.js.unhover.</span>raw
        <span class="apidocSignatureSpan">(gd, evt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unhoverRaw(gd, evt) {
    var fullLayout = gd._fullLayout;
    var oldhoverdata = gd._hoverdata;

    if(!evt) evt = {};
    if(evt.target &amp;&amp;
       Events.triggerHandler(gd, 'plotly_beforehover', evt) === false) {
        return;
    }

    fullLayout._hoverlayer.selectAll('g').remove();
    fullLayout._hoverlayer.selectAll('line').remove();
    fullLayout._hoverlayer.selectAll('circle').remove();
    gd._hoverdata = undefined;

    if(evt.target &amp;&amp; oldhoverdata) {
        gd.emit('plotly_unhover', {
            event: evt,
            points: oldhoverdata
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Important, clear any queued hovers
if(gd._hoverTimer) {
    clearTimeout(gd._hoverTimer);
    gd._hoverTimer = undefined;
}

unhover.<span class="apidocCodeKeywordSpan">raw</span>(gd, evt, subplot);
};


// remove hover effects on mouse out, and emit unhover event
unhover.raw = function unhoverRaw(gd, evt) {
var fullLayout = gd._fullLayout;
var oldhoverdata = gd._hoverdata;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.plotly.js.unhover.wrapped" id="apidoc.element.plotly.js.unhover.wrapped">
        function <span class="apidocSignatureSpan">plotly.js.unhover.</span>wrapped
        <span class="apidocSignatureSpan">(gd, evt, subplot)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrapped = function (gd, evt, subplot) {
    if(typeof gd === 'string') gd = document.getElementById(gd);

    // Important, clear any queued hovers
    if(gd._hoverTimer) {
        clearTimeout(gd._hoverTimer);
        gd._hoverTimer = undefined;
    }

    unhover.raw(gd, evt, subplot);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>